// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package server

import (
	"context"
	"database/sql"
	"github.com/google/wire"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/mikeydub/go-gallery/db/gen/coredb"
	"github.com/mikeydub/go-gallery/service/media"
	"github.com/mikeydub/go-gallery/service/multichain"
	"github.com/mikeydub/go-gallery/service/multichain/indexer"
	"github.com/mikeydub/go-gallery/service/multichain/opensea"
	"github.com/mikeydub/go-gallery/service/multichain/poap"
	"github.com/mikeydub/go-gallery/service/multichain/reservoir"
	"github.com/mikeydub/go-gallery/service/multichain/tezos"
	"github.com/mikeydub/go-gallery/service/multichain/tzkt"
	"github.com/mikeydub/go-gallery/service/multichain/zora"
	"github.com/mikeydub/go-gallery/service/persist"
	"github.com/mikeydub/go-gallery/service/persist/postgres"
	"github.com/mikeydub/go-gallery/service/redis"
	"github.com/mikeydub/go-gallery/service/rpc"
	"github.com/mikeydub/go-gallery/service/rpc/arweave"
	"github.com/mikeydub/go-gallery/service/rpc/ipfs"
	"github.com/mikeydub/go-gallery/service/task"
	"github.com/mikeydub/go-gallery/service/tokenmanage"
	"net/http"
)

// Injectors from inject.go:

// NewMultichainProvider is a wire injector that sets up a multichain provider instance
func NewMultichainProvider(ctx context.Context, envFunc func()) (*multichain.Provider, func()) {
	serverEnvInit := setEnv(envFunc)
	db, cleanup := newPqClient(serverEnvInit)
	pool, cleanup2 := newPgxClient(serverEnvInit)
	repositories := postgres.NewRepositories(db, pool)
	queries := newQueries(pool)
	cache := newCommunitiesCache()
	client := _wireClientValue
	ethereumProvider := ethProviderSet(serverEnvInit, client)
	tezosProvider := tezosProviderSet(serverEnvInit, client)
	optimismProvider := optimismProviderSet(client)
	arbitrumProvider := arbitrumProviderSet(client)
	poapProvider := poapProviderSet(serverEnvInit, client)
	zoraProvider := zoraProviderSet(serverEnvInit, client)
	baseProvider := baseProviderSet(client)
	polygonProvider := polygonProviderSet(client)
	chainProvider := &multichain.ChainProvider{
		Ethereum: ethereumProvider,
		Tezos:    tezosProvider,
		Optimism: optimismProvider,
		Arbitrum: arbitrumProvider,
		Poap:     poapProvider,
		Zora:     zoraProvider,
		Base:     baseProvider,
		Polygon:  polygonProvider,
	}
	provider := multichainProviderSet(ctx, repositories, queries, cache, chainProvider)
	return provider, func() {
		cleanup2()
		cleanup()
	}
}

var (
	_wireClientValue = &http.Client{Timeout: 0}
)

func multichainProviderSet(contextContext context.Context, repositories *postgres.Repositories, queries *coredb.Queries, cache *redis.Cache, chainProvider *multichain.ChainProvider) *multichain.Provider {
	client := task.NewClient(contextContext)
	manager := tokenmanage.New(contextContext, client, cache)
	submitTokensF := newSubmitBatch(manager)
	providerLookup := newProviderLookup(chainProvider)
	ethclientClient := rpc.NewEthClient()
	shell := ipfs.NewShell()
	goarClient := arweave.NewClient()
	customMetadataHandlers := media.NewCustomMetadataHandlers(ethclientClient, shell, goarClient)
	provider := &multichain.Provider{
		Repos:                  repositories,
		Queries:                queries,
		SubmitTokens:           submitTokensF,
		Chains:                 providerLookup,
		CustomMetadataHandlers: customMetadataHandlers,
	}
	return provider
}

func ethProviderSet(serverEnvInit envInit, client *http.Client) *multichain.EthereumProvider {
	ethclientClient := rpc.NewEthClient()
	provider := indexer.NewProvider(client, ethclientClient)
	chain := _wireChainValue
	openseaProvider := newOpenseaProvider(client, chain)
	ethereumProvider := ethProvidersConfig(provider, openseaProvider)
	return ethereumProvider
}

var (
	_wireChainValue = persist.ChainETH
)

func newOpenseaProvider(client *http.Client, chain persist.Chain) *opensea.Provider {
	provider := reservoir.NewProvider(client, chain)
	openseaProvider := opensea.NewProvider(client, chain, provider)
	return openseaProvider
}

func ethProvidersConfig(indexerProvider *indexer.Provider, openseaProvider *opensea.Provider) *multichain.EthereumProvider {
	ethereumProvider := &multichain.EthereumProvider{
		ContractRefresher:                indexerProvider,
		ContractFetcher:                  openseaProvider,
		ContractsOwnerFetcher:            indexerProvider,
		TokenDescriptorsFetcher:          openseaProvider,
		TokenMetadataFetcher:             openseaProvider,
		TokensContractFetcher:            openseaProvider,
		TokensIncrementalContractFetcher: openseaProvider,
		TokensIncrementalOwnerFetcher:    openseaProvider,
		TokensOwnerFetcher:               openseaProvider,
		Verifier:                         indexerProvider,
	}
	return ethereumProvider
}

func tezosProviderSet(serverEnvInit envInit, client *http.Client) *multichain.TezosProvider {
	provider := tezos.NewProvider(client)
	tzktProvider := tzkt.NewProvider(client)
	tezosProvider := tezosProvidersConfig(provider, tzktProvider)
	return tezosProvider
}

func tezosProvidersConfig(tezosProvider *tezos.Provider, tzktProvider *tzkt.Provider) *multichain.TezosProvider {
	multichainTezosProvider := &multichain.TezosProvider{
		ContractsOwnerFetcher:            tzktProvider,
		TokenDescriptorsFetcher:          tzktProvider,
		TokenMetadataFetcher:             tzktProvider,
		TokensContractFetcher:            tzktProvider,
		TokensIncrementalContractFetcher: tzktProvider,
		TokensIncrementalOwnerFetcher:    tzktProvider,
		TokensOwnerFetcher:               tzktProvider,
		Verifier:                         tezosProvider,
	}
	return multichainTezosProvider
}

func optimismProviderSet(client *http.Client) *multichain.OptimismProvider {
	chain := _wirePersistChainValue
	provider := newOpenseaProvider(client, chain)
	optimismProvider := optimismProvidersConfig(provider)
	return optimismProvider
}

var (
	_wirePersistChainValue = persist.ChainOptimism
)

func optimismProvidersConfig(openseaProvider *opensea.Provider) *multichain.OptimismProvider {
	optimismProvider := &multichain.OptimismProvider{
		TokenDescriptorsFetcher:       openseaProvider,
		TokenMetadataFetcher:          openseaProvider,
		TokensContractFetcher:         openseaProvider,
		TokensIncrementalOwnerFetcher: openseaProvider,
		TokensOwnerFetcher:            openseaProvider,
	}
	return optimismProvider
}

func arbitrumProviderSet(client *http.Client) *multichain.ArbitrumProvider {
	chain := _wireChainValue2
	provider := newOpenseaProvider(client, chain)
	arbitrumProvider := arbitrumProvidersConfig(provider)
	return arbitrumProvider
}

var (
	_wireChainValue2 = persist.ChainArbitrum
)

func arbitrumProvidersConfig(openseaProvider *opensea.Provider) *multichain.ArbitrumProvider {
	arbitrumProvider := &multichain.ArbitrumProvider{
		TokenDescriptorsFetcher:       openseaProvider,
		TokenMetadataFetcher:          openseaProvider,
		TokensContractFetcher:         openseaProvider,
		TokensIncrementalOwnerFetcher: openseaProvider,
		TokensOwnerFetcher:            openseaProvider,
	}
	return arbitrumProvider
}

func poapProviderSet(serverEnvInit envInit, client *http.Client) *multichain.PoapProvider {
	provider := poap.NewProvider(client)
	poapProvider := poapProvidersConfig(provider)
	return poapProvider
}

func poapProvidersConfig(poapProvider *poap.Provider) *multichain.PoapProvider {
	multichainPoapProvider := &multichain.PoapProvider{
		TokenDescriptorsFetcher:       poapProvider,
		TokenMetadataFetcher:          poapProvider,
		TokensContractFetcher:         poapProvider,
		TokensIncrementalOwnerFetcher: poapProvider,
		TokensOwnerFetcher:            poapProvider,
	}
	return multichainPoapProvider
}

func zoraProviderSet(serverEnvInit envInit, client *http.Client) *multichain.ZoraProvider {
	chain := _wireChainValue3
	provider := newOpenseaProvider(client, chain)
	zoraProvider := zora.NewProvider(client)
	multichainZoraProvider := zoraProvidersConfig(provider, zoraProvider)
	return multichainZoraProvider
}

var (
	_wireChainValue3 = persist.ChainZora
)

func zoraProvidersConfig(openseaProvider *opensea.Provider, zoraProvider *zora.Provider) *multichain.ZoraProvider {
	multichainZoraProvider := &multichain.ZoraProvider{
		ContractFetcher:                  openseaProvider,
		ContractsOwnerFetcher:            zoraProvider,
		TokenDescriptorsFetcher:          openseaProvider,
		TokenMetadataFetcher:             openseaProvider,
		TokensContractFetcher:            openseaProvider,
		TokensIncrementalContractFetcher: openseaProvider,
		TokensIncrementalOwnerFetcher:    openseaProvider,
		TokensOwnerFetcher:               openseaProvider,
	}
	return multichainZoraProvider
}

func baseProviderSet(client *http.Client) *multichain.BaseProvider {
	chain := _wireChainValue4
	provider := newOpenseaProvider(client, chain)
	baseProvider := baseProvidersConfig(provider)
	return baseProvider
}

var (
	_wireChainValue4 = persist.ChainBase
)

func baseProvidersConfig(openseaProvider *opensea.Provider) *multichain.BaseProvider {
	baseProvider := &multichain.BaseProvider{
		TokenDescriptorsFetcher:       openseaProvider,
		TokenMetadataFetcher:          openseaProvider,
		TokensContractFetcher:         openseaProvider,
		TokensIncrementalOwnerFetcher: openseaProvider,
		TokensOwnerFetcher:            openseaProvider,
	}
	return baseProvider
}

func polygonProviderSet(client *http.Client) *multichain.PolygonProvider {
	chain := _wireChainValue5
	provider := newOpenseaProvider(client, chain)
	polygonProvider := polygonProvidersConfig(provider)
	return polygonProvider
}

var (
	_wireChainValue5 = persist.ChainPolygon
)

func polygonProvidersConfig(openseaProvider *opensea.Provider) *multichain.PolygonProvider {
	polygonProvider := &multichain.PolygonProvider{
		TokenDescriptorsFetcher:       openseaProvider,
		TokenMetadataFetcher:          openseaProvider,
		TokensContractFetcher:         openseaProvider,
		TokensIncrementalOwnerFetcher: openseaProvider,
		TokensOwnerFetcher:            openseaProvider,
	}
	return polygonProvider
}

// inject.go:

// envInit is a type returned after setting up the environment
// Adding envInit as a dependency to a provider will ensure that the environment is set up prior
// to calling the provider
type envInit struct{}

// customMetadataHandlerSet is a wire provider set for initializing custom metadata handlers
var customMetadataHandlerSet = wire.NewSet(rpc.NewEthClient, ipfs.NewShell, arweave.NewClient, media.NewCustomMetadataHandlers)

// dbConnSet is a wire provider set for initializing a postgres connection
var dbConnSet = wire.NewSet(
	newPqClient,
	newPgxClient,
	newQueries,
)

func setEnv(f func()) envInit {
	f()
	return envInit{}
}

func newPqClient(e envInit) (*sql.DB, func()) {
	pq := postgres.MustCreateClient()
	return pq, func() { pq.Close() }
}

func newPgxClient(envInit) (*pgxpool.Pool, func()) {
	pgx := postgres.NewPgxClient()
	return pgx, func() { pgx.Close() }
}

func newQueries(p *pgxpool.Pool) *coredb.Queries {
	return coredb.New(p)
}

func newProviderLookup(p *multichain.ChainProvider) multichain.ProviderLookup {
	return multichain.ProviderLookup{persist.ChainETH: p.Ethereum, persist.ChainTezos: p.Tezos, persist.ChainOptimism: p.Optimism, persist.ChainArbitrum: p.Arbitrum, persist.ChainPOAP: p.Poap, persist.ChainZora: p.Zora, persist.ChainBase: p.Base, persist.ChainPolygon: p.Polygon}
}

func newCommunitiesCache() *redis.Cache {
	return redis.NewCache(redis.CommunitiesCache)
}

func newSubmitBatch(tm *tokenmanage.Manager) multichain.SubmitTokensF {
	return tm.SubmitBatch
}
