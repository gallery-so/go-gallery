// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package server

import (
	"cloud.google.com/go/cloudtasks/apiv2"
	"context"
	"database/sql"
	"fmt"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/google/wire"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/mikeydub/go-gallery/db/gen/coredb"
	"github.com/mikeydub/go-gallery/env"
	"github.com/mikeydub/go-gallery/service/multichain"
	"github.com/mikeydub/go-gallery/service/multichain/alchemy"
	"github.com/mikeydub/go-gallery/service/multichain/eth"
	"github.com/mikeydub/go-gallery/service/multichain/infura"
	"github.com/mikeydub/go-gallery/service/multichain/opensea"
	"github.com/mikeydub/go-gallery/service/multichain/poap"
	"github.com/mikeydub/go-gallery/service/multichain/reservoir"
	"github.com/mikeydub/go-gallery/service/multichain/tezos"
	"github.com/mikeydub/go-gallery/service/multichain/zora"
	"github.com/mikeydub/go-gallery/service/persist"
	"github.com/mikeydub/go-gallery/service/persist/postgres"
	"github.com/mikeydub/go-gallery/service/redis"
	"github.com/mikeydub/go-gallery/service/rpc"
	"github.com/mikeydub/go-gallery/service/task"
	"github.com/mikeydub/go-gallery/service/tokenmanage"
	"net/http"
)

// Injectors from inject.go:

// NewMultichainProvider is a wire injector that sets up a multichain provider instance
func NewMultichainProvider(ctx context.Context, envFunc func()) (*multichain.Provider, func()) {
	serverEnvInit := setEnv(envFunc)
	db, cleanup := newPqClient(serverEnvInit)
	pool, cleanup2 := newPgxClient(serverEnvInit)
	repositories := postgres.NewRepositories(db, pool)
	queries := newQueries(pool)
	cache := newCommunitiesCache()
	client := task.NewClient(ctx)
	httpClient := _wireClientValue
	serverEthProviderList := ethProviderSet(serverEnvInit, client, httpClient)
	serverOptimismProviderList := optimismProviderSet(httpClient)
	serverTezosProviderList := tezosProviderSet(serverEnvInit, httpClient)
	serverPoapProviderList := poapProviderSet(serverEnvInit, httpClient)
	serverZoraProviderList := zoraProviderSet(serverEnvInit, httpClient)
	serverBaseProviderList := baseProviderSet(httpClient)
	serverPolygonProviderList := polygonProviderSet(httpClient)
	serverArbitrumProviderList := arbitrumProviderSet(httpClient)
	v := newMultichainSet(serverEthProviderList, serverOptimismProviderList, serverTezosProviderList, serverPoapProviderList, serverZoraProviderList, serverBaseProviderList, serverPolygonProviderList, serverArbitrumProviderList)
	manager := tokenmanage.New(ctx, client)
	submitUserTokensF := newManagedTokens(ctx, manager)
	provider := &multichain.Provider{
		Repos:            repositories,
		Queries:          queries,
		Cache:            cache,
		Chains:           v,
		SubmitUserTokens: submitUserTokensF,
	}
	return provider, func() {
		cleanup2()
		cleanup()
	}
}

var (
	_wireClientValue = &http.Client{Timeout: 0}
)

// ethProviderSet is a wire injector that creates the set of Ethereum providers
func ethProviderSet(serverEnvInit envInit, client *cloudtasks.Client, httpClient *http.Client) ethProviderList {
	ethclientClient := rpc.NewEthClient()
	provider := newIndexerProvider(serverEnvInit, httpClient, ethclientClient, client)
	chain := _wireChainValue
	openseaProvider := opensea.NewProvider(ethclientClient, httpClient, chain)
	cache := newTokenProcessingCache()
	syncFailureFallbackProvider := ethFallbackProvider(httpClient, cache)
	alchemyProvider := alchemy.NewProvider(chain, httpClient, cache)
	serverEthProviderList := ethProvidersConfig(provider, openseaProvider, syncFailureFallbackProvider, alchemyProvider)
	return serverEthProviderList
}

var (
	_wireChainValue = persist.ChainETH
)

// ethProvidersConfig is a wire injector that binds multichain interfaces to their concrete Ethereum implementations
func ethProvidersConfig(indexerProvider *eth.Provider, openseaProvider *opensea.Provider, fallbackProvider multichain.SyncFailureFallbackProvider, alchemyProvider *alchemy.Provider) ethProviderList {
	serverEthProviderList := ethRequirements(indexerProvider, indexerProvider, fallbackProvider, alchemyProvider, fallbackProvider, fallbackProvider, indexerProvider, indexerProvider, indexerProvider, indexerProvider, openseaProvider)
	return serverEthProviderList
}

// tezosProviderSet is a wire injector that creates the set of Tezos providers
func tezosProviderSet(serverEnvInit envInit, client *http.Client) tezosProviderList {
	provider := newTzktProvider(serverEnvInit, client)
	tezosObjktProvider := newObjktProvider(serverEnvInit)
	syncWithContractEvalFallbackProvider := tezosFallbackProvider(client, provider, tezosObjktProvider)
	serverTezosProviderList := tezosProvidersConfig(syncWithContractEvalFallbackProvider)
	return serverTezosProviderList
}

// tezosProvidersConfig is a wire injector that binds multichain interfaces to their concrete Tezos implementations
func tezosProvidersConfig(tezosProvider multichain.SyncWithContractEvalFallbackProvider) tezosProviderList {
	serverTezosProviderList := tezosRequirements(tezosProvider, tezosProvider, tezosProvider, tezosProvider)
	return serverTezosProviderList
}

// optimismProviderSet is a wire injector that creates the set of Optimism providers
func optimismProviderSet(client *http.Client) optimismProviderList {
	cache := newTokenProcessingCache()
	serverOptimismProvider := newOptimismProvider(client, cache)
	ethclientClient := rpc.NewEthClient()
	chain := _wirePersistChainValue
	provider := opensea.NewProvider(ethclientClient, client, chain)
	serverOptimismProviderList := optimismProvidersConfig(serverOptimismProvider, provider)
	return serverOptimismProviderList
}

var (
	_wirePersistChainValue = persist.ChainOptimism
)

// optimismProvidersConfig is a wire injector that binds multichain interfaces to their concrete Optimism implementations
func optimismProvidersConfig(optimismProvider2 *optimismProvider, openseaProvier *opensea.Provider) optimismProviderList {
	serverOptimismProviderList := optimismRequirements(optimismProvider2, optimismProvider2, optimismProvider2, optimismProvider2, openseaProvier)
	return serverOptimismProviderList
}

// arbitrumProviderSet is a wire injector that creates the set of Arbitrum providers
func arbitrumProviderSet(client *http.Client) arbitrumProviderList {
	cache := newTokenProcessingCache()
	serverArbitrumProvider := newArbitrumProvider(client, cache)
	ethclientClient := rpc.NewEthClient()
	chain := _wireChainValue2
	provider := opensea.NewProvider(ethclientClient, client, chain)
	serverArbitrumProviderList := arbitrumProvidersConfig(serverArbitrumProvider, provider)
	return serverArbitrumProviderList
}

var (
	_wireChainValue2 = persist.ChainArbitrum
)

// arbitrumProvidersConfig is a wire injector that binds multichain interfaces to their concrete Arbitrum implementations
func arbitrumProvidersConfig(arbitrumProvider2 *arbitrumProvider, openseaProvider *opensea.Provider) arbitrumProviderList {
	serverArbitrumProviderList := arbitrumRequirements(arbitrumProvider2, arbitrumProvider2, arbitrumProvider2, arbitrumProvider2, openseaProvider, arbitrumProvider2)
	return serverArbitrumProviderList
}

// poapProviderSet is a wire injector that creates the set of POAP providers
func poapProviderSet(serverEnvInit envInit, client *http.Client) poapProviderList {
	provider := newPoapProvider(serverEnvInit, client)
	serverPoapProviderList := poapProvidersConfig(provider)
	return serverPoapProviderList
}

// poapProvidersConfig is a wire injector that binds multichain interfaces to their concrete POAP implementations
func poapProvidersConfig(poapProvider *poap.Provider) poapProviderList {
	serverPoapProviderList := poapRequirements(poapProvider, poapProvider, poapProvider, poapProvider, poapProvider)
	return serverPoapProviderList
}

// zoraProviderSet is a wire injector that creates the set of zora providers
func zoraProviderSet(serverEnvInit envInit, client *http.Client) zoraProviderList {
	provider := newZoraProvider(serverEnvInit, client)
	serverZoraProviderList := zoraProvidersConfig(provider)
	return serverZoraProviderList
}

// zoraProvidersConfig is a wire injector that binds multichain interfaces to their concrete zora implementations
func zoraProvidersConfig(zoraProvider *zora.Provider) zoraProviderList {
	serverZoraProviderList := zoraRequirements(zoraProvider, zoraProvider, zoraProvider, zoraProvider, zoraProvider, zoraProvider)
	return serverZoraProviderList
}

func baseProviderSet(client *http.Client) baseProviderList {
	chain := _wireChainValue3
	provider := reservoir.NewProvider(chain, client)
	serverBaseProviderList := baseProvidersConfig(provider)
	return serverBaseProviderList
}

var (
	_wireChainValue3 = persist.ChainBase
)

// baseProvidersConfig is a wire injector that binds multichain interfaces to their concrete base implementations
func baseProvidersConfig(baseProvider *reservoir.Provider) baseProviderList {
	serverBaseProviderList := baseRequirements(baseProvider, baseProvider, baseProvider)
	return serverBaseProviderList
}

// polygonProviderSet is a wire injector that creates the set of polygon providers
func polygonProviderSet(client *http.Client) polygonProviderList {
	cache := newTokenProcessingCache()
	serverPolygonProvider := newPolygonProvider(client, cache)
	ethclientClient := rpc.NewEthClient()
	chain := _wireChainValue4
	provider := opensea.NewProvider(ethclientClient, client, chain)
	serverPolygonProviderList := polygonProvidersConfig(serverPolygonProvider, provider)
	return serverPolygonProviderList
}

var (
	_wireChainValue4 = persist.ChainPolygon
)

// polygonProvidersConfig is a wire injector that binds multichain interfaces to their concrete Polygon implementations
func polygonProvidersConfig(polygonProvider2 *polygonProvider, openseaProvider *opensea.Provider) polygonProviderList {
	serverPolygonProviderList := polygonRequirements(polygonProvider2, polygonProvider2, polygonProvider2, openseaProvider)
	return serverPolygonProviderList
}

func ethFallbackProvider(httpClient *http.Client, r *redis.Cache) multichain.SyncFailureFallbackProvider {
	chain := _wireChainValue5
	provider := alchemy.NewProvider(chain, httpClient, r)
	infuraProvider := infura.NewProvider(httpClient)
	syncFailureFallbackProvider := multichain.SyncFailureFallbackProvider{
		Primary:  provider,
		Fallback: infuraProvider,
	}
	return syncFailureFallbackProvider
}

var (
	_wireChainValue5 = persist.ChainETH
)

func tezosFallbackProvider(httpClient *http.Client, tzktProvider *tezos.Provider, objktProvider *tezos.TezosObjktProvider) multichain.SyncWithContractEvalFallbackProvider {
	v := tezosTokenEvalFunc()
	syncWithContractEvalFallbackProvider := multichain.SyncWithContractEvalFallbackProvider{
		Primary:  tzktProvider,
		Fallback: objktProvider,
		Eval:     v,
	}
	return syncWithContractEvalFallbackProvider
}

// inject.go:

// envInit is a type returned after setting up the environment
// Adding envInit as a dependency to a provider will ensure that the environment is set up prior
// to calling the provider
type envInit struct{}

type ethProviderList []any

type tezosProviderList []any

type optimismProviderList []any

type poapProviderList []any

type zoraProviderList []any

type baseProviderList []any

type polygonProviderList []any

type arbitrumProviderList []any

type optimismProvider struct{ *alchemy.Provider }

type polygonProvider struct{ *alchemy.Provider }

type arbitrumProvider struct{ *alchemy.Provider }

// dbConnSet is a wire provider set for initializing a postgres connection
var dbConnSet = wire.NewSet(
	newPqClient,
	newPgxClient,
	newQueries,
)

func setEnv(f func()) envInit {
	f()
	return envInit{}
}

func newPqClient(e envInit) (*sql.DB, func()) {
	pq := postgres.MustCreateClient()
	return pq, func() { pq.Close() }
}

func newPgxClient(envInit) (*pgxpool.Pool, func()) {
	pgx := postgres.NewPgxClient()
	return pgx, func() { pgx.Close() }
}

func newQueries(p *pgxpool.Pool) *coredb.Queries {
	return coredb.New(p)
}

// ethRequirements is the set of provider interfaces required for Ethereum
func ethRequirements(
	nr multichain.NameResolver,
	v multichain.Verifier,
	tof multichain.TokensOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	cf multichain.ContractsFetcher,
	cr multichain.ContractRefresher,
	tmf multichain.TokenMetadataFetcher,
	tcof multichain.ContractsOwnerFetcher,
	tdf multichain.TokenDescriptorsFetcher,
	osccf multichain.OpenSeaChildContractFetcher,
) ethProviderList {
	return ethProviderList{nr, v, tof, toc, tiof, cf, cr, tmf, tcof, tdf, osccf}
}

// tezosRequirements is the set of provider interfaces required for Tezos
func tezosRequirements(
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tmf multichain.TokenMetadataFetcher,
) tezosProviderList {
	return tezosProviderList{tof, tiof, toc, tmf}
}

// optimismRequirements is the set of provider interfaces required for Optimism
func optimismRequirements(
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tmf multichain.TokenMetadataFetcher, opensea2 multichain.OpenSeaChildContractFetcher,

) optimismProviderList {
	return optimismProviderList{tof, toc, tiof, tmf, opensea2}
}

// arbitrumRequirements is the set of provider interfaces required for Arbitrum
func arbitrumRequirements(
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tmf multichain.TokenMetadataFetcher, opensea2 multichain.OpenSeaChildContractFetcher,

	tdf multichain.TokenDescriptorsFetcher,
) arbitrumProviderList {
	return arbitrumProviderList{tof, toc, tiof, tmf, opensea2, tdf}
}

// poapRequirements is the set of provider interfaces required for POAP
func poapRequirements(
	nr multichain.NameResolver,
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tmf multichain.TokenMetadataFetcher,
) poapProviderList {
	return poapProviderList{nr, tof, tiof, toc, tmf}
}

// zoraRequirements is the set of provider interfaces required for zora
func zoraRequirements(
	nr multichain.ContractsFetcher,
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tcof multichain.ContractsOwnerFetcher,
	tmf multichain.TokenMetadataFetcher,
) zoraProviderList {
	return zoraProviderList{nr, tof, tiof, toc, tcof, tmf}
}

// zoraRequirements is the set of provider interfaces required for zora
func baseRequirements(
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	tdf multichain.TokenDescriptorsFetcher,
) baseProviderList {
	return baseProviderList{tof, tiof, tdf}
}

// polygonRequirements is the set of provider interfaces required for Polygon
func polygonRequirements(
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher, opensea2 multichain.OpenSeaChildContractFetcher,

) polygonProviderList {
	return polygonProviderList{tof, tiof, toc, opensea2}
}

// newMultichain is a wire provider that creates a multichain provider
func newMultichainSet(
	ethProviders ethProviderList,
	optimismProviders optimismProviderList,
	tezosProviders tezosProviderList,
	poapProviders poapProviderList,
	zoraProviders zoraProviderList,
	baseProviders baseProviderList,
	polygonProviders polygonProviderList,
	arbitrumProviders arbitrumProviderList,
) map[persist.Chain][]any {

	dedupe := func(providers []any) []any {
		seen := map[string]bool{}
		deduped := []any{}
		for _, p := range providers {
			if addr := fmt.Sprintf("%p", p); !seen[addr] {
				seen[addr] = true
				deduped = append(deduped, p)
			}
		}
		return deduped
	}

	chainToProviders := map[persist.Chain][]any{}
	chainToProviders[persist.ChainETH] = dedupe(ethProviders)
	chainToProviders[persist.ChainOptimism] = dedupe(optimismProviders)
	chainToProviders[persist.ChainTezos] = dedupe(tezosProviders)
	chainToProviders[persist.ChainPOAP] = dedupe(poapProviders)
	chainToProviders[persist.ChainZora] = dedupe(zoraProviders)
	chainToProviders[persist.ChainBase] = dedupe(baseProviders)
	chainToProviders[persist.ChainPolygon] = dedupe(polygonProviders)
	chainToProviders[persist.ChainArbitrum] = dedupe(arbitrumProviders)
	return chainToProviders
}

func newIndexerProvider(e envInit, httpClient *http.Client, ethClient *ethclient.Client, taskClient *cloudtasks.Client) *eth.Provider {
	return eth.NewProvider(env.GetString("INDEXER_HOST"), httpClient, ethClient, taskClient)
}

func newTzktProvider(e envInit, httpClient *http.Client) *tezos.Provider {
	return tezos.NewProvider(env.GetString("TEZOS_API_URL"), httpClient)
}

func newObjktProvider(e envInit) *tezos.TezosObjktProvider {
	return tezos.NewObjktProvider(env.GetString("IPFS_URL"))
}

func tezosTokenEvalFunc() func(context.Context, multichain.ChainAgnosticToken) bool {
	return func(ctx context.Context, token multichain.ChainAgnosticToken) bool {
		return tezos.IsSigned(ctx, token) && tezos.ContainsTezosKeywords(ctx, token)
	}
}

func newPoapProvider(e envInit, c *http.Client) *poap.Provider {
	return poap.NewProvider(c, env.GetString("POAP_API_KEY"), env.GetString("POAP_AUTH_TOKEN"))
}

func newZoraProvider(e envInit, c *http.Client) *zora.Provider {
	return zora.NewProvider(c)
}

func newOptimismProvider(c *http.Client, r *redis.Cache) *optimismProvider {
	return &optimismProvider{alchemy.NewProvider(persist.ChainOptimism, c, r)}
}

func newPolygonProvider(c *http.Client, r *redis.Cache) *polygonProvider {
	return &polygonProvider{alchemy.NewProvider(persist.ChainPolygon, c, r)}
}

func newArbitrumProvider(c *http.Client, r *redis.Cache) *arbitrumProvider {
	return &arbitrumProvider{alchemy.NewProvider(persist.ChainArbitrum, c, r)}
}

func newCommunitiesCache() *redis.Cache {
	return redis.NewCache(redis.CommunitiesCache)
}

func newTokenProcessingCache() *redis.Cache {
	return redis.NewCache(redis.TokenProcessingMetadataCache)
}

func newManagedTokens(ctx context.Context, tm *tokenmanage.Manager) multichain.SubmitUserTokensF {
	return func(ctx context.Context, userID persist.DBID, tokenIDs []persist.DBID, tokens []persist.TokenIdentifiers) error {
		if len(tokenIDs) == 0 {
			return nil
		}
		return tm.SubmitUser(ctx, userID, tokenIDs, tokens)
	}
}
