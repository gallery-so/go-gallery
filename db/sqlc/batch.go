// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: batch.go
package sqlc

import (
	"context"
	"database/sql"

	"github.com/jackc/pgx/v4"
	"github.com/mikeydub/go-gallery/service/persist"
)

const getAddressByDetailsBatch = `-- name: GetAddressByDetailsBatch :batchone
SELECT id, created_at, last_updated, deleted, version, address_value, chain FROM addresses WHERE address_value = $1 AND chain = $2 AND deleted = false
`

type GetAddressByDetailsBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetAddressByDetailsBatchParams struct {
	AddressValue persist.AddressValue
	Chain        persist.Chain
}

func (q *Queries) GetAddressByDetailsBatch(ctx context.Context, arg []GetAddressByDetailsBatchParams) *GetAddressByDetailsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.AddressValue,
			a.Chain,
		}
		batch.Queue(getAddressByDetailsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAddressByDetailsBatchBatchResults{br, 0}
}

func (b *GetAddressByDetailsBatchBatchResults) QueryRow(f func(int, Address, error)) {
	for {
		row := b.br.QueryRow()
		var i Address
		err := row.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.AddressValue,
			&i.Chain,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetAddressByDetailsBatchBatchResults) Close() error {
	return b.br.Close()
}

const getAddressByIDBatch = `-- name: GetAddressByIDBatch :batchone
SELECT id, created_at, last_updated, deleted, version, address_value, chain FROM addresses WHERE id = $1 AND deleted = false
`

type GetAddressByIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetAddressByIDBatch(ctx context.Context, id []persist.DBID) *GetAddressByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getAddressByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAddressByIDBatchBatchResults{br, 0}
}

func (b *GetAddressByIDBatchBatchResults) QueryRow(f func(int, Address, error)) {
	for {
		row := b.br.QueryRow()
		var i Address
		err := row.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.AddressValue,
			&i.Chain,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetAddressByIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getCollectionByIdBatch = `-- name: GetCollectionByIdBatch :batchone
SELECT id, deleted, owner_user_id, nfts, version, last_updated, created_at, hidden, collectors_note, name, layout FROM collections WHERE id = $1 AND deleted = false
`

type GetCollectionByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetCollectionByIdBatch(ctx context.Context, id []persist.DBID) *GetCollectionByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getCollectionByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetCollectionByIdBatchBatchResults{br, 0}
}

func (b *GetCollectionByIdBatchBatchResults) QueryRow(f func(int, Collection, error)) {
	for {
		row := b.br.QueryRow()
		var i Collection
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerUserID,
			&i.Nfts,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Hidden,
			&i.CollectorsNote,
			&i.Name,
			&i.Layout,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetCollectionByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getCollectionsByGalleryIdBatch = `-- name: GetCollectionsByGalleryIdBatch :batchmany
SELECT c.id, c.deleted, c.owner_user_id, c.nfts, c.version, c.last_updated, c.created_at, c.hidden, c.collectors_note, c.name, c.layout FROM galleries g, unnest(g.collections)
    WITH ORDINALITY AS x(coll_id, coll_ord)
    INNER JOIN collections c ON c.id = x.coll_id
    WHERE g.id = $1 AND g.deleted = false AND c.deleted = false ORDER BY x.coll_ord
`

type GetCollectionsByGalleryIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetCollectionsByGalleryIdBatch(ctx context.Context, id []persist.DBID) *GetCollectionsByGalleryIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getCollectionsByGalleryIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetCollectionsByGalleryIdBatchBatchResults{br, 0}
}

func (b *GetCollectionsByGalleryIdBatchBatchResults) Query(f func(int, []Collection, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Collection
		for rows.Next() {
			var i Collection
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.OwnerUserID,
				&i.Nfts,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Hidden,
				&i.CollectorsNote,
				&i.Name,
				&i.Layout,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetCollectionsByGalleryIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getContractByAddressBatch = `-- name: GetContractByAddressBatch :batchone
select id, deleted, version, created_at, last_updated, name, symbol, address, latest_block, creator_address, chain FROM contracts WHERE address = $1 AND deleted = false
`

type GetContractByAddressBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetContractByAddressBatch(ctx context.Context, address []sql.NullString) *GetContractByAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range address {
		vals := []interface{}{
			a,
		}
		batch.Queue(getContractByAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetContractByAddressBatchBatchResults{br, 0}
}

func (b *GetContractByAddressBatchBatchResults) QueryRow(f func(int, Contract, error)) {
	for {
		row := b.br.QueryRow()
		var i Contract
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Address,
			&i.LatestBlock,
			&i.CreatorAddress,
			&i.Chain,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetContractByAddressBatchBatchResults) Close() error {
	return b.br.Close()
}

const getContractByDetailsBatch = `-- name: GetContractByDetailsBatch :batchone
select id, deleted, version, created_at, last_updated, name, symbol, address, latest_block, creator_address, chain FROM contracts WHERE address = (SELECT ID FROM addresses WHERE addresses.address_value = $1 AND addresses.chain = $2 AND addresses.deleted = false) AND deleted = false
`

type GetContractByDetailsBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetContractByDetailsBatchParams struct {
	AddressValue persist.AddressValue
	Chain        persist.Chain
}

func (q *Queries) GetContractByDetailsBatch(ctx context.Context, arg []GetContractByDetailsBatchParams) *GetContractByDetailsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.AddressValue,
			a.Chain,
		}
		batch.Queue(getContractByDetailsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetContractByDetailsBatchBatchResults{br, 0}
}

func (b *GetContractByDetailsBatchBatchResults) QueryRow(f func(int, Contract, error)) {
	for {
		row := b.br.QueryRow()
		var i Contract
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Address,
			&i.LatestBlock,
			&i.CreatorAddress,
			&i.Chain,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetContractByDetailsBatchBatchResults) Close() error {
	return b.br.Close()
}

const getContractByIDBatch = `-- name: GetContractByIDBatch :batchone
select id, deleted, version, created_at, last_updated, name, symbol, address, latest_block, creator_address, chain FROM contracts WHERE id = $1 AND deleted = false
`

type GetContractByIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetContractByIDBatch(ctx context.Context, id []persist.DBID) *GetContractByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getContractByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetContractByIDBatchBatchResults{br, 0}
}

func (b *GetContractByIDBatchBatchResults) QueryRow(f func(int, Contract, error)) {
	for {
		row := b.br.QueryRow()
		var i Contract
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Address,
			&i.LatestBlock,
			&i.CreatorAddress,
			&i.Chain,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetContractByIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getGalleriesByUserIdBatch = `-- name: GetGalleriesByUserIdBatch :batchmany
SELECT id, deleted, last_updated, created_at, version, owner_user_id, collections FROM galleries WHERE owner_user_id = $1 AND deleted = false
`

type GetGalleriesByUserIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetGalleriesByUserIdBatch(ctx context.Context, ownerUserID []persist.DBID) *GetGalleriesByUserIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range ownerUserID {
		vals := []interface{}{
			a,
		}
		batch.Queue(getGalleriesByUserIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetGalleriesByUserIdBatchBatchResults{br, 0}
}

func (b *GetGalleriesByUserIdBatchBatchResults) Query(f func(int, []Gallery, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Gallery
		for rows.Next() {
			var i Gallery
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Version,
				&i.OwnerUserID,
				&i.Collections,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetGalleriesByUserIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getGalleryByCollectionIdBatch = `-- name: GetGalleryByCollectionIdBatch :batchone
SELECT g.id, g.deleted, g.last_updated, g.created_at, g.version, g.owner_user_id, g.collections FROM galleries g, collections c WHERE c.id = $1 AND c.deleted = false AND $1 = ANY(g.collections) AND g.deleted = false
`

type GetGalleryByCollectionIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetGalleryByCollectionIdBatch(ctx context.Context, id []persist.DBID) *GetGalleryByCollectionIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getGalleryByCollectionIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetGalleryByCollectionIdBatchBatchResults{br, 0}
}

func (b *GetGalleryByCollectionIdBatchBatchResults) QueryRow(f func(int, Gallery, error)) {
	for {
		row := b.br.QueryRow()
		var i Gallery
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Version,
			&i.OwnerUserID,
			&i.Collections,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetGalleryByCollectionIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getGalleryByIdBatch = `-- name: GetGalleryByIdBatch :batchone
SELECT id, deleted, last_updated, created_at, version, owner_user_id, collections FROM galleries WHERE id = $1 AND deleted = false
`

type GetGalleryByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetGalleryByIdBatch(ctx context.Context, id []persist.DBID) *GetGalleryByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getGalleryByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetGalleryByIdBatchBatchResults{br, 0}
}

func (b *GetGalleryByIdBatchBatchResults) QueryRow(f func(int, Gallery, error)) {
	for {
		row := b.br.QueryRow()
		var i Gallery
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Version,
			&i.OwnerUserID,
			&i.Collections,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetGalleryByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getMembershipByMembershipIdBatch = `-- name: GetMembershipByMembershipIdBatch :batchone
SELECT id, deleted, version, created_at, last_updated, token_id, name, asset_url, owners FROM membership WHERE id = $1 AND deleted = false
`

type GetMembershipByMembershipIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetMembershipByMembershipIdBatch(ctx context.Context, id []persist.DBID) *GetMembershipByMembershipIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getMembershipByMembershipIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetMembershipByMembershipIdBatchBatchResults{br, 0}
}

func (b *GetMembershipByMembershipIdBatchBatchResults) QueryRow(f func(int, Membership, error)) {
	for {
		row := b.br.QueryRow()
		var i Membership
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.TokenID,
			&i.Name,
			&i.AssetUrl,
			&i.Owners,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetMembershipByMembershipIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getNftByIdBatch = `-- name: GetNftByIdBatch :batchone
SELECT id, deleted, version, last_updated, created_at, name, description, collectors_note, external_url, creator_address, creator_name, owner_address, multiple_owners, contract, opensea_id, opensea_token_id, token_collection_name, image_url, image_thumbnail_url, image_preview_url, image_original_url, animation_url, animation_original_url, acquisition_date, token_metadata_url FROM nfts WHERE id = $1 AND deleted = false
`

type GetNftByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetNftByIdBatch(ctx context.Context, id []persist.DBID) *GetNftByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getNftByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetNftByIdBatchBatchResults{br, 0}
}

func (b *GetNftByIdBatchBatchResults) QueryRow(f func(int, Nft, error)) {
	for {
		row := b.br.QueryRow()
		var i Nft
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.ExternalUrl,
			&i.CreatorAddress,
			&i.CreatorName,
			&i.OwnerAddress,
			&i.MultipleOwners,
			&i.Contract,
			&i.OpenseaID,
			&i.OpenseaTokenID,
			&i.TokenCollectionName,
			&i.ImageUrl,
			&i.ImageThumbnailUrl,
			&i.ImagePreviewUrl,
			&i.ImageOriginalUrl,
			&i.AnimationUrl,
			&i.AnimationOriginalUrl,
			&i.AcquisitionDate,
			&i.TokenMetadataUrl,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetNftByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getNftsByCollectionIdBatch = `-- name: GetNftsByCollectionIdBatch :batchmany
SELECT n.id, n.deleted, n.version, n.last_updated, n.created_at, n.name, n.description, n.collectors_note, n.external_url, n.creator_address, n.creator_name, n.owner_address, n.multiple_owners, n.contract, n.opensea_id, n.opensea_token_id, n.token_collection_name, n.image_url, n.image_thumbnail_url, n.image_preview_url, n.image_original_url, n.animation_url, n.animation_original_url, n.acquisition_date, n.token_metadata_url FROM collections c, unnest(c.nfts)
    WITH ORDINALITY AS x(nft_id, nft_ord)
    INNER JOIN nfts n ON n.id = x.nft_id
    WHERE c.id = $1 AND c.deleted = false AND n.deleted = false ORDER BY x.nft_ord
`

type GetNftsByCollectionIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetNftsByCollectionIdBatch(ctx context.Context, id []persist.DBID) *GetNftsByCollectionIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getNftsByCollectionIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetNftsByCollectionIdBatchBatchResults{br, 0}
}

func (b *GetNftsByCollectionIdBatchBatchResults) Query(f func(int, []Nft, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Nft
		for rows.Next() {
			var i Nft
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.ExternalUrl,
				&i.CreatorAddress,
				&i.CreatorName,
				&i.OwnerAddress,
				&i.MultipleOwners,
				&i.Contract,
				&i.OpenseaID,
				&i.OpenseaTokenID,
				&i.TokenCollectionName,
				&i.ImageUrl,
				&i.ImageThumbnailUrl,
				&i.ImagePreviewUrl,
				&i.ImageOriginalUrl,
				&i.AnimationUrl,
				&i.AnimationOriginalUrl,
				&i.AcquisitionDate,
				&i.TokenMetadataUrl,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetNftsByCollectionIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getNftsByOwnerAddressBatch = `-- name: GetNftsByOwnerAddressBatch :batchmany
SELECT id, deleted, version, last_updated, created_at, name, description, collectors_note, external_url, creator_address, creator_name, owner_address, multiple_owners, contract, opensea_id, opensea_token_id, token_collection_name, image_url, image_thumbnail_url, image_preview_url, image_original_url, animation_url, animation_original_url, acquisition_date, token_metadata_url FROM nfts WHERE owner_address = $1 AND deleted = false
`

type GetNftsByOwnerAddressBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetNftsByOwnerAddressBatch(ctx context.Context, ownerAddress []persist.DBID) *GetNftsByOwnerAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range ownerAddress {
		vals := []interface{}{
			a,
		}
		batch.Queue(getNftsByOwnerAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetNftsByOwnerAddressBatchBatchResults{br, 0}
}

func (b *GetNftsByOwnerAddressBatchBatchResults) Query(f func(int, []Nft, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Nft
		for rows.Next() {
			var i Nft
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.ExternalUrl,
				&i.CreatorAddress,
				&i.CreatorName,
				&i.OwnerAddress,
				&i.MultipleOwners,
				&i.Contract,
				&i.OpenseaID,
				&i.OpenseaTokenID,
				&i.TokenCollectionName,
				&i.ImageUrl,
				&i.ImageThumbnailUrl,
				&i.ImagePreviewUrl,
				&i.ImageOriginalUrl,
				&i.AnimationUrl,
				&i.AnimationOriginalUrl,
				&i.AcquisitionDate,
				&i.TokenMetadataUrl,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetNftsByOwnerAddressBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokenByIDBatch = `-- name: GetTokenByIDBatch :batchone
SELECT id, deleted, version, created_at, last_updated, name, description, contract_address, collectors_note, media, chain, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owner_addresses FROM tokens WHERE id = $1 AND deleted = false
`

type GetTokenByIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetTokenByIDBatch(ctx context.Context, id []persist.DBID) *GetTokenByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokenByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokenByIDBatchBatchResults{br, 0}
}

func (b *GetTokenByIDBatchBatchResults) QueryRow(f func(int, Token, error)) {
	for {
		row := b.br.QueryRow()
		var i Token
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.ContractAddress,
			&i.CollectorsNote,
			&i.Media,
			&i.Chain,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnerAddresses,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetTokenByIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokensByUserIDBatch = `-- name: GetTokensByUserIDBatch :batchmany
SELECT id, deleted, version, created_at, last_updated, name, description, contract_address, collectors_note, media, chain, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owner_addresses FROM tokens WHERE owner_user_id = $1 AND deleted = false
`

type GetTokensByUserIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetTokensByUserIDBatch(ctx context.Context, ownerUserID []persist.DBID) *GetTokensByUserIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range ownerUserID {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokensByUserIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokensByUserIDBatchBatchResults{br, 0}
}

func (b *GetTokensByUserIDBatchBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.ContractAddress,
				&i.CollectorsNote,
				&i.Media,
				&i.Chain,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnerAddresses,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetTokensByUserIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getUserByAddressBatch = `-- name: GetUserByAddressBatch :batchone
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, addresses, bio FROM users WHERE $1::varchar = ANY(addresses) AND deleted = false
`

type GetUserByAddressBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetUserByAddressBatch(ctx context.Context, dollar_1 []string) *GetUserByAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range dollar_1 {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUserByAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserByAddressBatchBatchResults{br, 0}
}

func (b *GetUserByAddressBatchBatchResults) QueryRow(f func(int, User, error)) {
	for {
		row := b.br.QueryRow()
		var i User
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Addresses,
			&i.Bio,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetUserByAddressBatchBatchResults) Close() error {
	return b.br.Close()
}

const getUserByIdBatch = `-- name: GetUserByIdBatch :batchone
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, addresses, bio FROM users WHERE id = $1 AND deleted = false
`

type GetUserByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetUserByIdBatch(ctx context.Context, id []persist.DBID) *GetUserByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUserByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserByIdBatchBatchResults{br, 0}
}

func (b *GetUserByIdBatchBatchResults) QueryRow(f func(int, User, error)) {
	for {
		row := b.br.QueryRow()
		var i User
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Addresses,
			&i.Bio,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetUserByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getUserByUsernameBatch = `-- name: GetUserByUsernameBatch :batchone
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, addresses, bio FROM users WHERE username_idempotent = lower($1) AND deleted = false
`

type GetUserByUsernameBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetUserByUsernameBatch(ctx context.Context, lower []string) *GetUserByUsernameBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range lower {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUserByUsernameBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserByUsernameBatchBatchResults{br, 0}
}

func (b *GetUserByUsernameBatchBatchResults) QueryRow(f func(int, User, error)) {
	for {
		row := b.br.QueryRow()
		var i User
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Addresses,
			&i.Bio,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetUserByUsernameBatchBatchResults) Close() error {
	return b.br.Close()
}

const getWalletByIDBatch = `-- name: GetWalletByIDBatch :batchone
SELECT wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type FROM wallets INNER JOIN addresses ON wallets.address = addresses.id WHERE wallets.id = $1 AND wallets.deleted = false AND addresses.deleted = false
`

type GetWalletByIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetWalletByIDBatch(ctx context.Context, id []persist.DBID) *GetWalletByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getWalletByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetWalletByIDBatchBatchResults{br, 0}
}

func (b *GetWalletByIDBatchBatchResults) QueryRow(f func(int, Wallet, error)) {
	for {
		row := b.br.QueryRow()
		var i Wallet
		err := row.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetWalletByIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getWalletsByUserIDBatch = `-- name: GetWalletsByUserIDBatch :batchmany
SELECT w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type FROM users u, unnest(u.addresses) INNER JOIN wallets w on w.address = addresses.id WHERE u.id = $1 AND u.deleted = false AND addresses.deleted = false AND w.deleted = false
`

type GetWalletsByUserIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetWalletsByUserIDBatch(ctx context.Context, id []persist.DBID) *GetWalletsByUserIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getWalletsByUserIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetWalletsByUserIDBatchBatchResults{br, 0}
}

func (b *GetWalletsByUserIDBatchBatchResults) Query(f func(int, []Wallet, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Wallet
		for rows.Next() {
			var i Wallet
			if err := rows.Scan(
				&i.ID,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Deleted,
				&i.Version,
				&i.Address,
				&i.WalletType,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetWalletsByUserIDBatchBatchResults) Close() error {
	return b.br.Close()
}
