// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package mirrordb

import (
	"context"
	"time"

	"github.com/jackc/pgtype"
	"github.com/mikeydub/go-gallery/service/persist"
)

const deleteEthereumOwnerEntry = `-- name: DeleteEthereumOwnerEntry :exec
delete from ethereum.owners where simplehash_kafka_key = $1
`

func (q *Queries) DeleteEthereumOwnerEntry(ctx context.Context, simplehashKafkaKey string) error {
	_, err := q.db.Exec(ctx, deleteEthereumOwnerEntry, simplehashKafkaKey)
	return err
}

const upsertEthereumOwnerEntry = `-- name: UpsertEthereumOwnerEntry :exec
insert into ethereum.owners (
    simplehash_kafka_key,
    simplehash_nft_id,
    last_updated,
    kafka_offset,
    kafka_partition,
    kafka_timestamp,
    contract_address,
    token_id,
    owner_address,
    quantity,
    collection_id,
    first_acquired_date,
    last_acquired_date,
    first_acquired_transaction,
    last_acquired_transaction,
    minted_to_this_wallet,
    airdropped_to_this_wallet,
    sold_to_this_wallet
    )
    values (
        $1,
        $2,
        now(),
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17
    )
    on conflict (simplehash_kafka_key) do update
        set simplehash_nft_id = excluded.simplehash_nft_id,
            contract_address = excluded.contract_address,
            token_id = excluded.token_id,
            owner_address = excluded.owner_address,
            quantity = excluded.quantity,
            collection_id = excluded.collection_id,
            first_acquired_date = excluded.first_acquired_date,
            last_acquired_date = excluded.last_acquired_date,
            first_acquired_transaction = excluded.first_acquired_transaction,
            last_acquired_transaction = excluded.last_acquired_transaction,
            minted_to_this_wallet = excluded.minted_to_this_wallet,
            airdropped_to_this_wallet = excluded.airdropped_to_this_wallet,
            sold_to_this_wallet = excluded.sold_to_this_wallet
`

type UpsertEthereumOwnerEntryParams struct {
	SimplehashKafkaKey       string           `db:"simplehash_kafka_key" json:"simplehash_kafka_key"`
	SimplehashNftID          *string          `db:"simplehash_nft_id" json:"simplehash_nft_id"`
	KafkaOffset              *int64           `db:"kafka_offset" json:"kafka_offset"`
	KafkaPartition           *int32           `db:"kafka_partition" json:"kafka_partition"`
	KafkaTimestamp           *time.Time       `db:"kafka_timestamp" json:"kafka_timestamp"`
	ContractAddress          *persist.Address `db:"contract_address" json:"contract_address"`
	TokenID                  pgtype.Numeric   `db:"token_id" json:"token_id"`
	OwnerAddress             *persist.Address `db:"owner_address" json:"owner_address"`
	Quantity                 pgtype.Numeric   `db:"quantity" json:"quantity"`
	CollectionID             *string          `db:"collection_id" json:"collection_id"`
	FirstAcquiredDate        *time.Time       `db:"first_acquired_date" json:"first_acquired_date"`
	LastAcquiredDate         *time.Time       `db:"last_acquired_date" json:"last_acquired_date"`
	FirstAcquiredTransaction *string          `db:"first_acquired_transaction" json:"first_acquired_transaction"`
	LastAcquiredTransaction  *string          `db:"last_acquired_transaction" json:"last_acquired_transaction"`
	MintedToThisWallet       *bool            `db:"minted_to_this_wallet" json:"minted_to_this_wallet"`
	AirdroppedToThisWallet   *bool            `db:"airdropped_to_this_wallet" json:"airdropped_to_this_wallet"`
	SoldToThisWallet         *bool            `db:"sold_to_this_wallet" json:"sold_to_this_wallet"`
}

func (q *Queries) UpsertEthereumOwnerEntry(ctx context.Context, arg UpsertEthereumOwnerEntryParams) error {
	_, err := q.db.Exec(ctx, upsertEthereumOwnerEntry,
		arg.SimplehashKafkaKey,
		arg.SimplehashNftID,
		arg.KafkaOffset,
		arg.KafkaPartition,
		arg.KafkaTimestamp,
		arg.ContractAddress,
		arg.TokenID,
		arg.OwnerAddress,
		arg.Quantity,
		arg.CollectionID,
		arg.FirstAcquiredDate,
		arg.LastAcquiredDate,
		arg.FirstAcquiredTransaction,
		arg.LastAcquiredTransaction,
		arg.MintedToThisWallet,
		arg.AirdroppedToThisWallet,
		arg.SoldToThisWallet,
	)
	return err
}
