// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: bemf.sql

package coredb

import (
	"context"
	"database/sql"
)

const getDisplayedContractsByUser = `-- name: GetDisplayedContractsByUser :many
select t.username_idempotent username, array_agg(t.address)::varchar[] as addresses
from (
	select users.username_idempotent, contracts.address
	from tokens
	join contracts on tokens.contract = contracts.id
	join users on tokens.owner_user_id = users.id
	where not tokens.deleted
	  and tokens.displayable
	  and not contracts.deleted
	  and not users.deleted
	  and not users.universal
	group by users.username_idempotent, contracts.address
) t
group by t.username_idempotent
`

type GetDisplayedContractsByUserRow struct {
	Username  sql.NullString `json:"username"`
	Addresses []string       `json:"addresses"`
}

func (q *Queries) GetDisplayedContractsByUser(ctx context.Context) ([]GetDisplayedContractsByUserRow, error) {
	rows, err := q.db.Query(ctx, getDisplayedContractsByUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDisplayedContractsByUserRow
	for rows.Next() {
		var i GetDisplayedContractsByUserRow
		if err := rows.Scan(&i.Username, &i.Addresses); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnedContractsByUser = `-- name: GetOwnedContractsByUser :many
select t.username_idempotent username, array_agg(t.address)::varchar[] as addresses
from (
	select users.username_idempotent, contracts.address
	from tokens
	join contracts on tokens.contract = contracts.id
	join users on tokens.owner_user_id = users.id
	where not tokens.deleted
	  and tokens.displayable
	  and not contracts.deleted
	  and not users.deleted
	  and not users.universal
	group by users.username_idempotent, contracts.address
) t
group by t.username_idempotent
`

type GetOwnedContractsByUserRow struct {
	Username  sql.NullString `json:"username"`
	Addresses []string       `json:"addresses"`
}

func (q *Queries) GetOwnedContractsByUser(ctx context.Context) ([]GetOwnedContractsByUserRow, error) {
	rows, err := q.db.Query(ctx, getOwnedContractsByUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOwnedContractsByUserRow
	for rows.Next() {
		var i GetOwnedContractsByUserRow
		if err := rows.Scan(&i.Username, &i.Addresses); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostedContractsByUser = `-- name: GetPostedContractsByUser :many
select t.username_idempotent username, array_agg(t.address)::varchar[] as addresses
from (
	select users.username_idempotent, contracts.address
	from posts
	join users on posts.actor_id = users.id
	join contracts on contracts.id = any(posts.contract_ids)
	where not users.deleted
		and not users.universal
		and not posts.deleted
	group by users.username_idempotent, contracts.address
) t
group by t.username_idempotent
`

type GetPostedContractsByUserRow struct {
	Username  sql.NullString `json:"username"`
	Addresses []string       `json:"addresses"`
}

func (q *Queries) GetPostedContractsByUser(ctx context.Context) ([]GetPostedContractsByUserRow, error) {
	rows, err := q.db.Query(ctx, getPostedContractsByUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostedContractsByUserRow
	for rows.Next() {
		var i GetPostedContractsByUserRow
		if err := rows.Scan(&i.Username, &i.Addresses); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewedContractsByUser = `-- name: GetViewedContractsByUser :many
select t.username_idempotent username, array_agg(t.address)::varchar[] as addresses
from (
	select users.username_idempotent, contracts.address
	from events
	join tokens on tokens.id = events.token_id
	join users on events.actor_id = users.id
	join contracts on tokens.contract = contracts.id
	where not events.deleted
		and action = 'ViewedToken'
		and not tokens.deleted
		and not users.deleted
		and not contracts.deleted
	group by users.username_idempotent, contracts.address
) t
group by t.username_idempotent
`

type GetViewedContractsByUserRow struct {
	Username  sql.NullString `json:"username"`
	Addresses []string       `json:"addresses"`
}

func (q *Queries) GetViewedContractsByUser(ctx context.Context) ([]GetViewedContractsByUserRow, error) {
	rows, err := q.db.Query(ctx, getViewedContractsByUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewedContractsByUserRow
	for rows.Next() {
		var i GetViewedContractsByUserRow
		if err := rows.Scan(&i.Username, &i.Addresses); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
