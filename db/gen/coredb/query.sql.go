// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package coredb

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
	"github.com/mikeydub/go-gallery/service/persist"
)

const addUserRoles = `-- name: AddUserRoles :exec
insert into user_roles (id, user_id, role, created_at, last_updated)
select unnest($2::varchar[]), $1, unnest($3::varchar[]), now(), now()
on conflict (user_id, role) do update set deleted = false, last_updated = now()
`

type AddUserRolesParams struct {
	UserID persist.DBID
	Ids    []string
	Roles  []string
}

func (q *Queries) AddUserRoles(ctx context.Context, arg AddUserRolesParams) error {
	_, err := q.db.Exec(ctx, addUserRoles, arg.UserID, arg.Ids, arg.Roles)
	return err
}

const blockUserFromFeed = `-- name: BlockUserFromFeed :exec
INSERT INTO feed_blocklist (id, user_id, action) VALUES ($1, $2, $3)
`

type BlockUserFromFeedParams struct {
	ID     persist.DBID
	UserID persist.DBID
	Action persist.Action
}

func (q *Queries) BlockUserFromFeed(ctx context.Context, arg BlockUserFromFeedParams) error {
	_, err := q.db.Exec(ctx, blockUserFromFeed, arg.ID, arg.UserID, arg.Action)
	return err
}

const clearNotificationsForUser = `-- name: ClearNotificationsForUser :many
UPDATE notifications SET seen = true WHERE owner_id = $1 AND seen = false RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount
`

func (q *Queries) ClearNotificationsForUser(ctx context.Context, ownerID persist.DBID) ([]Notification, error) {
	rows, err := q.db.Query(ctx, clearNotificationsForUser, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countOwnersByContractId = `-- name: CountOwnersByContractId :one
SELECT count(DISTINCT users.id) FROM users, tokens
    WHERE tokens.contract = $1 AND tokens.owner_user_id = users.id
    AND (NOT $2::bool OR users.universal = false)
    AND tokens.deleted = false AND users.deleted = false
`

type CountOwnersByContractIdParams struct {
	Contract         persist.DBID
	GalleryUsersOnly bool
}

func (q *Queries) CountOwnersByContractId(ctx context.Context, arg CountOwnersByContractIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOwnersByContractId, arg.Contract, arg.GalleryUsersOnly)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTokensByContractId = `-- name: CountTokensByContractId :one
SELECT count(*) FROM tokens JOIN users ON users.id = tokens.owner_user_id WHERE contract = $1 AND (NOT $2::bool OR users.universal = false) AND tokens.deleted = false
`

type CountTokensByContractIdParams struct {
	Contract         persist.DBID
	GalleryUsersOnly bool
}

func (q *Queries) CountTokensByContractId(ctx context.Context, arg CountTokensByContractIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTokensByContractId, arg.Contract, arg.GalleryUsersOnly)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserNotifications = `-- name: CountUserNotifications :one
SELECT count(*) FROM notifications WHERE owner_id = $1 AND deleted = false
`

func (q *Queries) CountUserNotifications(ctx context.Context, ownerID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserNotifications, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserUnseenNotifications = `-- name: CountUserUnseenNotifications :one
SELECT count(*) FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false
`

func (q *Queries) CountUserUnseenNotifications(ctx context.Context, ownerID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserUnseenNotifications, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAdmireEvent = `-- name: CreateAdmireEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, admire_id, feed_event_id, subject_id, data) VALUES ($1, $2, $3, $4, $5, $6, $5, $7) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption
`

type CreateAdmireEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	AdmireID       persist.DBID
	FeedEventID    persist.DBID
	Data           persist.EventData
}

func (q *Queries) CreateAdmireEvent(ctx context.Context, arg CreateAdmireEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createAdmireEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.AdmireID,
		arg.FeedEventID,
		arg.Data,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
	)
	return i, err
}

const createAdmireNotification = `-- name: CreateAdmireNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, feed_event_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount
`

type CreateAdmireNotificationParams struct {
	ID          persist.DBID
	OwnerID     persist.DBID
	Action      persist.Action
	Data        persist.NotificationData
	EventIds    persist.DBIDList
	FeedEventID persist.DBID
}

func (q *Queries) CreateAdmireNotification(ctx context.Context, arg CreateAdmireNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createAdmireNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.FeedEventID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const createCollection = `-- name: CreateCollection :one
insert into collections (id, version, name, collectors_note, owner_user_id, gallery_id, layout, nfts, hidden, token_settings, created_at, last_updated) values ($1, 0, $2, $3, $4, $5, $6, $7, $8, $9, now(), now()) returning id
`

type CreateCollectionParams struct {
	ID             persist.DBID
	Name           sql.NullString
	CollectorsNote sql.NullString
	OwnerUserID    persist.DBID
	GalleryID      persist.DBID
	Layout         persist.TokenLayout
	Nfts           persist.DBIDList
	Hidden         bool
	TokenSettings  map[persist.DBID]persist.CollectionTokenSettings
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.ID,
		arg.Name,
		arg.CollectorsNote,
		arg.OwnerUserID,
		arg.GalleryID,
		arg.Layout,
		arg.Nfts,
		arg.Hidden,
		arg.TokenSettings,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const createCollectionEvent = `-- name: CreateCollectionEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, collection_id, subject_id, data, caption) VALUES ($1, $2, $3, $4, $5, $5, $6, $7) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption
`

type CreateCollectionEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	CollectionID   persist.DBID
	Data           persist.EventData
	Caption        sql.NullString
}

func (q *Queries) CreateCollectionEvent(ctx context.Context, arg CreateCollectionEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createCollectionEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.CollectionID,
		arg.Data,
		arg.Caption,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
	)
	return i, err
}

const createCommentEvent = `-- name: CreateCommentEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, comment_id, feed_event_id, subject_id, data) VALUES ($1, $2, $3, $4, $5, $6, $5, $7) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption
`

type CreateCommentEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	CommentID      persist.DBID
	FeedEventID    persist.DBID
	Data           persist.EventData
}

func (q *Queries) CreateCommentEvent(ctx context.Context, arg CreateCommentEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createCommentEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.CommentID,
		arg.FeedEventID,
		arg.Data,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
	)
	return i, err
}

const createCommentNotification = `-- name: CreateCommentNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, feed_event_id, comment_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount
`

type CreateCommentNotificationParams struct {
	ID          persist.DBID
	OwnerID     persist.DBID
	Action      persist.Action
	Data        persist.NotificationData
	EventIds    persist.DBIDList
	FeedEventID persist.DBID
	CommentID   persist.DBID
}

func (q *Queries) CreateCommentNotification(ctx context.Context, arg CreateCommentNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createCommentNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.FeedEventID,
		arg.CommentID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const createFeedEvent = `-- name: CreateFeedEvent :one
INSERT INTO feed_events (id, owner_id, action, data, event_time, event_ids, caption) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption
`

type CreateFeedEventParams struct {
	ID        persist.DBID
	OwnerID   persist.DBID
	Action    persist.Action
	Data      persist.FeedEventData
	EventTime time.Time
	EventIds  persist.DBIDList
	Caption   sql.NullString
}

func (q *Queries) CreateFeedEvent(ctx context.Context, arg CreateFeedEventParams) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, createFeedEvent,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventTime,
		arg.EventIds,
		arg.Caption,
	)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
	)
	return i, err
}

const createFollowNotification = `-- name: CreateFollowNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids) VALUES ($1, $2, $3, $4, $5) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount
`

type CreateFollowNotificationParams struct {
	ID       persist.DBID
	OwnerID  persist.DBID
	Action   persist.Action
	Data     persist.NotificationData
	EventIds persist.DBIDList
}

func (q *Queries) CreateFollowNotification(ctx context.Context, arg CreateFollowNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createFollowNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const createGalleryEvent = `-- name: CreateGalleryEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, gallery_id, subject_id, data, external_id) VALUES ($1, $2, $3, $4, $5, $5, $6, $7) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption
`

type CreateGalleryEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	GalleryID      persist.DBID
	Data           persist.EventData
	ExternalID     sql.NullString
}

func (q *Queries) CreateGalleryEvent(ctx context.Context, arg CreateGalleryEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createGalleryEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.GalleryID,
		arg.Data,
		arg.ExternalID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
	)
	return i, err
}

const createTokenEvent = `-- name: CreateTokenEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, token_id, subject_id, data) VALUES ($1, $2, $3, $4, $5, $5, $6) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption
`

type CreateTokenEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	TokenID        persist.DBID
	Data           persist.EventData
}

func (q *Queries) CreateTokenEvent(ctx context.Context, arg CreateTokenEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createTokenEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.TokenID,
		arg.Data,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
	)
	return i, err
}

const createUserEvent = `-- name: CreateUserEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, user_id, subject_id, data) VALUES ($1, $2, $3, $4, $5, $5, $6) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption
`

type CreateUserEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	UserID         persist.DBID
	Data           persist.EventData
}

func (q *Queries) CreateUserEvent(ctx context.Context, arg CreateUserEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createUserEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.UserID,
		arg.Data,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
	)
	return i, err
}

const createViewGalleryNotification = `-- name: CreateViewGalleryNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, gallery_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount
`

type CreateViewGalleryNotificationParams struct {
	ID        persist.DBID
	OwnerID   persist.DBID
	Action    persist.Action
	Data      persist.NotificationData
	EventIds  persist.DBIDList
	GalleryID persist.DBID
}

func (q *Queries) CreateViewGalleryNotification(ctx context.Context, arg CreateViewGalleryNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createViewGalleryNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.GalleryID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const deleteCollections = `-- name: DeleteCollections :exec
update collections set deleted = true, last_updated = now() where id = any($1::varchar[])
`

func (q *Queries) DeleteCollections(ctx context.Context, ids []string) error {
	_, err := q.db.Exec(ctx, deleteCollections, ids)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
update user_roles set deleted = true, last_updated = now() where user_id = $1 and role = any($2)
`

type DeleteUserRolesParams struct {
	UserID persist.DBID
	Roles  persist.RoleList
}

func (q *Queries) DeleteUserRoles(ctx context.Context, arg DeleteUserRolesParams) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, arg.UserID, arg.Roles)
	return err
}

const getAdmireByAdmireID = `-- name: GetAdmireByAdmireID :one
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated FROM admires WHERE id = $1 AND deleted = false
`

func (q *Queries) GetAdmireByAdmireID(ctx context.Context, id persist.DBID) (Admire, error) {
	row := q.db.QueryRow(ctx, getAdmireByAdmireID, id)
	var i Admire
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.FeedEventID,
		&i.ActorID,
		&i.Deleted,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}

const getAdmiresByActorID = `-- name: GetAdmiresByActorID :many
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated FROM admires WHERE actor_id = $1 AND deleted = false ORDER BY created_at DESC
`

func (q *Queries) GetAdmiresByActorID(ctx context.Context, actorID persist.DBID) ([]Admire, error) {
	rows, err := q.db.Query(ctx, getAdmiresByActorID, actorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Admire
	for rows.Next() {
		var i Admire
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdmiresByAdmireIDs = `-- name: GetAdmiresByAdmireIDs :many
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated from admires WHERE id = ANY($1) AND deleted = false
`

func (q *Queries) GetAdmiresByAdmireIDs(ctx context.Context, admireIds persist.DBIDList) ([]Admire, error) {
	rows, err := q.db.Query(ctx, getAdmiresByAdmireIDs, admireIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Admire
	for rows.Next() {
		var i Admire
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionById = `-- name: GetCollectionById :one
SELECT id, deleted, owner_user_id, nfts, version, last_updated, created_at, hidden, collectors_note, name, layout, token_settings, gallery_id FROM collections WHERE id = $1 AND deleted = false
`

func (q *Queries) GetCollectionById(ctx context.Context, id persist.DBID) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionById, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerUserID,
		&i.Nfts,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Hidden,
		&i.CollectorsNote,
		&i.Name,
		&i.Layout,
		&i.TokenSettings,
		&i.GalleryID,
	)
	return i, err
}

const getCollectionsByGalleryId = `-- name: GetCollectionsByGalleryId :many
SELECT c.id, c.deleted, c.owner_user_id, c.nfts, c.version, c.last_updated, c.created_at, c.hidden, c.collectors_note, c.name, c.layout, c.token_settings, c.gallery_id FROM galleries g, unnest(g.collections)
    WITH ORDINALITY AS x(coll_id, coll_ord)
    INNER JOIN collections c ON c.id = x.coll_id
    WHERE g.id = $1 AND g.deleted = false AND c.deleted = false ORDER BY x.coll_ord
`

func (q *Queries) GetCollectionsByGalleryId(ctx context.Context, id persist.DBID) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getCollectionsByGalleryId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerUserID,
			&i.Nfts,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Hidden,
			&i.CollectorsNote,
			&i.Name,
			&i.Layout,
			&i.TokenSettings,
			&i.GalleryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentByCommentID = `-- name: GetCommentByCommentID :one
SELECT id, version, feed_event_id, actor_id, reply_to, comment, deleted, created_at, last_updated FROM comments WHERE id = $1 AND deleted = false
`

func (q *Queries) GetCommentByCommentID(ctx context.Context, id persist.DBID) (Comment, error) {
	row := q.db.QueryRow(ctx, getCommentByCommentID, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.FeedEventID,
		&i.ActorID,
		&i.ReplyTo,
		&i.Comment,
		&i.Deleted,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}

const getCommentsByActorID = `-- name: GetCommentsByActorID :many
SELECT id, version, feed_event_id, actor_id, reply_to, comment, deleted, created_at, last_updated FROM comments WHERE actor_id = $1 AND deleted = false ORDER BY created_at DESC
`

func (q *Queries) GetCommentsByActorID(ctx context.Context, actorID persist.DBID) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getCommentsByActorID, actorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.ReplyTo,
			&i.Comment,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsByCommentIDs = `-- name: GetCommentsByCommentIDs :many
SELECT id, version, feed_event_id, actor_id, reply_to, comment, deleted, created_at, last_updated from comments WHERE id = ANY($1) AND deleted = false
`

func (q *Queries) GetCommentsByCommentIDs(ctx context.Context, commentIds persist.DBIDList) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getCommentsByCommentIDs, commentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.ReplyTo,
			&i.Comment,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContractByChainAddress = `-- name: GetContractByChainAddress :one
select id, deleted, version, created_at, last_updated, name, symbol, address, creator_address, chain, profile_banner_url, profile_image_url, badge_url, description FROM contracts WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetContractByChainAddressParams struct {
	Address persist.Address
	Chain   persist.Chain
}

func (q *Queries) GetContractByChainAddress(ctx context.Context, arg GetContractByChainAddressParams) (Contract, error) {
	row := q.db.QueryRow(ctx, getContractByChainAddress, arg.Address, arg.Chain)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Name,
		&i.Symbol,
		&i.Address,
		&i.CreatorAddress,
		&i.Chain,
		&i.ProfileBannerUrl,
		&i.ProfileImageUrl,
		&i.BadgeUrl,
		&i.Description,
	)
	return i, err
}

const getContractByID = `-- name: GetContractByID :one
select id, deleted, version, created_at, last_updated, name, symbol, address, creator_address, chain, profile_banner_url, profile_image_url, badge_url, description FROM contracts WHERE id = $1 AND deleted = false
`

func (q *Queries) GetContractByID(ctx context.Context, id persist.DBID) (Contract, error) {
	row := q.db.QueryRow(ctx, getContractByID, id)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Name,
		&i.Symbol,
		&i.Address,
		&i.CreatorAddress,
		&i.Chain,
		&i.ProfileBannerUrl,
		&i.ProfileImageUrl,
		&i.BadgeUrl,
		&i.Description,
	)
	return i, err
}

const getContractsByIDs = `-- name: GetContractsByIDs :many
SELECT id, deleted, version, created_at, last_updated, name, symbol, address, creator_address, chain, profile_banner_url, profile_image_url, badge_url, description from contracts WHERE id = ANY($1) AND deleted = false
`

func (q *Queries) GetContractsByIDs(ctx context.Context, contractIds persist.DBIDList) ([]Contract, error) {
	rows, err := q.db.Query(ctx, getContractsByIDs, contractIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Address,
			&i.CreatorAddress,
			&i.Chain,
			&i.ProfileBannerUrl,
			&i.ProfileImageUrl,
			&i.BadgeUrl,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContractsByUserID = `-- name: GetContractsByUserID :many
SELECT DISTINCT ON (contracts.id) contracts.id, contracts.deleted, contracts.version, contracts.created_at, contracts.last_updated, contracts.name, contracts.symbol, contracts.address, contracts.creator_address, contracts.chain, contracts.profile_banner_url, contracts.profile_image_url, contracts.badge_url, contracts.description FROM contracts, tokens
    WHERE tokens.owner_user_id = $1 AND tokens.contract = contracts.id
    AND tokens.deleted = false AND contracts.deleted = false
`

func (q *Queries) GetContractsByUserID(ctx context.Context, ownerUserID persist.DBID) ([]Contract, error) {
	rows, err := q.db.Query(ctx, getContractsByUserID, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Address,
			&i.CreatorAddress,
			&i.Chain,
			&i.ProfileBannerUrl,
			&i.ProfileImageUrl,
			&i.BadgeUrl,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvent = `-- name: GetEvent :one
SELECT id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption FROM events WHERE id = $1 AND deleted = false
`

func (q *Queries) GetEvent(ctx context.Context, id persist.DBID) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
	)
	return i, err
}

const getEventsInWindow = `-- name: GetEventsInWindow :many
with recursive activity as (
    select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption from events where events.id = $1 and deleted = false
    union
    select e.id, e.version, e.actor_id, e.resource_type_id, e.subject_id, e.user_id, e.token_id, e.collection_id, e.action, e.data, e.deleted, e.last_updated, e.created_at, e.gallery_id, e.comment_id, e.admire_id, e.feed_event_id, e.external_id, e.caption from events e, activity a
    where e.actor_id = a.actor_id
        and e.action = any($3)
        and e.created_at < a.created_at
        and e.created_at >= a.created_at - make_interval(secs => $2)
        and e.deleted = false
        and e.caption is null
        and (not $4::bool or e.subject_id = a.subject_id)
)
select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption from events where id = any(select id from activity) order by (created_at, id) asc
`

type GetEventsInWindowParams struct {
	ID             persist.DBID
	Secs           float64
	Actions        persist.ActionList
	IncludeSubject bool
}

func (q *Queries) GetEventsInWindow(ctx context.Context, arg GetEventsInWindowParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsInWindow,
		arg.ID,
		arg.Secs,
		arg.Actions,
		arg.IncludeSubject,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.TokenID,
			&i.CollectionID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.GalleryID,
			&i.CommentID,
			&i.AdmireID,
			&i.FeedEventID,
			&i.ExternalID,
			&i.Caption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeedEventByID = `-- name: GetFeedEventByID :one
SELECT id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption FROM feed_events WHERE id = $1 AND deleted = false
`

func (q *Queries) GetFeedEventByID(ctx context.Context, id persist.DBID) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, getFeedEventByID, id)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
	)
	return i, err
}

const getGalleriesByUserId = `-- name: GetGalleriesByUserId :many
SELECT id, deleted, last_updated, created_at, version, owner_user_id, collections, name, description, hidden, position FROM galleries WHERE owner_user_id = $1 AND deleted = false order by position
`

func (q *Queries) GetGalleriesByUserId(ctx context.Context, ownerUserID persist.DBID) ([]Gallery, error) {
	rows, err := q.db.Query(ctx, getGalleriesByUserId, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gallery
	for rows.Next() {
		var i Gallery
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Version,
			&i.OwnerUserID,
			&i.Collections,
			&i.Name,
			&i.Description,
			&i.Hidden,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGalleryByCollectionId = `-- name: GetGalleryByCollectionId :one
SELECT g.id, g.deleted, g.last_updated, g.created_at, g.version, g.owner_user_id, g.collections, g.name, g.description, g.hidden, g.position FROM galleries g, collections c WHERE c.id = $1 AND c.deleted = false AND $1 = ANY(g.collections) AND g.deleted = false
`

func (q *Queries) GetGalleryByCollectionId(ctx context.Context, id persist.DBID) (Gallery, error) {
	row := q.db.QueryRow(ctx, getGalleryByCollectionId, id)
	var i Gallery
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Version,
		&i.OwnerUserID,
		&i.Collections,
		&i.Name,
		&i.Description,
		&i.Hidden,
		&i.Position,
	)
	return i, err
}

const getGalleryById = `-- name: GetGalleryById :one
SELECT id, deleted, last_updated, created_at, version, owner_user_id, collections, name, description, hidden, position FROM galleries WHERE id = $1 AND deleted = false
`

func (q *Queries) GetGalleryById(ctx context.Context, id persist.DBID) (Gallery, error) {
	row := q.db.QueryRow(ctx, getGalleryById, id)
	var i Gallery
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Version,
		&i.OwnerUserID,
		&i.Collections,
		&i.Name,
		&i.Description,
		&i.Hidden,
		&i.Position,
	)
	return i, err
}

const getGalleryTokenPreviewsByID = `-- name: GetGalleryTokenPreviewsByID :many
select (t.media->>'thumbnail_url')::varchar as previews from tokens t, collections c, galleries g where g.id = $1 and c.id = any(g.collections) and t.id = any(c.nfts) and t.deleted = false and g.deleted = false and c.deleted = false and length(t.media->>'thumbnail_url'::varchar) > 0 order by array_position(g.collections, c.id),array_position(c.nfts, t.id) limit 3
`

func (q *Queries) GetGalleryTokenPreviewsByID(ctx context.Context, id persist.DBID) ([]string, error) {
	rows, err := q.db.Query(ctx, getGalleryTokenPreviewsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var previews string
		if err := rows.Scan(&previews); err != nil {
			return nil, err
		}
		items = append(items, previews)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastFeedEventForCollection = `-- name: GetLastFeedEventForCollection :one
select id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption from feed_events where deleted = false
    and owner_id = $1
    and action = any($3)
    and data ->> 'collection_id' = $4
    and event_time < $2
    order by event_time desc
    limit 1
`

type GetLastFeedEventForCollectionParams struct {
	OwnerID      persist.DBID
	EventTime    time.Time
	Actions      persist.ActionList
	CollectionID persist.DBID
}

func (q *Queries) GetLastFeedEventForCollection(ctx context.Context, arg GetLastFeedEventForCollectionParams) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, getLastFeedEventForCollection,
		arg.OwnerID,
		arg.EventTime,
		arg.Actions,
		arg.CollectionID,
	)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
	)
	return i, err
}

const getLastFeedEventForToken = `-- name: GetLastFeedEventForToken :one
select id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption from feed_events where deleted = false
    and owner_id = $1
    and action = any($3)
    and data ->> 'token_id' = $4::varchar
    and event_time < $2
    order by event_time desc
    limit 1
`

type GetLastFeedEventForTokenParams struct {
	OwnerID   persist.DBID
	EventTime time.Time
	Actions   persist.ActionList
	TokenID   string
}

func (q *Queries) GetLastFeedEventForToken(ctx context.Context, arg GetLastFeedEventForTokenParams) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, getLastFeedEventForToken,
		arg.OwnerID,
		arg.EventTime,
		arg.Actions,
		arg.TokenID,
	)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
	)
	return i, err
}

const getLastFeedEventForUser = `-- name: GetLastFeedEventForUser :one
select id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption from feed_events where deleted = false
    and owner_id = $1
    and action = any($3)
    and event_time < $2
    order by event_time desc
    limit 1
`

type GetLastFeedEventForUserParams struct {
	OwnerID   persist.DBID
	EventTime time.Time
	Actions   persist.ActionList
}

func (q *Queries) GetLastFeedEventForUser(ctx context.Context, arg GetLastFeedEventForUserParams) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, getLastFeedEventForUser, arg.OwnerID, arg.EventTime, arg.Actions)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
	)
	return i, err
}

const getMembershipByMembershipId = `-- name: GetMembershipByMembershipId :one
SELECT id, deleted, version, created_at, last_updated, token_id, name, asset_url, owners FROM membership WHERE id = $1 AND deleted = false
`

func (q *Queries) GetMembershipByMembershipId(ctx context.Context, id persist.DBID) (Membership, error) {
	row := q.db.QueryRow(ctx, getMembershipByMembershipId, id)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.TokenID,
		&i.Name,
		&i.AssetUrl,
		&i.Owners,
	)
	return i, err
}

const getMerchDiscountCodeByTokenID = `-- name: GetMerchDiscountCodeByTokenID :one
select discount_code from merch where token_id = $1 and redeemed = true and deleted = false
`

func (q *Queries) GetMerchDiscountCodeByTokenID(ctx context.Context, tokenHex persist.TokenID) (sql.NullString, error) {
	row := q.db.QueryRow(ctx, getMerchDiscountCodeByTokenID, tokenHex)
	var discount_code sql.NullString
	err := row.Scan(&discount_code)
	return discount_code, err
}

const getMostRecentNotificationByOwnerIDForAction = `-- name: GetMostRecentNotificationByOwnerIDForAction :one
select id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount from notifications
    where owner_id = $1
    and action = $2
    and deleted = false
    and (not $4::bool or feed_event_id = $3)
    order by created_at desc
    limit 1
`

type GetMostRecentNotificationByOwnerIDForActionParams struct {
	OwnerID          persist.DBID
	Action           persist.Action
	FeedEventID      persist.DBID
	OnlyForFeedEvent bool
}

func (q *Queries) GetMostRecentNotificationByOwnerIDForAction(ctx context.Context, arg GetMostRecentNotificationByOwnerIDForActionParams) (Notification, error) {
	row := q.db.QueryRow(ctx, getMostRecentNotificationByOwnerIDForAction,
		arg.OwnerID,
		arg.Action,
		arg.FeedEventID,
		arg.OnlyForFeedEvent,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount FROM notifications WHERE id = $1 AND deleted = false
`

func (q *Queries) GetNotificationByID(ctx context.Context, id persist.DBID) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const getNotificationsByOwnerIDForActionAfter = `-- name: GetNotificationsByOwnerIDForActionAfter :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount FROM notifications
    WHERE owner_id = $1 AND action = $2 AND deleted = false AND created_at > $3
    ORDER BY created_at DESC
`

type GetNotificationsByOwnerIDForActionAfterParams struct {
	OwnerID      persist.DBID
	Action       persist.Action
	CreatedAfter time.Time
}

func (q *Queries) GetNotificationsByOwnerIDForActionAfter(ctx context.Context, arg GetNotificationsByOwnerIDForActionAfterParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByOwnerIDForActionAfter, arg.OwnerID, arg.Action, arg.CreatedAfter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreviewURLsByContractIdAndUserId = `-- name: GetPreviewURLsByContractIdAndUserId :many
SELECT (MEDIA->>'thumbnail_url')::varchar as thumbnail_url FROM tokens WHERE CONTRACT = $1 AND DELETED = false AND OWNER_USER_ID = $2 AND LENGTH(MEDIA->>'thumbnail_url'::varchar) > 0 ORDER BY ID LIMIT 3
`

type GetPreviewURLsByContractIdAndUserIdParams struct {
	Contract    persist.DBID
	OwnerUserID persist.DBID
}

func (q *Queries) GetPreviewURLsByContractIdAndUserId(ctx context.Context, arg GetPreviewURLsByContractIdAndUserIdParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getPreviewURLsByContractIdAndUserId, arg.Contract, arg.OwnerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var thumbnail_url string
		if err := rows.Scan(&thumbnail_url); err != nil {
			return nil, err
		}
		items = append(items, thumbnail_url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentUnseenNotifications = `-- name: GetRecentUnseenNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false and created_at > $2 order by created_at desc limit $3
`

type GetRecentUnseenNotificationsParams struct {
	OwnerID      persist.DBID
	CreatedAfter time.Time
	Lim          int32
}

func (q *Queries) GetRecentUnseenNotifications(ctx context.Context, arg GetRecentUnseenNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getRecentUnseenNotifications, arg.OwnerID, arg.CreatedAfter, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenById = `-- name: GetTokenById :one
SELECT id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam, last_synced FROM tokens WHERE id = $1 AND deleted = false
`

func (q *Queries) GetTokenById(ctx context.Context, id persist.DBID) (Token, error) {
	row := q.db.QueryRow(ctx, getTokenById, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Name,
		&i.Description,
		&i.CollectorsNote,
		&i.Media,
		&i.TokenUri,
		&i.TokenType,
		&i.TokenID,
		&i.Quantity,
		&i.OwnershipHistory,
		&i.TokenMetadata,
		&i.ExternalUrl,
		&i.BlockNumber,
		&i.OwnerUserID,
		&i.OwnedByWallets,
		&i.Chain,
		&i.Contract,
		&i.IsUserMarkedSpam,
		&i.IsProviderMarkedSpam,
		&i.LastSynced,
	)
	return i, err
}

const getTokenByTokenIdentifiers = `-- name: GetTokenByTokenIdentifiers :one
select id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam, last_synced from tokens where tokens.token_id = $1 and contract = (select contracts.id from contracts where contracts.address = $2) and tokens.chain = $3 and tokens.deleted = false
`

type GetTokenByTokenIdentifiersParams struct {
	TokenHex        persist.TokenID
	ContractAddress persist.Address
	Chain           persist.Chain
}

func (q *Queries) GetTokenByTokenIdentifiers(ctx context.Context, arg GetTokenByTokenIdentifiersParams) (Token, error) {
	row := q.db.QueryRow(ctx, getTokenByTokenIdentifiers, arg.TokenHex, arg.ContractAddress, arg.Chain)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Name,
		&i.Description,
		&i.CollectorsNote,
		&i.Media,
		&i.TokenUri,
		&i.TokenType,
		&i.TokenID,
		&i.Quantity,
		&i.OwnershipHistory,
		&i.TokenMetadata,
		&i.ExternalUrl,
		&i.BlockNumber,
		&i.OwnerUserID,
		&i.OwnedByWallets,
		&i.Chain,
		&i.Contract,
		&i.IsUserMarkedSpam,
		&i.IsProviderMarkedSpam,
		&i.LastSynced,
	)
	return i, err
}

const getTokenOwnerByID = `-- name: GetTokenOwnerByID :one
SELECT u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_verified, u.email_unsubscriptions, u.featured_gallery FROM tokens t
    JOIN users u ON u.id = t.owner_user_id
    WHERE t.id = $1 AND t.deleted = false AND u.deleted = false
`

func (q *Queries) GetTokenOwnerByID(ctx context.Context, id persist.DBID) (User, error) {
	row := q.db.QueryRow(ctx, getTokenOwnerByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailVerified,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
	)
	return i, err
}

const getTokensByCollectionId = `-- name: GetTokensByCollectionId :many
SELECT t.id, t.deleted, t.version, t.created_at, t.last_updated, t.name, t.description, t.collectors_note, t.media, t.token_uri, t.token_type, t.token_id, t.quantity, t.ownership_history, t.token_metadata, t.external_url, t.block_number, t.owner_user_id, t.owned_by_wallets, t.chain, t.contract, t.is_user_marked_spam, t.is_provider_marked_spam, t.last_synced FROM users u, collections c, unnest(c.nfts)
    WITH ORDINALITY AS x(nft_id, nft_ord)
    INNER JOIN tokens t ON t.id = x.nft_id
    WHERE u.id = t.owner_user_id AND t.owned_by_wallets && u.wallets
    AND c.id = $1 AND u.deleted = false AND c.deleted = false AND t.deleted = false ORDER BY x.nft_ord LIMIT $2
`

type GetTokensByCollectionIdParams struct {
	CollectionID persist.DBID
	Limit        sql.NullInt32
}

func (q *Queries) GetTokensByCollectionId(ctx context.Context, arg GetTokensByCollectionIdParams) ([]Token, error) {
	rows, err := q.db.Query(ctx, getTokensByCollectionId, arg.CollectionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensByContractId = `-- name: GetTokensByContractId :many
SELECT id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam, last_synced FROM tokens WHERE contract = $1 AND deleted = false
    ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

func (q *Queries) GetTokensByContractId(ctx context.Context, contract persist.DBID) ([]Token, error) {
	rows, err := q.db.Query(ctx, getTokensByContractId, contract)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensByContractIdPaginate = `-- name: GetTokensByContractIdPaginate :many
SELECT t.id, t.deleted, t.version, t.created_at, t.last_updated, t.name, t.description, t.collectors_note, t.media, t.token_uri, t.token_type, t.token_id, t.quantity, t.ownership_history, t.token_metadata, t.external_url, t.block_number, t.owner_user_id, t.owned_by_wallets, t.chain, t.contract, t.is_user_marked_spam, t.is_provider_marked_spam, t.last_synced FROM tokens t
    JOIN users u ON u.id = t.owner_user_id
    WHERE t.contract = $1 AND t.deleted = false
    AND (NOT $3::bool OR u.universal = false)
    AND (u.universal,t.created_at,t.id) < ($4, $5::timestamptz, $6)
    AND (u.universal,t.created_at,t.id) > ($7, $8::timestamptz, $9)
    ORDER BY CASE WHEN $10::bool THEN (u.universal,t.created_at,t.id) END ASC,
             CASE WHEN NOT $10::bool THEN (u.universal,t.created_at,t.id) END DESC
    LIMIT $2
`

type GetTokensByContractIdPaginateParams struct {
	Contract           persist.DBID
	Limit              int32
	GalleryUsersOnly   bool
	CurBeforeUniversal bool
	CurBeforeTime      time.Time
	CurBeforeID        persist.DBID
	CurAfterUniversal  bool
	CurAfterTime       time.Time
	CurAfterID         persist.DBID
	PagingForward      bool
}

func (q *Queries) GetTokensByContractIdPaginate(ctx context.Context, arg GetTokensByContractIdPaginateParams) ([]Token, error) {
	rows, err := q.db.Query(ctx, getTokensByContractIdPaginate,
		arg.Contract,
		arg.Limit,
		arg.GalleryUsersOnly,
		arg.CurBeforeUniversal,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterUniversal,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensByUserId = `-- name: GetTokensByUserId :many
SELECT tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.name, tokens.description, tokens.collectors_note, tokens.media, tokens.token_uri, tokens.token_type, tokens.token_id, tokens.quantity, tokens.ownership_history, tokens.token_metadata, tokens.external_url, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.chain, tokens.contract, tokens.is_user_marked_spam, tokens.is_provider_marked_spam, tokens.last_synced FROM tokens, users
    WHERE tokens.owner_user_id = $1 AND users.id = $1
      AND tokens.owned_by_wallets && users.wallets
      AND tokens.deleted = false AND users.deleted = false
    ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

func (q *Queries) GetTokensByUserId(ctx context.Context, ownerUserID persist.DBID) ([]Token, error) {
	rows, err := q.db.Query(ctx, getTokensByUserId, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensByUserIdAndContractID = `-- name: GetTokensByUserIdAndContractID :many
SELECT tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.name, tokens.description, tokens.collectors_note, tokens.media, tokens.token_uri, tokens.token_type, tokens.token_id, tokens.quantity, tokens.ownership_history, tokens.token_metadata, tokens.external_url, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.chain, tokens.contract, tokens.is_user_marked_spam, tokens.is_provider_marked_spam, tokens.last_synced FROM tokens, users
    WHERE tokens.owner_user_id = $1 AND users.id = $1
      AND tokens.owned_by_wallets && users.wallets
      AND tokens.contract = $2
      AND tokens.deleted = false AND users.deleted = false
    ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

type GetTokensByUserIdAndContractIDParams struct {
	OwnerUserID persist.DBID
	Contract    persist.DBID
}

func (q *Queries) GetTokensByUserIdAndContractID(ctx context.Context, arg GetTokensByUserIdAndContractIDParams) ([]Token, error) {
	rows, err := q.db.Query(ctx, getTokensByUserIdAndContractID, arg.OwnerUserID, arg.Contract)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensByWalletIds = `-- name: GetTokensByWalletIds :many
SELECT id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam, last_synced FROM tokens WHERE owned_by_wallets && $1 AND deleted = false
    ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

func (q *Queries) GetTokensByWalletIds(ctx context.Context, ownedByWallets persist.DBIDList) ([]Token, error) {
	rows, err := q.db.Query(ctx, getTokensByWalletIds, ownedByWallets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_gallery FROM users WHERE id = $1 AND deleted = false
`

func (q *Queries) GetUserById(ctx context.Context, id persist.DBID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailVerified,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_gallery FROM users WHERE username_idempotent = lower($1) AND deleted = false
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailVerified,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
	)
	return i, err
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type GetUserNotificationsParams struct {
	OwnerID       persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserNotifications,
		arg.OwnerID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOwnsTokenByIdentifiers = `-- name: GetUserOwnsTokenByIdentifiers :one
select exists(select 1 from tokens where owner_user_id = $1 and token_id = $2 and contract = $3 and chain = $4 and deleted = false) as owns_token
`

type GetUserOwnsTokenByIdentifiersParams struct {
	UserID   persist.DBID
	TokenHex persist.TokenID
	Contract persist.DBID
	Chain    persist.Chain
}

func (q *Queries) GetUserOwnsTokenByIdentifiers(ctx context.Context, arg GetUserOwnsTokenByIdentifiersParams) (bool, error) {
	row := q.db.QueryRow(ctx, getUserOwnsTokenByIdentifiers,
		arg.UserID,
		arg.TokenHex,
		arg.Contract,
		arg.Chain,
	)
	var owns_token bool
	err := row.Scan(&owns_token)
	return owns_token, err
}

const getUserRolesByUserId = `-- name: GetUserRolesByUserId :many
select role from user_roles where user_id = $1 and deleted = false
union
select role from (
  select
    case when exists(select 1 from tokens where owner_user_id = $1 and token_id = any($2::varchar[]) and contract = (select id from contracts where address = $3 and contracts.chain = $4 and contracts.deleted = false) and deleted = false)
      then $5 else null end as role
) r where role is not null
`

type GetUserRolesByUserIdParams struct {
	UserID                persist.DBID
	MembershipTokenIds    []string
	MembershipAddress     persist.Address
	Chain                 persist.Chain
	GrantedMembershipRole string
}

func (q *Queries) GetUserRolesByUserId(ctx context.Context, arg GetUserRolesByUserIdParams) ([]persist.Role, error) {
	rows, err := q.db.Query(ctx, getUserRolesByUserId,
		arg.UserID,
		arg.MembershipTokenIds,
		arg.MembershipAddress,
		arg.Chain,
		arg.GrantedMembershipRole,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.Role
	for rows.Next() {
		var role persist.Role
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserUnseenNotifications = `-- name: GetUserUnseenNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type GetUserUnseenNotificationsParams struct {
	OwnerID       persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUserUnseenNotifications(ctx context.Context, arg GetUserUnseenNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserUnseenNotifications,
		arg.OwnerID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithPIIByID = `-- name: GetUserWithPIIByID :one
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, pii_email_address from users_with_pii where id = $1 and deleted = false
`

func (q *Queries) GetUserWithPIIByID(ctx context.Context, userID persist.DBID) (UsersWithPii, error) {
	row := q.db.QueryRow(ctx, getUserWithPIIByID, userID)
	var i UsersWithPii
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailVerified,
		&i.EmailUnsubscriptions,
		&i.PiiEmailAddress,
	)
	return i, err
}

const getUsersByChainAddresses = `-- name: GetUsersByChainAddresses :many
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_verified, users.email_unsubscriptions, users.featured_gallery,wallets.address from users, wallets where wallets.address = ANY($1::varchar[]) AND wallets.chain = $2::int AND ARRAY[wallets.id] <@ users.wallets AND users.deleted = false AND wallets.deleted = false
`

type GetUsersByChainAddressesParams struct {
	Addresses []string
	Chain     int32
}

type GetUsersByChainAddressesRow struct {
	ID                   persist.DBID
	Deleted              bool
	Version              sql.NullInt32
	LastUpdated          time.Time
	CreatedAt            time.Time
	Username             sql.NullString
	UsernameIdempotent   sql.NullString
	Wallets              persist.WalletList
	Bio                  sql.NullString
	Traits               pgtype.JSONB
	Universal            bool
	NotificationSettings persist.UserNotificationSettings
	EmailVerified        persist.EmailVerificationStatus
	EmailUnsubscriptions persist.EmailUnsubscriptions
	FeaturedGallery      *persist.DBID
	Address              persist.Address
}

func (q *Queries) GetUsersByChainAddresses(ctx context.Context, arg GetUsersByChainAddressesParams) ([]GetUsersByChainAddressesRow, error) {
	rows, err := q.db.Query(ctx, getUsersByChainAddresses, arg.Addresses, arg.Chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByChainAddressesRow
	for rows.Next() {
		var i GetUsersByChainAddressesRow
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_gallery FROM users WHERE id = ANY($2) AND deleted = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $1
`

type GetUsersByIDsParams struct {
	Limit         int32
	UserIds       persist.DBIDList
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUsersByIDs(ctx context.Context, arg GetUsersByIDsParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs,
		arg.Limit,
		arg.UserIds,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithEmailNotificationsOn = `-- name: GetUsersWithEmailNotificationsOn :many
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, pii_email_address from users_with_pii
    where (email_unsubscriptions->>'all' = 'false' or email_unsubscriptions->>'all' is null)
    and deleted = false and pii_email_address is not null and email_verified = $1
    and (created_at, id) < ($3, $4)
    and (created_at, id) > ($5, $6)
    order by case when $7::bool then (created_at, id) end asc,
             case when not $7::bool then (created_at, id) end desc
    limit $2
`

type GetUsersWithEmailNotificationsOnParams struct {
	EmailVerified persist.EmailVerificationStatus
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

// TODO: Does not appear to be used
func (q *Queries) GetUsersWithEmailNotificationsOn(ctx context.Context, arg GetUsersWithEmailNotificationsOnParams) ([]UsersWithPii, error) {
	rows, err := q.db.Query(ctx, getUsersWithEmailNotificationsOn,
		arg.EmailVerified,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersWithPii
	for rows.Next() {
		var i UsersWithPii
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.PiiEmailAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithEmailNotificationsOnForEmailType = `-- name: GetUsersWithEmailNotificationsOnForEmailType :many
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, pii_email_address from users_with_pii
    where (email_unsubscriptions->>'all' = 'false' or email_unsubscriptions->>'all' is null)
    and (email_unsubscriptions->>$3::varchar = 'false' or email_unsubscriptions->>$3::varchar is null)
    and deleted = false and pii_email_address is not null and email_verified = $1
    and (created_at, id) < ($4, $5)
    and (created_at, id) > ($6, $7)
    order by case when $8::bool then (created_at, id) end asc,
             case when not $8::bool then (created_at, id) end desc
    limit $2
`

type GetUsersWithEmailNotificationsOnForEmailTypeParams struct {
	EmailVerified       persist.EmailVerificationStatus
	Limit               int32
	EmailUnsubscription string
	CurBeforeTime       time.Time
	CurBeforeID         persist.DBID
	CurAfterTime        time.Time
	CurAfterID          persist.DBID
	PagingForward       bool
}

// for some reason this query will not allow me to use @tags for $1
func (q *Queries) GetUsersWithEmailNotificationsOnForEmailType(ctx context.Context, arg GetUsersWithEmailNotificationsOnForEmailTypeParams) ([]UsersWithPii, error) {
	rows, err := q.db.Query(ctx, getUsersWithEmailNotificationsOnForEmailType,
		arg.EmailVerified,
		arg.Limit,
		arg.EmailUnsubscription,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersWithPii
	for rows.Next() {
		var i UsersWithPii
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.PiiEmailAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRolePaginate = `-- name: GetUsersWithRolePaginate :many
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_verified, u.email_unsubscriptions, u.featured_gallery from users u, user_roles ur where u.deleted = false and ur.deleted = false
    and u.id = ur.user_id and ur.role = $2
    and (u.username_idempotent, u.id) < ($3::varchar, $4)
    and (u.username_idempotent, u.id) > ($5::varchar, $6)
    order by case when $7::bool then (u.username_idempotent, u.id) end asc,
             case when not $7::bool then (u.username_idempotent, u.id) end desc
    limit $1
`

type GetUsersWithRolePaginateParams struct {
	Limit         int32
	Role          persist.Role
	CurBeforeKey  string
	CurBeforeID   persist.DBID
	CurAfterKey   string
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUsersWithRolePaginate(ctx context.Context, arg GetUsersWithRolePaginateParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithRolePaginate,
		arg.Limit,
		arg.Role,
		arg.CurBeforeKey,
		arg.CurBeforeID,
		arg.CurAfterKey,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithTrait = `-- name: GetUsersWithTrait :many
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_gallery FROM users WHERE (traits->$1::string) IS NOT NULL AND deleted = false
`

func (q *Queries) GetUsersWithTrait(ctx context.Context, dollar_1 string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithTrait, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByChainAddress = `-- name: GetWalletByChainAddress :one
SELECT wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type, wallets.chain FROM wallets WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetWalletByChainAddressParams struct {
	Address persist.Address
	Chain   persist.Chain
}

func (q *Queries) GetWalletByChainAddress(ctx context.Context, arg GetWalletByChainAddressParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByChainAddress, arg.Address, arg.Chain)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Version,
		&i.Address,
		&i.WalletType,
		&i.Chain,
	)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, created_at, last_updated, deleted, version, address, wallet_type, chain FROM wallets WHERE id = $1 AND deleted = false
`

func (q *Queries) GetWalletByID(ctx context.Context, id persist.DBID) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Version,
		&i.Address,
		&i.WalletType,
		&i.Chain,
	)
	return i, err
}

const getWalletsByUserID = `-- name: GetWalletsByUserID :many
SELECT w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type, w.chain FROM users u, unnest(u.wallets) WITH ORDINALITY AS a(wallet_id, wallet_ord)INNER JOIN wallets w on w.id = a.wallet_id WHERE u.id = $1 AND u.deleted = false AND w.deleted = false ORDER BY a.wallet_ord
`

func (q *Queries) GetWalletsByUserID(ctx context.Context, id persist.DBID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getWalletsByUserID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isActorActionActive = `-- name: IsActorActionActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and action = any($2)
  and created_at > $3 and created_at <= $4
)
`

type IsActorActionActiveParams struct {
	ActorID     sql.NullString
	Actions     persist.ActionList
	WindowStart time.Time
	WindowEnd   time.Time
}

func (q *Queries) IsActorActionActive(ctx context.Context, arg IsActorActionActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorActionActive,
		arg.ActorID,
		arg.Actions,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSubjectActionActive = `-- name: IsActorSubjectActionActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and subject_id = $2
  and action = any($3)
  and created_at > $4 and created_at <= $5
)
`

type IsActorSubjectActionActiveParams struct {
	ActorID     sql.NullString
	SubjectID   persist.DBID
	Actions     persist.ActionList
	WindowStart time.Time
	WindowEnd   time.Time
}

func (q *Queries) IsActorSubjectActionActive(ctx context.Context, arg IsActorSubjectActionActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSubjectActionActive,
		arg.ActorID,
		arg.SubjectID,
		arg.Actions,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSubjectActive = `-- name: IsActorSubjectActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and subject_id = $2
  and created_at > $3 and created_at <= $4
)
`

type IsActorSubjectActiveParams struct {
	ActorID     sql.NullString
	SubjectID   persist.DBID
	WindowStart time.Time
	WindowEnd   time.Time
}

func (q *Queries) IsActorSubjectActive(ctx context.Context, arg IsActorSubjectActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSubjectActive,
		arg.ActorID,
		arg.SubjectID,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isFeedUserActionBlocked = `-- name: IsFeedUserActionBlocked :one
SELECT EXISTS(SELECT 1 FROM feed_blocklist WHERE user_id = $1 AND action = $2 AND deleted = false)
`

type IsFeedUserActionBlockedParams struct {
	UserID persist.DBID
	Action persist.Action
}

func (q *Queries) IsFeedUserActionBlocked(ctx context.Context, arg IsFeedUserActionBlockedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFeedUserActionBlocked, arg.UserID, arg.Action)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const redeemMerch = `-- name: RedeemMerch :one
update merch set redeemed = true, token_id = $1, last_updated = now() where id = (select m.id from merch m where m.object_type = $2 and m.token_id is null and m.redeemed = false and m.deleted = false order by m.id limit 1) and token_id is null and redeemed = false returning discount_code
`

type RedeemMerchParams struct {
	TokenHex   persist.TokenID
	ObjectType int32
}

func (q *Queries) RedeemMerch(ctx context.Context, arg RedeemMerchParams) (sql.NullString, error) {
	row := q.db.QueryRow(ctx, redeemMerch, arg.TokenHex, arg.ObjectType)
	var discount_code sql.NullString
	err := row.Scan(&discount_code)
	return discount_code, err
}

const updateCollectionTokens = `-- name: UpdateCollectionTokens :exec
update collections set nfts = $1, last_updated = now() where id = $2 and deleted = false
`

type UpdateCollectionTokensParams struct {
	Nfts persist.DBIDList
	ID   persist.DBID
}

func (q *Queries) UpdateCollectionTokens(ctx context.Context, arg UpdateCollectionTokensParams) error {
	_, err := q.db.Exec(ctx, updateCollectionTokens, arg.Nfts, arg.ID)
	return err
}

const updateCollectionsInfo = `-- name: UpdateCollectionsInfo :exec
with updates as (
    select unnest($1::varchar[]) as id, unnest($2::varchar[]) as name, unnest($3::varchar[]) as collectors_note, unnest($4::jsonb[]) as layout, unnest($5::jsonb[]) as token_settings, unnest($6::bool[]) as hidden
)
update collections c set collectors_note = updates.collectors_note, layout = updates.layout, token_settings = updates.token_settings, hidden = updates.hidden, name = updates.name, last_updated = now() from updates where c.id = updates.id and c.deleted = false
`

type UpdateCollectionsInfoParams struct {
	Ids             []string
	Names           []string
	CollectorsNotes []string
	Layouts         []pgtype.JSONB
	TokenSettings   []pgtype.JSONB
	Hidden          []bool
}

func (q *Queries) UpdateCollectionsInfo(ctx context.Context, arg UpdateCollectionsInfoParams) error {
	_, err := q.db.Exec(ctx, updateCollectionsInfo,
		arg.Ids,
		arg.Names,
		arg.CollectorsNotes,
		arg.Layouts,
		arg.TokenSettings,
		arg.Hidden,
	)
	return err
}

const updateGallery = `-- name: UpdateGallery :exec
update galleries set name = case when $1::bool then $2 else name end, description = case when $3::bool then $4 else description end, collections = case when $5::bool then $6 else collections end, last_updated = now() where galleries.id = $7 and galleries.deleted = false and (select count(*) from collections c where c.id = any($6) and c.gallery_id = $7 and c.deleted = false) = cardinality($6)
`

type UpdateGalleryParams struct {
	NameUpdated        bool
	Name               string
	DescriptionUpdated bool
	Description        string
	CollectionsUpdated bool
	Collections        persist.DBIDList
	GalleryID          persist.DBID
}

func (q *Queries) UpdateGallery(ctx context.Context, arg UpdateGalleryParams) error {
	_, err := q.db.Exec(ctx, updateGallery,
		arg.NameUpdated,
		arg.Name,
		arg.DescriptionUpdated,
		arg.Description,
		arg.CollectionsUpdated,
		arg.Collections,
		arg.GalleryID,
	)
	return err
}

const updateGalleryHidden = `-- name: UpdateGalleryHidden :one
update galleries set hidden = $1, last_updated = now() where id = $2 and deleted = false returning id, deleted, last_updated, created_at, version, owner_user_id, collections, name, description, hidden, position
`

type UpdateGalleryHiddenParams struct {
	Hidden bool
	ID     persist.DBID
}

func (q *Queries) UpdateGalleryHidden(ctx context.Context, arg UpdateGalleryHiddenParams) (Gallery, error) {
	row := q.db.QueryRow(ctx, updateGalleryHidden, arg.Hidden, arg.ID)
	var i Gallery
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Version,
		&i.OwnerUserID,
		&i.Collections,
		&i.Name,
		&i.Description,
		&i.Hidden,
		&i.Position,
	)
	return i, err
}

const updateGalleryInfo = `-- name: UpdateGalleryInfo :exec
update galleries set name = $1, description = $2, last_updated = now() where id = $3 and deleted = false
`

type UpdateGalleryInfoParams struct {
	Name        string
	Description string
	ID          persist.DBID
}

func (q *Queries) UpdateGalleryInfo(ctx context.Context, arg UpdateGalleryInfoParams) error {
	_, err := q.db.Exec(ctx, updateGalleryInfo, arg.Name, arg.Description, arg.ID)
	return err
}

const updateGalleryPositions = `-- name: UpdateGalleryPositions :exec
with updates as (
    select unnest($1::text[]) as id, unnest($2::text[]) as position
)
update galleries g set position = updates.position, last_updated = now() from updates where g.id = updates.id and deleted = false
`

type UpdateGalleryPositionsParams struct {
	GalleryIds []string
	Positions  []string
}

func (q *Queries) UpdateGalleryPositions(ctx context.Context, arg UpdateGalleryPositionsParams) error {
	_, err := q.db.Exec(ctx, updateGalleryPositions, arg.GalleryIds, arg.Positions)
	return err
}

const updateNotification = `-- name: UpdateNotification :exec
UPDATE notifications SET data = $2, event_ids = event_ids || $3, amount = $4, last_updated = now(), seen = false WHERE id = $1 AND deleted = false AND NOT amount = $4
`

type UpdateNotificationParams struct {
	ID       persist.DBID
	Data     persist.NotificationData
	EventIds persist.DBIDList
	Amount   int32
}

func (q *Queries) UpdateNotification(ctx context.Context, arg UpdateNotificationParams) error {
	_, err := q.db.Exec(ctx, updateNotification,
		arg.ID,
		arg.Data,
		arg.EventIds,
		arg.Amount,
	)
	return err
}

const updateNotificationSettingsByID = `-- name: UpdateNotificationSettingsByID :exec
UPDATE users SET notification_settings = $2 WHERE id = $1
`

type UpdateNotificationSettingsByIDParams struct {
	ID                   persist.DBID
	NotificationSettings persist.UserNotificationSettings
}

func (q *Queries) UpdateNotificationSettingsByID(ctx context.Context, arg UpdateNotificationSettingsByIDParams) error {
	_, err := q.db.Exec(ctx, updateNotificationSettingsByID, arg.ID, arg.NotificationSettings)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
with upsert_pii as (
    insert into pii_for_users (user_id, pii_email_address) values ($1, $2)
        on conflict (user_id) do update set pii_email_address = excluded.pii_email_address
),

upsert_metadata as (
    insert into dev_metadata_users (user_id, has_email_address) values ($1, ($2 is not null))
        on conflict (user_id) do update set has_email_address = excluded.has_email_address
)

update users set email_verified = 0 where users.id = $1
`

type UpdateUserEmailParams struct {
	UserID       persist.DBID
	EmailAddress persist.Email
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserEmail, arg.UserID, arg.EmailAddress)
	return err
}

const updateUserEmailUnsubscriptions = `-- name: UpdateUserEmailUnsubscriptions :exec
UPDATE users SET email_unsubscriptions = $2 WHERE id = $1
`

type UpdateUserEmailUnsubscriptionsParams struct {
	ID                   persist.DBID
	EmailUnsubscriptions persist.EmailUnsubscriptions
}

func (q *Queries) UpdateUserEmailUnsubscriptions(ctx context.Context, arg UpdateUserEmailUnsubscriptionsParams) error {
	_, err := q.db.Exec(ctx, updateUserEmailUnsubscriptions, arg.ID, arg.EmailUnsubscriptions)
	return err
}

const updateUserFeaturedGallery = `-- name: UpdateUserFeaturedGallery :exec
update users set featured_gallery = $1, last_updated = now() from galleries where users.id = $2 and galleries.id = $1 and galleries.owner_user_id = $2 and galleries.deleted = false
`

type UpdateUserFeaturedGalleryParams struct {
	GalleryID persist.DBID
	UserID    persist.DBID
}

func (q *Queries) UpdateUserFeaturedGallery(ctx context.Context, arg UpdateUserFeaturedGalleryParams) error {
	_, err := q.db.Exec(ctx, updateUserFeaturedGallery, arg.GalleryID, arg.UserID)
	return err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :exec
UPDATE users SET email_verified = $2 WHERE id = $1
`

type UpdateUserVerificationStatusParams struct {
	ID            persist.DBID
	EmailVerified persist.EmailVerificationStatus
}

func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserVerificationStatus, arg.ID, arg.EmailVerified)
	return err
}
