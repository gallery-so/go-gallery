// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package coredb

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
	"github.com/mikeydub/go-gallery/service/multichain/highlight"
	"github.com/mikeydub/go-gallery/service/persist"
)

const addCollectionToGallery = `-- name: AddCollectionToGallery :exec
update galleries set collections = array_append(collections, $1), last_updated = now() where id = $2 and deleted = false
`

type AddCollectionToGalleryParams struct {
	CollectionID interface{}  `db:"collection_id" json:"collection_id"`
	GalleryID    persist.DBID `db:"gallery_id" json:"gallery_id"`
}

func (q *Queries) AddCollectionToGallery(ctx context.Context, arg AddCollectionToGalleryParams) error {
	_, err := q.db.Exec(ctx, addCollectionToGallery, arg.CollectionID, arg.GalleryID)
	return err
}

const addManyFollows = `-- name: AddManyFollows :many
insert into follows (id, follower, followee, deleted) select unnest($1::varchar[]), $2, unnest($3::varchar[]), false on conflict (follower, followee) where deleted = false do update set deleted = false, last_updated = now() returning last_updated > created_at
`

type AddManyFollowsParams struct {
	Ids       []string     `db:"ids" json:"ids"`
	Follower  persist.DBID `db:"follower" json:"follower"`
	Followees []string     `db:"followees" json:"followees"`
}

func (q *Queries) AddManyFollows(ctx context.Context, arg AddManyFollowsParams) ([]bool, error) {
	rows, err := q.db.Query(ctx, addManyFollows, arg.Ids, arg.Follower, arg.Followees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []bool
	for rows.Next() {
		var column_1 bool
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addPiiAccountCreationInfo = `-- name: AddPiiAccountCreationInfo :exec
insert into pii.account_creation_info (user_id, ip_address, created_at) values ($1, $2, now())
  on conflict do nothing
`

type AddPiiAccountCreationInfoParams struct {
	UserID    persist.DBID `db:"user_id" json:"user_id"`
	IpAddress string       `db:"ip_address" json:"ip_address"`
}

func (q *Queries) AddPiiAccountCreationInfo(ctx context.Context, arg AddPiiAccountCreationInfoParams) error {
	_, err := q.db.Exec(ctx, addPiiAccountCreationInfo, arg.UserID, arg.IpAddress)
	return err
}

const addSocialToUser = `-- name: AddSocialToUser :exec
insert into pii.for_users (user_id, pii_socials) values ($1, $2) on conflict (user_id) where deleted = false do update set pii_socials = for_users.pii_socials || $2
`

type AddSocialToUserParams struct {
	UserID  persist.DBID    `db:"user_id" json:"user_id"`
	Socials persist.Socials `db:"socials" json:"socials"`
}

func (q *Queries) AddSocialToUser(ctx context.Context, arg AddSocialToUserParams) error {
	_, err := q.db.Exec(ctx, addSocialToUser, arg.UserID, arg.Socials)
	return err
}

const addUserRoles = `-- name: AddUserRoles :exec
insert into user_roles (id, user_id, role, created_at, last_updated)
select unnest($2::varchar[]), $1, unnest($3::varchar[]), now(), now()
on conflict (user_id, role) do update set deleted = false, last_updated = now()
`

type AddUserRolesParams struct {
	UserID persist.DBID `db:"user_id" json:"user_id"`
	Ids    []string     `db:"ids" json:"ids"`
	Roles  []string     `db:"roles" json:"roles"`
}

func (q *Queries) AddUserRoles(ctx context.Context, arg AddUserRolesParams) error {
	_, err := q.db.Exec(ctx, addUserRoles, arg.UserID, arg.Ids, arg.Roles)
	return err
}

const blockUser = `-- name: BlockUser :one
with user_to_block as (select id from users where users.id = $3 and not deleted and not universal)
insert into user_blocklist (id, user_id, blocked_user_id, active) (select $1, $2, user_to_block.id, true from user_to_block)
on conflict(user_id, blocked_user_id) where not deleted do update set active = true, last_updated = now() returning id
`

type BlockUserParams struct {
	ID            persist.DBID `db:"id" json:"id"`
	UserID        persist.DBID `db:"user_id" json:"user_id"`
	BlockedUserID persist.DBID `db:"blocked_user_id" json:"blocked_user_id"`
}

func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, blockUser, arg.ID, arg.UserID, arg.BlockedUserID)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const blockUserFromFeed = `-- name: BlockUserFromFeed :exec
insert into feed_blocklist (id, user_id, reason, active) values ($1, $2, $3, true)
on conflict(user_id) where not deleted do update set reason = coalesce(excluded.reason, feed_blocklist.reason), active = true, last_updated = now()
`

type BlockUserFromFeedParams struct {
	ID     persist.DBID         `db:"id" json:"id"`
	UserID persist.DBID         `db:"user_id" json:"user_id"`
	Reason persist.ReportReason `db:"reason" json:"reason"`
}

func (q *Queries) BlockUserFromFeed(ctx context.Context, arg BlockUserFromFeedParams) error {
	_, err := q.db.Exec(ctx, blockUserFromFeed, arg.ID, arg.UserID, arg.Reason)
	return err
}

const checkUserOwnsAllTokenDbids = `-- name: CheckUserOwnsAllTokenDbids :one
with user_tokens as (select count(*) total from tokens where id = any($2) and owner_user_id = $1 and not tokens.deleted), total_tokens as (select cardinality($2) total)
select (select total from total_tokens) = (select total from user_tokens) owns_all
`

type CheckUserOwnsAllTokenDbidsParams struct {
	OwnerUserID persist.DBID     `db:"owner_user_id" json:"owner_user_id"`
	TokenIds    persist.DBIDList `db:"token_ids" json:"token_ids"`
}

func (q *Queries) CheckUserOwnsAllTokenDbids(ctx context.Context, arg CheckUserOwnsAllTokenDbidsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserOwnsAllTokenDbids, arg.OwnerUserID, arg.TokenIds)
	var owns_all bool
	err := row.Scan(&owns_all)
	return owns_all, err
}

const clearNotificationsForUser = `-- name: ClearNotificationsForUser :many
UPDATE notifications SET seen = true WHERE owner_id = $1 AND seen = false RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

func (q *Queries) ClearNotificationsForUser(ctx context.Context, ownerID persist.DBID) ([]Notification, error) {
	rows, err := q.db.Query(ctx, clearNotificationsForUser, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
			&i.PostID,
			&i.TokenID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countAllUsers = `-- name: CountAllUsers :one
SELECT count(*) FROM users WHERE deleted = false and universal = false
`

func (q *Queries) CountAllUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCommentsAndRepliesByFeedEventID = `-- name: CountCommentsAndRepliesByFeedEventID :one
SELECT count(*) FROM comments WHERE feed_event_id = $1 AND deleted = false
`

func (q *Queries) CountCommentsAndRepliesByFeedEventID(ctx context.Context, feedEventID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countCommentsAndRepliesByFeedEventID, feedEventID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCommentsAndRepliesByPostID = `-- name: CountCommentsAndRepliesByPostID :one
SELECT count(*) FROM comments WHERE post_id = $1 AND deleted = false
`

func (q *Queries) CountCommentsAndRepliesByPostID(ctx context.Context, postID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countCommentsAndRepliesByPostID, postID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFollowersByUserID = `-- name: CountFollowersByUserID :one
SELECT count(*) FROM follows WHERE followee = $1 AND deleted = false
`

func (q *Queries) CountFollowersByUserID(ctx context.Context, followee persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countFollowersByUserID, followee)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOwnersByContractId = `-- name: CountOwnersByContractId :one
select count(distinct users.id) from users, tokens, contracts
    where (contracts.id = $1 or contracts.parent_id = $1)
    and tokens.contract_id = contracts.id
    and tokens.owner_user_id = users.id
    and tokens.displayable
    and (not $2::bool or users.universal = false)
    and tokens.deleted = false and users.deleted = false and contracts.deleted = false
`

type CountOwnersByContractIdParams struct {
	ID               persist.DBID `db:"id" json:"id"`
	GalleryUsersOnly bool         `db:"gallery_users_only" json:"gallery_users_only"`
}

func (q *Queries) CountOwnersByContractId(ctx context.Context, arg CountOwnersByContractIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOwnersByContractId, arg.ID, arg.GalleryUsersOnly)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPostsByContractID = `-- name: CountPostsByContractID :one
select count(*)
from posts
where $1 = any(posts.contract_ids)
and posts.deleted = false
`

func (q *Queries) CountPostsByContractID(ctx context.Context, contractID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countPostsByContractID, contractID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPostsByUserID = `-- name: CountPostsByUserID :one
select count(*) from posts where actor_id = $1 and not posts.deleted
`

func (q *Queries) CountPostsByUserID(ctx context.Context, actorID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countPostsByUserID, actorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSharedCommunities = `-- name: CountSharedCommunities :one
select count(*)
from owned_communities a, owned_communities b, communities
left join contracts on communities.contract_id = contracts.id
left join marketplace_contracts on communities.contract_id = marketplace_contracts.contract_id
where a.user_id = $1
  and b.user_id = $2
  and a.community_id = b.community_id
  and a.community_id = communities.id
  and marketplace_contracts.contract_id is null
  and communities.name != ''
  and communities.name != 'Unidentified contract'
  and (contracts.is_provider_marked_spam is null or contracts.is_provider_marked_spam = false)
`

type CountSharedCommunitiesParams struct {
	UserAID persist.DBID `db:"user_a_id" json:"user_a_id"`
	UserBID persist.DBID `db:"user_b_id" json:"user_b_id"`
}

func (q *Queries) CountSharedCommunities(ctx context.Context, arg CountSharedCommunitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSharedCommunities, arg.UserAID, arg.UserBID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSharedFollows = `-- name: CountSharedFollows :one
select count(*)
from users, follows a, follows b
where a.follower = $1
	and a.followee = b.follower
	and b.followee = $2
	and users.id = b.follower
	and a.deleted = false
	and b.deleted = false
	and users.deleted = false
`

type CountSharedFollowsParams struct {
	Follower persist.DBID `db:"follower" json:"follower"`
	Followee persist.DBID `db:"followee" json:"followee"`
}

func (q *Queries) CountSharedFollows(ctx context.Context, arg CountSharedFollowsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSharedFollows, arg.Follower, arg.Followee)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSocialConnections = `-- name: CountSocialConnections :one
select count(*)
from (select unnest($1::varchar[]) as social_id) as s
    inner join pii.user_view on user_view.pii_socials->$2::text->>'id'::varchar = s.social_id and user_view.deleted = false
    left outer join follows f on f.follower = $3 and f.followee = user_view.id and f.deleted = false
where case when $4::bool then f.id is null else true end
`

type CountSocialConnectionsParams struct {
	SocialIds       []string     `db:"social_ids" json:"social_ids"`
	Social          string       `db:"social" json:"social"`
	UserID          persist.DBID `db:"user_id" json:"user_id"`
	OnlyUnfollowing bool         `db:"only_unfollowing" json:"only_unfollowing"`
}

func (q *Queries) CountSocialConnections(ctx context.Context, arg CountSocialConnectionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSocialConnections,
		arg.SocialIds,
		arg.Social,
		arg.UserID,
		arg.OnlyUnfollowing,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTokensAdmiredByUserID = `-- name: CountTokensAdmiredByUserID :one
select count(*) from admires, tokens where actor_id = $1 and admires.token_id = tokens.id and not admires.deleted and not tokens.deleted
`

func (q *Queries) CountTokensAdmiredByUserID(ctx context.Context, actorID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countTokensAdmiredByUserID, actorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTokensByContractId = `-- name: CountTokensByContractId :one
select count(*)
from tokens
join users on users.id = tokens.owner_user_id
join contracts on tokens.contract_id = contracts.id
where (contracts.id = $1 or contracts.parent_id = $1)
  and (not $2::bool or users.universal = false) and tokens.deleted = false and contracts.deleted = false
  and tokens.displayable
`

type CountTokensByContractIdParams struct {
	ID               persist.DBID `db:"id" json:"id"`
	GalleryUsersOnly bool         `db:"gallery_users_only" json:"gallery_users_only"`
}

func (q *Queries) CountTokensByContractId(ctx context.Context, arg CountTokensByContractIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTokensByContractId, arg.ID, arg.GalleryUsersOnly)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserNotifications = `-- name: CountUserNotifications :one
SELECT count(*) FROM notifications WHERE owner_id = $1 AND deleted = false
`

func (q *Queries) CountUserNotifications(ctx context.Context, ownerID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserNotifications, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserUnseenNotifications = `-- name: CountUserUnseenNotifications :one
SELECT count(*) FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false
`

func (q *Queries) CountUserUnseenNotifications(ctx context.Context, ownerID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserUnseenNotifications, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAdmireEvent = `-- name: CreateAdmireEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, admire_id, feed_event_id, post_id, token_id, comment_id, subject_id, data, group_id, caption) VALUES ($1, $2, $3, $4, $5, $10, $11, $12, $13, $6, $7, $8, $9) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreateAdmireEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	AdmireID       persist.DBID         `db:"admire_id" json:"admire_id"`
	SubjectID      persist.DBID         `db:"subject_id" json:"subject_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
	FeedEvent      sql.NullString       `db:"feed_event" json:"feed_event"`
	Post           sql.NullString       `db:"post" json:"post"`
	Token          sql.NullString       `db:"token" json:"token"`
	Comment        sql.NullString       `db:"comment" json:"comment"`
}

func (q *Queries) CreateAdmireEvent(ctx context.Context, arg CreateAdmireEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createAdmireEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.AdmireID,
		arg.SubjectID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
		arg.FeedEvent,
		arg.Post,
		arg.Token,
		arg.Comment,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createAdmireNotification = `-- name: CreateAdmireNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, feed_event_id, post_id, token_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateAdmireNotificationParams struct {
	ID        persist.DBID             `db:"id" json:"id"`
	OwnerID   persist.DBID             `db:"owner_id" json:"owner_id"`
	Action    persist.Action           `db:"action" json:"action"`
	Data      persist.NotificationData `db:"data" json:"data"`
	EventIds  persist.DBIDList         `db:"event_ids" json:"event_ids"`
	FeedEvent sql.NullString           `db:"feed_event" json:"feed_event"`
	Post      sql.NullString           `db:"post" json:"post"`
	Token     sql.NullString           `db:"token" json:"token"`
}

func (q *Queries) CreateAdmireNotification(ctx context.Context, arg CreateAdmireNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createAdmireNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.FeedEvent,
		arg.Post,
		arg.Token,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createAnnouncementNotifications = `-- name: CreateAnnouncementNotifications :many
WITH 
id_with_row_number AS (
    SELECT unnest($5::varchar(255)[]) AS id, row_number() OVER (ORDER BY unnest($5::varchar(255)[])) AS rn
),
user_with_row_number AS (
    SELECT id AS user_id, row_number() OVER () AS rn
    FROM users
    WHERE deleted = false AND universal = false
)
INSERT INTO notifications (id, owner_id, action, data, event_ids)
SELECT 
    i.id, 
    u.user_id, 
    $1, 
    $2, 
    $3
FROM 
    id_with_row_number i
JOIN 
    user_with_row_number u ON i.rn = u.rn
WHERE NOT EXISTS (
    SELECT 1
    FROM notifications n
    WHERE n.owner_id = u.user_id 
    AND n.data ->> 'internal_id' = $4::varchar
)
RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateAnnouncementNotificationsParams struct {
	Action   persist.Action           `db:"action" json:"action"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
	Internal string                   `db:"internal" json:"internal"`
	Ids      []string                 `db:"ids" json:"ids"`
}

// later on, we might want to add a "global" column to notifications or even an enum column like "match" to determine how largely consumed
// notifications will get searched for for a given user. For example, global notifications will always return for a user and follower notifications will
// perform the check to see if the user follows the owner of the notification. Where this breaks is how we handle "seen" notifications. Since there is 1:1 notifications to users
// right now, we can't have a "seen" field on the notification itself. We would have to move seen out into a separate table.
func (q *Queries) CreateAnnouncementNotifications(ctx context.Context, arg CreateAnnouncementNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, createAnnouncementNotifications,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.Internal,
		arg.Ids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
			&i.PostID,
			&i.TokenID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCollection = `-- name: CreateCollection :one
insert into collections (id, version, name, collectors_note, owner_user_id, gallery_id, layout, nfts, hidden, token_settings, created_at, last_updated) values ($1, 1, $2, $3, $4, $5, $6, $7, $8, $9, now(), now()) returning id
`

type CreateCollectionParams struct {
	ID             persist.DBID                                     `db:"id" json:"id"`
	Name           sql.NullString                                   `db:"name" json:"name"`
	CollectorsNote sql.NullString                                   `db:"collectors_note" json:"collectors_note"`
	OwnerUserID    persist.DBID                                     `db:"owner_user_id" json:"owner_user_id"`
	GalleryID      persist.DBID                                     `db:"gallery_id" json:"gallery_id"`
	Layout         persist.TokenLayout                              `db:"layout" json:"layout"`
	Nfts           persist.DBIDList                                 `db:"nfts" json:"nfts"`
	Hidden         bool                                             `db:"hidden" json:"hidden"`
	TokenSettings  map[persist.DBID]persist.CollectionTokenSettings `db:"token_settings" json:"token_settings"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.ID,
		arg.Name,
		arg.CollectorsNote,
		arg.OwnerUserID,
		arg.GalleryID,
		arg.Layout,
		arg.Nfts,
		arg.Hidden,
		arg.TokenSettings,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const createCollectionEvent = `-- name: CreateCollectionEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, collection_id, subject_id, data, caption, group_id, gallery_id) VALUES ($1, $2, $3, $4, $5, $5, $6, $7, $8, $9) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreateCollectionEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	CollectionID   persist.DBID         `db:"collection_id" json:"collection_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	GalleryID      persist.DBID         `db:"gallery_id" json:"gallery_id"`
}

func (q *Queries) CreateCollectionEvent(ctx context.Context, arg CreateCollectionEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createCollectionEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.CollectionID,
		arg.Data,
		arg.Caption,
		arg.GroupID,
		arg.GalleryID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createCommentEvent = `-- name: CreateCommentEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, comment_id, feed_event_id, post_id, mention_id, subject_id, data, group_id, caption) VALUES ($1, $2, $3, $4, $5, $10, $11, $12, $6, $7, $8, $9) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreateCommentEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	CommentID      persist.DBID         `db:"comment_id" json:"comment_id"`
	SubjectID      persist.DBID         `db:"subject_id" json:"subject_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
	FeedEvent      sql.NullString       `db:"feed_event" json:"feed_event"`
	Post           sql.NullString       `db:"post" json:"post"`
	Mention        sql.NullString       `db:"mention" json:"mention"`
}

func (q *Queries) CreateCommentEvent(ctx context.Context, arg CreateCommentEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createCommentEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.CommentID,
		arg.SubjectID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
		arg.FeedEvent,
		arg.Post,
		arg.Mention,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createCommentNotification = `-- name: CreateCommentNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, feed_event_id, post_id, comment_id) VALUES ($1, $2, $3, $4, $5, $7, $8, $6) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateCommentNotificationParams struct {
	ID        persist.DBID             `db:"id" json:"id"`
	OwnerID   persist.DBID             `db:"owner_id" json:"owner_id"`
	Action    persist.Action           `db:"action" json:"action"`
	Data      persist.NotificationData `db:"data" json:"data"`
	EventIds  persist.DBIDList         `db:"event_ids" json:"event_ids"`
	CommentID persist.DBID             `db:"comment_id" json:"comment_id"`
	FeedEvent sql.NullString           `db:"feed_event" json:"feed_event"`
	Post      sql.NullString           `db:"post" json:"post"`
}

func (q *Queries) CreateCommentNotification(ctx context.Context, arg CreateCommentNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createCommentNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.CommentID,
		arg.FeedEvent,
		arg.Post,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createCommunityEvent = `-- name: CreateCommunityEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, community_id, subject_id, post_id, comment_id, feed_event_id, mention_id, data, group_id, caption) VALUES ($1, $2, $3, $4, $5, $5, $9, $10, $11, $12, $6, $7, $8) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreateCommunityEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	CommunityID    persist.DBID         `db:"community_id" json:"community_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
	Post           sql.NullString       `db:"post" json:"post"`
	Comment        sql.NullString       `db:"comment" json:"comment"`
	FeedEvent      sql.NullString       `db:"feed_event" json:"feed_event"`
	Mention        sql.NullString       `db:"mention" json:"mention"`
}

func (q *Queries) CreateCommunityEvent(ctx context.Context, arg CreateCommunityEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createCommunityEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.CommunityID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
		arg.Post,
		arg.Comment,
		arg.FeedEvent,
		arg.Mention,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createCommunityNotification = `-- name: CreateCommunityNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, feed_event_id, post_id, comment_id, community_id, mention_id) VALUES ($1, $2, $3, $4, $5, $8, $9, $10, $6, $7) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateCommunityNotificationParams struct {
	ID          persist.DBID             `db:"id" json:"id"`
	OwnerID     persist.DBID             `db:"owner_id" json:"owner_id"`
	Action      persist.Action           `db:"action" json:"action"`
	Data        persist.NotificationData `db:"data" json:"data"`
	EventIds    persist.DBIDList         `db:"event_ids" json:"event_ids"`
	CommunityID persist.DBID             `db:"community_id" json:"community_id"`
	MentionID   persist.DBID             `db:"mention_id" json:"mention_id"`
	FeedEvent   sql.NullString           `db:"feed_event" json:"feed_event"`
	Post        sql.NullString           `db:"post" json:"post"`
	Comment     sql.NullString           `db:"comment" json:"comment"`
}

func (q *Queries) CreateCommunityNotification(ctx context.Context, arg CreateCommunityNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createCommunityNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.CommunityID,
		arg.MentionID,
		arg.FeedEvent,
		arg.Post,
		arg.Comment,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createDataOnlyEvent = `-- name: CreateDataOnlyEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, data, group_id, caption, subject_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreateDataOnlyEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
	SubjectID      persist.DBID         `db:"subject_id" json:"subject_id"`
}

func (q *Queries) CreateDataOnlyEvent(ctx context.Context, arg CreateDataOnlyEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createDataOnlyEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
		arg.SubjectID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createFeedEvent = `-- name: CreateFeedEvent :one
INSERT INTO feed_events (id, owner_id, action, data, event_time, event_ids, group_id, caption) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption, group_id
`

type CreateFeedEventParams struct {
	ID        persist.DBID          `db:"id" json:"id"`
	OwnerID   persist.DBID          `db:"owner_id" json:"owner_id"`
	Action    persist.Action        `db:"action" json:"action"`
	Data      persist.FeedEventData `db:"data" json:"data"`
	EventTime time.Time             `db:"event_time" json:"event_time"`
	EventIds  persist.DBIDList      `db:"event_ids" json:"event_ids"`
	GroupID   sql.NullString        `db:"group_id" json:"group_id"`
	Caption   sql.NullString        `db:"caption" json:"caption"`
}

func (q *Queries) CreateFeedEvent(ctx context.Context, arg CreateFeedEventParams) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, createFeedEvent,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventTime,
		arg.EventIds,
		arg.GroupID,
		arg.Caption,
	)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const createGalleryEvent = `-- name: CreateGalleryEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, gallery_id, subject_id, data, external_id, group_id, caption) VALUES ($1, $2, $3, $4, $5, $5, $6, $7, $8, $9) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreateGalleryEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	GalleryID      persist.DBID         `db:"gallery_id" json:"gallery_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	ExternalID     sql.NullString       `db:"external_id" json:"external_id"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
}

func (q *Queries) CreateGalleryEvent(ctx context.Context, arg CreateGalleryEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createGalleryEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.GalleryID,
		arg.Data,
		arg.ExternalID,
		arg.GroupID,
		arg.Caption,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createMentionUserNotification = `-- name: CreateMentionUserNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, feed_event_id, post_id, comment_id, mention_id) VALUES ($1, $2, $3, $4, $5, $7, $8, $9, $6) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateMentionUserNotificationParams struct {
	ID        persist.DBID             `db:"id" json:"id"`
	OwnerID   persist.DBID             `db:"owner_id" json:"owner_id"`
	Action    persist.Action           `db:"action" json:"action"`
	Data      persist.NotificationData `db:"data" json:"data"`
	EventIds  persist.DBIDList         `db:"event_ids" json:"event_ids"`
	MentionID persist.DBID             `db:"mention_id" json:"mention_id"`
	FeedEvent sql.NullString           `db:"feed_event" json:"feed_event"`
	Post      sql.NullString           `db:"post" json:"post"`
	Comment   sql.NullString           `db:"comment" json:"comment"`
}

func (q *Queries) CreateMentionUserNotification(ctx context.Context, arg CreateMentionUserNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createMentionUserNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.MentionID,
		arg.FeedEvent,
		arg.Post,
		arg.Comment,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createPostEvent = `-- name: CreatePostEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, user_id, subject_id, post_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreatePostEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	UserID         persist.DBID         `db:"user_id" json:"user_id"`
	SubjectID      persist.DBID         `db:"subject_id" json:"subject_id"`
	PostID         persist.DBID         `db:"post_id" json:"post_id"`
}

func (q *Queries) CreatePostEvent(ctx context.Context, arg CreatePostEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createPostEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.UserID,
		arg.SubjectID,
		arg.PostID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createPostNotification = `-- name: CreatePostNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, post_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreatePostNotificationParams struct {
	ID       persist.DBID             `db:"id" json:"id"`
	OwnerID  persist.DBID             `db:"owner_id" json:"owner_id"`
	Action   persist.Action           `db:"action" json:"action"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
	PostID   persist.DBID             `db:"post_id" json:"post_id"`
}

func (q *Queries) CreatePostNotification(ctx context.Context, arg CreatePostNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createPostNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.PostID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createPushTickets = `-- name: CreatePushTickets :exec
insert into push_notification_tickets (id, push_token_id, ticket_id, created_at, check_after, num_check_attempts, status, deleted) values
  (
   unnest($1::text[]),
   unnest($2::text[]),
   unnest($3::text[]),
   now(),
   now() + interval '15 minutes',
   0,
   'pending',
   false
  )
`

type CreatePushTicketsParams struct {
	Ids          []string `db:"ids" json:"ids"`
	PushTokenIds []string `db:"push_token_ids" json:"push_token_ids"`
	TicketIds    []string `db:"ticket_ids" json:"ticket_ids"`
}

func (q *Queries) CreatePushTickets(ctx context.Context, arg CreatePushTicketsParams) error {
	_, err := q.db.Exec(ctx, createPushTickets, arg.Ids, arg.PushTokenIds, arg.TicketIds)
	return err
}

const createPushTokenForUser = `-- name: CreatePushTokenForUser :one
insert into push_notification_tokens (id, user_id, push_token, created_at, deleted) values ($1, $2, $3, now(), false) returning id, user_id, push_token, created_at, deleted
`

type CreatePushTokenForUserParams struct {
	ID        persist.DBID `db:"id" json:"id"`
	UserID    persist.DBID `db:"user_id" json:"user_id"`
	PushToken string       `db:"push_token" json:"push_token"`
}

func (q *Queries) CreatePushTokenForUser(ctx context.Context, arg CreatePushTokenForUserParams) (PushNotificationToken, error) {
	row := q.db.QueryRow(ctx, createPushTokenForUser, arg.ID, arg.UserID, arg.PushToken)
	var i PushNotificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PushToken,
		&i.CreatedAt,
		&i.Deleted,
	)
	return i, err
}

const createSimpleNotification = `-- name: CreateSimpleNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids) VALUES ($1, $2, $3, $4, $5) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateSimpleNotificationParams struct {
	ID       persist.DBID             `db:"id" json:"id"`
	OwnerID  persist.DBID             `db:"owner_id" json:"owner_id"`
	Action   persist.Action           `db:"action" json:"action"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
}

func (q *Queries) CreateSimpleNotification(ctx context.Context, arg CreateSimpleNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createSimpleNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createTokenEvent = `-- name: CreateTokenEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, token_id, subject_id, data, group_id, caption, gallery_id, collection_id) VALUES ($1, $2, $3, $4, $5, $5, $6, $7, $8, $9, $10) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreateTokenEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	TokenID        persist.DBID         `db:"token_id" json:"token_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
	Gallery        sql.NullString       `db:"gallery" json:"gallery"`
	Collection     sql.NullString       `db:"collection" json:"collection"`
}

func (q *Queries) CreateTokenEvent(ctx context.Context, arg CreateTokenEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createTokenEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.TokenID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
		arg.Gallery,
		arg.Collection,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createTokenNotification = `-- name: CreateTokenNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, token_id, amount) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateTokenNotificationParams struct {
	ID       persist.DBID             `db:"id" json:"id"`
	OwnerID  persist.DBID             `db:"owner_id" json:"owner_id"`
	Action   persist.Action           `db:"action" json:"action"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
	TokenID  persist.DBID             `db:"token_id" json:"token_id"`
	Amount   int32                    `db:"amount" json:"amount"`
}

func (q *Queries) CreateTokenNotification(ctx context.Context, arg CreateTokenNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createTokenNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.TokenID,
		arg.Amount,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createUserEvent = `-- name: CreateUserEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, user_id, subject_id, post_id, comment_id, feed_event_id, mention_id, data, group_id, caption) VALUES ($1, $2, $3, $4, $5, $5, $9, $10, $11, $12, $6, $7, $8) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id
`

type CreateUserEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	UserID         persist.DBID         `db:"user_id" json:"user_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
	Post           sql.NullString       `db:"post" json:"post"`
	Comment        sql.NullString       `db:"comment" json:"comment"`
	FeedEvent      sql.NullString       `db:"feed_event" json:"feed_event"`
	Mention        sql.NullString       `db:"mention" json:"mention"`
}

func (q *Queries) CreateUserEvent(ctx context.Context, arg CreateUserEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createUserEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.UserID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
		arg.Post,
		arg.Comment,
		arg.FeedEvent,
		arg.Mention,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createUserPostedYourWorkNotification = `-- name: CreateUserPostedYourWorkNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, post_id, community_id) VALUES ($1, $2, $3, $4, $5, $7, $6) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateUserPostedYourWorkNotificationParams struct {
	ID          persist.DBID             `db:"id" json:"id"`
	OwnerID     persist.DBID             `db:"owner_id" json:"owner_id"`
	Action      persist.Action           `db:"action" json:"action"`
	Data        persist.NotificationData `db:"data" json:"data"`
	EventIds    persist.DBIDList         `db:"event_ids" json:"event_ids"`
	CommunityID persist.DBID             `db:"community_id" json:"community_id"`
	Post        sql.NullString           `db:"post" json:"post"`
}

func (q *Queries) CreateUserPostedYourWorkNotification(ctx context.Context, arg CreateUserPostedYourWorkNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createUserPostedYourWorkNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.CommunityID,
		arg.Post,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const createViewGalleryNotification = `-- name: CreateViewGalleryNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, gallery_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id
`

type CreateViewGalleryNotificationParams struct {
	ID        persist.DBID             `db:"id" json:"id"`
	OwnerID   persist.DBID             `db:"owner_id" json:"owner_id"`
	Action    persist.Action           `db:"action" json:"action"`
	Data      persist.NotificationData `db:"data" json:"data"`
	EventIds  persist.DBIDList         `db:"event_ids" json:"event_ids"`
	GalleryID persist.DBID             `db:"gallery_id" json:"gallery_id"`
}

func (q *Queries) CreateViewGalleryNotification(ctx context.Context, arg CreateViewGalleryNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createViewGalleryNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.GalleryID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const deleteCollections = `-- name: DeleteCollections :exec
update collections set deleted = true, last_updated = now() where id = any($1::varchar[])
`

func (q *Queries) DeleteCollections(ctx context.Context, ids []string) error {
	_, err := q.db.Exec(ctx, deleteCollections, ids)
	return err
}

const deletePostByID = `-- name: DeletePostByID :exec
update posts set deleted = true where id = $1
`

func (q *Queries) DeletePostByID(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, deletePostByID, id)
	return err
}

const deletePushTokensByIDs = `-- name: DeletePushTokensByIDs :exec
update push_notification_tokens set deleted = true where id = any($1) and deleted = false
`

func (q *Queries) DeletePushTokensByIDs(ctx context.Context, ids persist.DBIDList) error {
	_, err := q.db.Exec(ctx, deletePushTokensByIDs, ids)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
update users set deleted = true where id = $1
`

func (q *Queries) DeleteUserByID(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, deleteUserByID, id)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
update user_roles set deleted = true, last_updated = now() where user_id = $1 and role = any($2)
`

type DeleteUserRolesParams struct {
	UserID persist.DBID     `db:"user_id" json:"user_id"`
	Roles  persist.RoleList `db:"roles" json:"roles"`
}

func (q *Queries) DeleteUserRoles(ctx context.Context, arg DeleteUserRolesParams) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, arg.UserID, arg.Roles)
	return err
}

const deleteWalletByID = `-- name: DeleteWalletByID :exec
update wallets set deleted = true, last_updated = now() where id = $1
`

func (q *Queries) DeleteWalletByID(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, deleteWalletByID, id)
	return err
}

const getActiveWallets = `-- name: GetActiveWallets :many
select w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type, w.chain, w.l1_chain from users u join wallets w on w.id = any(u.wallets) where not u.deleted and not w.deleted and not u.universal
`

func (q *Queries) GetActiveWallets(ctx context.Context) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getActiveWallets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
			&i.L1Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActorForGroup = `-- name: GetActorForGroup :one
select actor_id from events where group_id = $1 and deleted = false order by(created_at, id) asc limit 1
`

func (q *Queries) GetActorForGroup(ctx context.Context, groupID sql.NullString) (sql.NullString, error) {
	row := q.db.QueryRow(ctx, getActorForGroup, groupID)
	var actor_id sql.NullString
	err := row.Scan(&actor_id)
	return actor_id, err
}

const getAdmireByAdmireID = `-- name: GetAdmireByAdmireID :one
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated, post_id, token_id, comment_id FROM admires WHERE id = $1 AND deleted = false
`

func (q *Queries) GetAdmireByAdmireID(ctx context.Context, id persist.DBID) (Admire, error) {
	row := q.db.QueryRow(ctx, getAdmireByAdmireID, id)
	var i Admire
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.FeedEventID,
		&i.ActorID,
		&i.Deleted,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.PostID,
		&i.TokenID,
		&i.CommentID,
	)
	return i, err
}

const getAdmiresByActorID = `-- name: GetAdmiresByActorID :many
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated, post_id, token_id, comment_id FROM admires WHERE actor_id = $1 AND deleted = false ORDER BY created_at DESC
`

func (q *Queries) GetAdmiresByActorID(ctx context.Context, actorID persist.DBID) ([]Admire, error) {
	rows, err := q.db.Query(ctx, getAdmiresByActorID, actorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Admire
	for rows.Next() {
		var i Admire
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.PostID,
			&i.TokenID,
			&i.CommentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdmiresByAdmireIDs = `-- name: GetAdmiresByAdmireIDs :many
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated, post_id, token_id, comment_id from admires WHERE id = ANY($1) AND deleted = false
`

func (q *Queries) GetAdmiresByAdmireIDs(ctx context.Context, admireIds persist.DBIDList) ([]Admire, error) {
	rows, err := q.db.Query(ctx, getAdmiresByAdmireIDs, admireIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Admire
	for rows.Next() {
		var i Admire
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.PostID,
			&i.TokenID,
			&i.CommentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTimeTrendingUserIDs = `-- name: GetAllTimeTrendingUserIDs :many
select users.id
from events, galleries, users
left join legacy_views on users.id = legacy_views.user_id and legacy_views.deleted = false
where action = 'ViewedGallery'
  and events.gallery_id = galleries.id
  and users.id = galleries.owner_user_id
  and galleries.deleted = false
  and users.deleted = false
group by users.id
order by row_number() over(order by count(events.id) + coalesce(max(legacy_views.view_count), 0) desc, max(users.created_at) desc) asc
limit $1
`

func (q *Queries) GetAllTimeTrendingUserIDs(ctx context.Context, limit int32) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, getAllTimeTrendingUserIDs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var id persist.DBID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCheckablePushTickets = `-- name: GetCheckablePushTickets :many
select id, push_token_id, ticket_id, created_at, check_after, num_check_attempts, deleted, status from push_notification_tickets where check_after <= now() and deleted = false limit $1
`

func (q *Queries) GetCheckablePushTickets(ctx context.Context, limit int32) ([]PushNotificationTicket, error) {
	rows, err := q.db.Query(ctx, getCheckablePushTickets, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PushNotificationTicket
	for rows.Next() {
		var i PushNotificationTicket
		if err := rows.Scan(
			&i.ID,
			&i.PushTokenID,
			&i.TicketID,
			&i.CreatedAt,
			&i.CheckAfter,
			&i.NumCheckAttempts,
			&i.Deleted,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionById = `-- name: GetCollectionById :one
SELECT id, deleted, owner_user_id, nfts, version, last_updated, created_at, hidden, collectors_note, name, layout, token_settings, gallery_id FROM collections WHERE id = $1 AND deleted = false
`

func (q *Queries) GetCollectionById(ctx context.Context, id persist.DBID) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionById, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerUserID,
		&i.Nfts,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Hidden,
		&i.CollectorsNote,
		&i.Name,
		&i.Layout,
		&i.TokenSettings,
		&i.GalleryID,
	)
	return i, err
}

const getCollectionTokensByCollectionID = `-- name: GetCollectionTokensByCollectionID :one
select nfts from collections where id = $1 and deleted = false
`

func (q *Queries) GetCollectionTokensByCollectionID(ctx context.Context, id persist.DBID) (persist.DBIDList, error) {
	row := q.db.QueryRow(ctx, getCollectionTokensByCollectionID, id)
	var nfts persist.DBIDList
	err := row.Scan(&nfts)
	return nfts, err
}

const getCollectionsByGalleryId = `-- name: GetCollectionsByGalleryId :many
SELECT c.id, c.deleted, c.owner_user_id, c.nfts, c.version, c.last_updated, c.created_at, c.hidden, c.collectors_note, c.name, c.layout, c.token_settings, c.gallery_id FROM galleries g, unnest(g.collections)
    WITH ORDINALITY AS x(coll_id, coll_ord)
    INNER JOIN collections c ON c.id = x.coll_id
    WHERE g.id = $1 AND g.deleted = false AND c.deleted = false ORDER BY x.coll_ord
`

func (q *Queries) GetCollectionsByGalleryId(ctx context.Context, id persist.DBID) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getCollectionsByGalleryId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerUserID,
			&i.Nfts,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Hidden,
			&i.CollectorsNote,
			&i.Name,
			&i.Layout,
			&i.TokenSettings,
			&i.GalleryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentByCommentID = `-- name: GetCommentByCommentID :one
SELECT id, version, feed_event_id, actor_id, reply_to, comment, deleted, created_at, last_updated, post_id, removed, top_level_comment_id FROM comments WHERE id = $1 AND deleted = false
`

func (q *Queries) GetCommentByCommentID(ctx context.Context, id persist.DBID) (Comment, error) {
	row := q.db.QueryRow(ctx, getCommentByCommentID, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.FeedEventID,
		&i.ActorID,
		&i.ReplyTo,
		&i.Comment,
		&i.Deleted,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.PostID,
		&i.Removed,
		&i.TopLevelCommentID,
	)
	return i, err
}

const getCommentsByCommentIDs = `-- name: GetCommentsByCommentIDs :many
SELECT id, version, feed_event_id, actor_id, reply_to, comment, deleted, created_at, last_updated, post_id, removed, top_level_comment_id from comments WHERE id = ANY($1) AND deleted = false
`

func (q *Queries) GetCommentsByCommentIDs(ctx context.Context, commentIds persist.DBIDList) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getCommentsByCommentIDs, commentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.ReplyTo,
			&i.Comment,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.PostID,
			&i.Removed,
			&i.TopLevelCommentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContractByChainAddress = `-- name: GetContractByChainAddress :one
select id, deleted, version, created_at, last_updated, name, symbol, address, creator_address, chain, profile_banner_url, profile_image_url, badge_url, description, owner_address, is_provider_marked_spam, parent_id, override_creator_user_id, l1_chain FROM contracts WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetContractByChainAddressParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetContractByChainAddress(ctx context.Context, arg GetContractByChainAddressParams) (Contract, error) {
	row := q.db.QueryRow(ctx, getContractByChainAddress, arg.Address, arg.Chain)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Name,
		&i.Symbol,
		&i.Address,
		&i.CreatorAddress,
		&i.Chain,
		&i.ProfileBannerUrl,
		&i.ProfileImageUrl,
		&i.BadgeUrl,
		&i.Description,
		&i.OwnerAddress,
		&i.IsProviderMarkedSpam,
		&i.ParentID,
		&i.OverrideCreatorUserID,
		&i.L1Chain,
	)
	return i, err
}

const getContractByID = `-- name: GetContractByID :one
select id, deleted, version, created_at, last_updated, name, symbol, address, creator_address, chain, profile_banner_url, profile_image_url, badge_url, description, owner_address, is_provider_marked_spam, parent_id, override_creator_user_id, l1_chain FROM contracts WHERE id = $1 AND deleted = false
`

func (q *Queries) GetContractByID(ctx context.Context, id persist.DBID) (Contract, error) {
	row := q.db.QueryRow(ctx, getContractByID, id)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Name,
		&i.Symbol,
		&i.Address,
		&i.CreatorAddress,
		&i.Chain,
		&i.ProfileBannerUrl,
		&i.ProfileImageUrl,
		&i.BadgeUrl,
		&i.Description,
		&i.OwnerAddress,
		&i.IsProviderMarkedSpam,
		&i.ParentID,
		&i.OverrideCreatorUserID,
		&i.L1Chain,
	)
	return i, err
}

const getContractCreatorsByIds = `-- name: GetContractCreatorsByIds :many
with keys as (
    select unnest ($1::text[]) as id
         , generate_subscripts($1::text[], 1) as batch_key_index
)
select k.batch_key_index, c.contract_id, c.creator_user_id, c.chain, c.creator_address from keys k
    join contract_creators c on c.contract_id = k.id
`

type GetContractCreatorsByIdsRow struct {
	BatchKeyIndex   int32           `db:"batch_key_index" json:"batch_key_index"`
	ContractCreator ContractCreator `db:"contractcreator" json:"contractcreator"`
}

func (q *Queries) GetContractCreatorsByIds(ctx context.Context, contractIds []string) ([]GetContractCreatorsByIdsRow, error) {
	rows, err := q.db.Query(ctx, getContractCreatorsByIds, contractIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContractCreatorsByIdsRow
	for rows.Next() {
		var i GetContractCreatorsByIdsRow
		if err := rows.Scan(
			&i.BatchKeyIndex,
			&i.ContractCreator.ContractID,
			&i.ContractCreator.CreatorUserID,
			&i.ContractCreator.Chain,
			&i.ContractCreator.CreatorAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContractsByIDs = `-- name: GetContractsByIDs :many
with keys as (
    select unnest ($1::varchar[]) as id
         , generate_subscripts($1::varchar[], 1) as batch_key_index
)
select k.batch_key_index, c.id, c.deleted, c.version, c.created_at, c.last_updated, c.name, c.symbol, c.address, c.creator_address, c.chain, c.profile_banner_url, c.profile_image_url, c.badge_url, c.description, c.owner_address, c.is_provider_marked_spam, c.parent_id, c.override_creator_user_id, c.l1_chain from keys k
    join contracts c on c.id = k.id
    where not c.deleted
`

type GetContractsByIDsRow struct {
	BatchKeyIndex int32    `db:"batch_key_index" json:"batch_key_index"`
	Contract      Contract `db:"contract" json:"contract"`
}

func (q *Queries) GetContractsByIDs(ctx context.Context, contractIds []string) ([]GetContractsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getContractsByIDs, contractIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContractsByIDsRow
	for rows.Next() {
		var i GetContractsByIDsRow
		if err := rows.Scan(
			&i.BatchKeyIndex,
			&i.Contract.ID,
			&i.Contract.Deleted,
			&i.Contract.Version,
			&i.Contract.CreatedAt,
			&i.Contract.LastUpdated,
			&i.Contract.Name,
			&i.Contract.Symbol,
			&i.Contract.Address,
			&i.Contract.CreatorAddress,
			&i.Contract.Chain,
			&i.Contract.ProfileBannerUrl,
			&i.Contract.ProfileImageUrl,
			&i.Contract.BadgeUrl,
			&i.Contract.Description,
			&i.Contract.OwnerAddress,
			&i.Contract.IsProviderMarkedSpam,
			&i.Contract.ParentID,
			&i.Contract.OverrideCreatorUserID,
			&i.Contract.L1Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContractsByTokenIDs = `-- name: GetContractsByTokenIDs :many
select contracts.id, contracts.deleted, contracts.version, contracts.created_at, contracts.last_updated, contracts.name, contracts.symbol, contracts.address, contracts.creator_address, contracts.chain, contracts.profile_banner_url, contracts.profile_image_url, contracts.badge_url, contracts.description, contracts.owner_address, contracts.is_provider_marked_spam, contracts.parent_id, contracts.override_creator_user_id, contracts.l1_chain from contracts join tokens on contracts.id = tokens.contract_id where tokens.id = any($1) and contracts.deleted = false
`

func (q *Queries) GetContractsByTokenIDs(ctx context.Context, tokenIds persist.DBIDList) ([]Contract, error) {
	rows, err := q.db.Query(ctx, getContractsByTokenIDs, tokenIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Address,
			&i.CreatorAddress,
			&i.Chain,
			&i.ProfileBannerUrl,
			&i.ProfileImageUrl,
			&i.BadgeUrl,
			&i.Description,
			&i.OwnerAddress,
			&i.IsProviderMarkedSpam,
			&i.ParentID,
			&i.OverrideCreatorUserID,
			&i.L1Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCreatedContractsByUserID = `-- name: GetCreatedContractsByUserID :many
select c.id, c.deleted, c.version, c.created_at, c.last_updated, c.name, c.symbol, c.address, c.creator_address, c.chain, c.profile_banner_url, c.profile_image_url, c.badge_url, c.description, c.owner_address, c.is_provider_marked_spam, c.parent_id, c.override_creator_user_id, c.l1_chain,
       w.id as wallet_id,
       false as is_override_creator
from users u, contracts c, wallets w
where u.id = $1
  and c.chain = any($2::int[])
  and w.id = any(u.wallets) and coalesce(nullif(c.owner_address, ''), nullif(c.creator_address, '')) = w.address 
  and w.l1_chain = c.l1_chain
  and u.deleted = false
  and c.deleted = false
  and w.deleted = false
  and c.override_creator_user_id is null
  and (not $3::bool or not exists(
    select 1 from tokens t
        where t.owner_user_id = $1
          and t.contract_id = c.id
          and t.is_creator_token
          and not t.deleted
        )
    )

union all

select c.id, c.deleted, c.version, c.created_at, c.last_updated, c.name, c.symbol, c.address, c.creator_address, c.chain, c.profile_banner_url, c.profile_image_url, c.badge_url, c.description, c.owner_address, c.is_provider_marked_spam, c.parent_id, c.override_creator_user_id, c.l1_chain,
       null as wallet_id,
       true as is_override_creator
from contracts c
where c.override_creator_user_id = $1
  and c.chain = any($2::int[])
  and c.deleted = false
  and (not $3::bool or not exists(
    select 1 from tokens t
        where t.owner_user_id = $1
          and t.contract_id = c.id
          and t.is_creator_token
          and not t.deleted
        )
    )
`

type GetCreatedContractsByUserIDParams struct {
	UserID           persist.DBID `db:"user_id" json:"user_id"`
	Chains           []int32      `db:"chains" json:"chains"`
	NewContractsOnly bool         `db:"new_contracts_only" json:"new_contracts_only"`
}

type GetCreatedContractsByUserIDRow struct {
	Contract          Contract     `db:"contract" json:"contract"`
	WalletID          persist.DBID `db:"wallet_id" json:"wallet_id"`
	IsOverrideCreator bool         `db:"is_override_creator" json:"is_override_creator"`
}

func (q *Queries) GetCreatedContractsByUserID(ctx context.Context, arg GetCreatedContractsByUserIDParams) ([]GetCreatedContractsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getCreatedContractsByUserID, arg.UserID, arg.Chains, arg.NewContractsOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCreatedContractsByUserIDRow
	for rows.Next() {
		var i GetCreatedContractsByUserIDRow
		if err := rows.Scan(
			&i.Contract.ID,
			&i.Contract.Deleted,
			&i.Contract.Version,
			&i.Contract.CreatedAt,
			&i.Contract.LastUpdated,
			&i.Contract.Name,
			&i.Contract.Symbol,
			&i.Contract.Address,
			&i.Contract.CreatorAddress,
			&i.Contract.Chain,
			&i.Contract.ProfileBannerUrl,
			&i.Contract.ProfileImageUrl,
			&i.Contract.BadgeUrl,
			&i.Contract.Description,
			&i.Contract.OwnerAddress,
			&i.Contract.IsProviderMarkedSpam,
			&i.Contract.ParentID,
			&i.Contract.OverrideCreatorUserID,
			&i.Contract.L1Chain,
			&i.WalletID,
			&i.IsOverrideCreator,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentTime = `-- name: GetCurrentTime :one
select now()::timestamptz
`

func (q *Queries) GetCurrentTime(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRow(ctx, getCurrentTime)
	var column_1 time.Time
	err := row.Scan(&column_1)
	return column_1, err
}

const getEthereumWalletsForEnsProfileImagesByUserID = `-- name: GetEthereumWalletsForEnsProfileImagesByUserID :many
select w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type, w.chain, w.l1_chain
from wallets w
join users u on w.id = any(u.wallets)
where u.id = $1 and w.chain = 0 and not w.deleted
order by u.primary_wallet_id = w.id desc, w.id desc
`

func (q *Queries) GetEthereumWalletsForEnsProfileImagesByUserID(ctx context.Context, id persist.DBID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getEthereumWalletsForEnsProfileImagesByUserID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
			&i.L1Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvent = `-- name: GetEvent :one
SELECT id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id FROM events WHERE id = $1 AND deleted = false
`

func (q *Queries) GetEvent(ctx context.Context, id persist.DBID) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.CollectionID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.GalleryID,
		&i.CommentID,
		&i.AdmireID,
		&i.FeedEventID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
		&i.PostID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const getEventsInGroup = `-- name: GetEventsInGroup :many
select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id from events where group_id = $1 and deleted = false order by(created_at, id) asc
`

func (q *Queries) GetEventsInGroup(ctx context.Context, groupID sql.NullString) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.TokenID,
			&i.CollectionID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.GalleryID,
			&i.CommentID,
			&i.AdmireID,
			&i.FeedEventID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
			&i.PostID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsInWindow = `-- name: GetEventsInWindow :many
with recursive activity as (
    select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id from events where events.id = $1 and deleted = false
    union
    select e.id, e.version, e.actor_id, e.resource_type_id, e.subject_id, e.user_id, e.token_id, e.collection_id, e.action, e.data, e.deleted, e.last_updated, e.created_at, e.gallery_id, e.comment_id, e.admire_id, e.feed_event_id, e.external_id, e.caption, e.group_id, e.post_id, e.mention_id, e.community_id from events e, activity a
    where e.actor_id = a.actor_id
        and e.action = any($3)
        and e.created_at < a.created_at
        and e.created_at >= a.created_at - make_interval(secs => $2)
        and e.deleted = false
        and e.caption is null
        and (not $4::bool or e.subject_id = a.subject_id)
)
select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id from events where id = any(select id from activity) order by (created_at, id) asc
`

type GetEventsInWindowParams struct {
	ID             persist.DBID       `db:"id" json:"id"`
	Secs           float64            `db:"secs" json:"secs"`
	Actions        persist.ActionList `db:"actions" json:"actions"`
	IncludeSubject bool               `db:"include_subject" json:"include_subject"`
}

func (q *Queries) GetEventsInWindow(ctx context.Context, arg GetEventsInWindowParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsInWindow,
		arg.ID,
		arg.Secs,
		arg.Actions,
		arg.IncludeSubject,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.TokenID,
			&i.CollectionID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.GalleryID,
			&i.CommentID,
			&i.AdmireID,
			&i.FeedEventID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
			&i.PostID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFarcasterConnections = `-- name: GetFarcasterConnections :many
with farcaster         as ( select unnest($1::varchar[]) fid ),
	 farcaster_gallery as ( select user_id, pii_unverified_email_address, deleted, pii_socials, pii_verified_email_address, fid from pii.for_users p join farcaster on p.pii_socials->'Farcaster'->>'id' = farcaster.fid ),
	 not_followed      as ( select user_id, pii_unverified_email_address, fg.deleted, pii_socials, pii_verified_email_address, fid, id, follower, followee, f.deleted, created_at, last_updated from farcaster_gallery fg left join follows f on f.follower = $2 and f.followee = fg.user_id where f.id is null ),
	 farcaster_users   as ( select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_gallery, u.primary_wallet_id, u.user_experiences, u.profile_image_id, u.persona from users u join not_followed on u.id = not_followed.user_id and not u.deleted and not u.universal ),
	 ordering          as ( select f.id
	                            , rank() over (order by sum(cardinality(c.nfts)) desc nulls last) display_rank
	                            , rank() over (order by count(p.id) desc nulls last) post_rank
	 						from farcaster_users f
	 						left join collections c on f.id = c.owner_user_id and not c.deleted
	 						left join posts p on f.id = p.actor_id and not p.deleted
	 						group by f.id )
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_gallery, users.primary_wallet_id, users.user_experiences, users.profile_image_id, users.persona
from farcaster_users users
left join ordering using(id)
order by ((ordering.display_rank + ordering.post_rank) / 2) asc nulls last
limit 200
`

type GetFarcasterConnectionsParams struct {
	Fids   []string     `db:"fids" json:"fids"`
	UserID persist.DBID `db:"user_id" json:"user_id"`
}

type GetFarcasterConnectionsRow struct {
	User User `db:"user" json:"user"`
}

func (q *Queries) GetFarcasterConnections(ctx context.Context, arg GetFarcasterConnectionsParams) ([]GetFarcasterConnectionsRow, error) {
	rows, err := q.db.Query(ctx, getFarcasterConnections, arg.Fids, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFarcasterConnectionsRow
	for rows.Next() {
		var i GetFarcasterConnectionsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Deleted,
			&i.User.Version,
			&i.User.LastUpdated,
			&i.User.CreatedAt,
			&i.User.Username,
			&i.User.UsernameIdempotent,
			&i.User.Wallets,
			&i.User.Bio,
			&i.User.Traits,
			&i.User.Universal,
			&i.User.NotificationSettings,
			&i.User.EmailUnsubscriptions,
			&i.User.FeaturedGallery,
			&i.User.PrimaryWalletID,
			&i.User.UserExperiences,
			&i.User.ProfileImageID,
			&i.User.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeedEventByID = `-- name: GetFeedEventByID :one
SELECT id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption, group_id FROM feed_events WHERE id = $1 AND deleted = false
`

func (q *Queries) GetFeedEventByID(ctx context.Context, id persist.DBID) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, getFeedEventByID, id)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const getFeedEventsByIds = `-- name: GetFeedEventsByIds :many
SELECT id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption, group_id FROM feed_events WHERE id = ANY($1::varchar(255)[]) AND deleted = false
`

func (q *Queries) GetFeedEventsByIds(ctx context.Context, ids []string) ([]FeedEvent, error) {
	rows, err := q.db.Query(ctx, getFeedEventsByIds, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedEvent
	for rows.Next() {
		var i FeedEvent
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.OwnerID,
			&i.Action,
			&i.Data,
			&i.EventTime,
			&i.EventIds,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Caption,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGalleriesByUserId = `-- name: GetGalleriesByUserId :many
SELECT id, deleted, last_updated, created_at, version, owner_user_id, collections, name, description, hidden, position FROM galleries WHERE owner_user_id = $1 AND deleted = false order by position
`

func (q *Queries) GetGalleriesByUserId(ctx context.Context, ownerUserID persist.DBID) ([]Gallery, error) {
	rows, err := q.db.Query(ctx, getGalleriesByUserId, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gallery
	for rows.Next() {
		var i Gallery
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Version,
			&i.OwnerUserID,
			&i.Collections,
			&i.Name,
			&i.Description,
			&i.Hidden,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGalleryByCollectionId = `-- name: GetGalleryByCollectionId :one
SELECT g.id, g.deleted, g.last_updated, g.created_at, g.version, g.owner_user_id, g.collections, g.name, g.description, g.hidden, g.position FROM galleries g, collections c WHERE c.id = $1 AND c.deleted = false AND $1 = ANY(g.collections) AND g.deleted = false
`

func (q *Queries) GetGalleryByCollectionId(ctx context.Context, id persist.DBID) (Gallery, error) {
	row := q.db.QueryRow(ctx, getGalleryByCollectionId, id)
	var i Gallery
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Version,
		&i.OwnerUserID,
		&i.Collections,
		&i.Name,
		&i.Description,
		&i.Hidden,
		&i.Position,
	)
	return i, err
}

const getGalleryById = `-- name: GetGalleryById :one
SELECT id, deleted, last_updated, created_at, version, owner_user_id, collections, name, description, hidden, position FROM galleries WHERE id = $1 AND deleted = false
`

func (q *Queries) GetGalleryById(ctx context.Context, id persist.DBID) (Gallery, error) {
	row := q.db.QueryRow(ctx, getGalleryById, id)
	var i Gallery
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Version,
		&i.OwnerUserID,
		&i.Collections,
		&i.Name,
		&i.Description,
		&i.Hidden,
		&i.Position,
	)
	return i, err
}

const getGalleryEventsInWindow = `-- name: GetGalleryEventsInWindow :many
with recursive activity as (
    select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id from events where events.id = $1 and deleted = false
    union
    select e.id, e.version, e.actor_id, e.resource_type_id, e.subject_id, e.user_id, e.token_id, e.collection_id, e.action, e.data, e.deleted, e.last_updated, e.created_at, e.gallery_id, e.comment_id, e.admire_id, e.feed_event_id, e.external_id, e.caption, e.group_id, e.post_id, e.mention_id, e.community_id from events e, activity a
    where e.actor_id = a.actor_id
        and e.action = any($3)
        and e.gallery_id = $4
        and e.created_at < a.created_at
        and e.created_at >= a.created_at - make_interval(secs => $2)
        and e.deleted = false
        and e.caption is null
        and (not $5::bool or e.subject_id = a.subject_id)
)
select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, collection_id, action, data, deleted, last_updated, created_at, gallery_id, comment_id, admire_id, feed_event_id, external_id, caption, group_id, post_id, mention_id, community_id from events where id = any(select id from activity) order by (created_at, id) asc
`

type GetGalleryEventsInWindowParams struct {
	ID             persist.DBID       `db:"id" json:"id"`
	Secs           float64            `db:"secs" json:"secs"`
	Actions        persist.ActionList `db:"actions" json:"actions"`
	GalleryID      persist.DBID       `db:"gallery_id" json:"gallery_id"`
	IncludeSubject bool               `db:"include_subject" json:"include_subject"`
}

func (q *Queries) GetGalleryEventsInWindow(ctx context.Context, arg GetGalleryEventsInWindowParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getGalleryEventsInWindow,
		arg.ID,
		arg.Secs,
		arg.Actions,
		arg.GalleryID,
		arg.IncludeSubject,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.TokenID,
			&i.CollectionID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.GalleryID,
			&i.CommentID,
			&i.AdmireID,
			&i.FeedEventID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
			&i.PostID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGalleryIDByCollectionID = `-- name: GetGalleryIDByCollectionID :one
select gallery_id from collections where id = $1 and deleted = false
`

func (q *Queries) GetGalleryIDByCollectionID(ctx context.Context, id persist.DBID) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, getGalleryIDByCollectionID, id)
	var gallery_id persist.DBID
	err := row.Scan(&gallery_id)
	return gallery_id, err
}

const getHighlightMintClaim = `-- name: GetHighlightMintClaim :one
select id, user_id, chain, contract_address, recipient_wallet_id, collection_id, token_id, claim_id, status, error_message, created_at, last_updated, deleted from highlight_mint_claims where id = $1 and not deleted
`

func (q *Queries) GetHighlightMintClaim(ctx context.Context, id persist.DBID) (HighlightMintClaim, error) {
	row := q.db.QueryRow(ctx, getHighlightMintClaim, id)
	var i HighlightMintClaim
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Chain,
		&i.ContractAddress,
		&i.RecipientWalletID,
		&i.CollectionID,
		&i.TokenID,
		&i.ClaimID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
	)
	return i, err
}

const getLastFeedEventForCollection = `-- name: GetLastFeedEventForCollection :one
select id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption, group_id from feed_events where deleted = false
    and owner_id = $1
    and action = any($3)
    and data ->> 'collection_id' = $4
    and event_time < $2
    order by event_time desc
    limit 1
`

type GetLastFeedEventForCollectionParams struct {
	OwnerID      persist.DBID       `db:"owner_id" json:"owner_id"`
	EventTime    time.Time          `db:"event_time" json:"event_time"`
	Actions      persist.ActionList `db:"actions" json:"actions"`
	CollectionID persist.DBID       `db:"collection_id" json:"collection_id"`
}

func (q *Queries) GetLastFeedEventForCollection(ctx context.Context, arg GetLastFeedEventForCollectionParams) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, getLastFeedEventForCollection,
		arg.OwnerID,
		arg.EventTime,
		arg.Actions,
		arg.CollectionID,
	)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const getLastFeedEventForToken = `-- name: GetLastFeedEventForToken :one
select id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption, group_id from feed_events where deleted = false
    and owner_id = $1
    and action = any($3)
    and data ->> 'token_id' = $4::varchar
    and event_time < $2
    order by event_time desc
    limit 1
`

type GetLastFeedEventForTokenParams struct {
	OwnerID   persist.DBID       `db:"owner_id" json:"owner_id"`
	EventTime time.Time          `db:"event_time" json:"event_time"`
	Actions   persist.ActionList `db:"actions" json:"actions"`
	TokenID   string             `db:"token_id" json:"token_id"`
}

func (q *Queries) GetLastFeedEventForToken(ctx context.Context, arg GetLastFeedEventForTokenParams) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, getLastFeedEventForToken,
		arg.OwnerID,
		arg.EventTime,
		arg.Actions,
		arg.TokenID,
	)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const getLastFeedEventForUser = `-- name: GetLastFeedEventForUser :one
select id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption, group_id from feed_events where deleted = false
    and owner_id = $1
    and action = any($3)
    and event_time < $2
    order by event_time desc
    limit 1
`

type GetLastFeedEventForUserParams struct {
	OwnerID   persist.DBID       `db:"owner_id" json:"owner_id"`
	EventTime time.Time          `db:"event_time" json:"event_time"`
	Actions   persist.ActionList `db:"actions" json:"actions"`
}

func (q *Queries) GetLastFeedEventForUser(ctx context.Context, arg GetLastFeedEventForUserParams) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, getLastFeedEventForUser, arg.OwnerID, arg.EventTime, arg.Actions)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const getMediaByTokenIdentifiersIgnoringStatus = `-- name: GetMediaByTokenIdentifiersIgnoringStatus :one
select token_medias.id, token_medias.created_at, token_medias.last_updated, token_medias.version, token_medias.active, token_medias.media, token_medias.processing_job_id, token_medias.deleted
from token_definitions
join token_medias on token_definitions.token_media_id = token_medias.id
where (chain, contract_address, token_id) = ($1, $2, $3)
    and not token_definitions.deleted
    and not token_medias.deleted
`

type GetMediaByTokenIdentifiersIgnoringStatusParams struct {
	Chain           persist.Chain      `db:"chain" json:"chain"`
	ContractAddress persist.Address    `db:"contract_address" json:"contract_address"`
	TokenID         persist.HexTokenID `db:"token_id" json:"token_id"`
}

func (q *Queries) GetMediaByTokenIdentifiersIgnoringStatus(ctx context.Context, arg GetMediaByTokenIdentifiersIgnoringStatusParams) (TokenMedia, error) {
	row := q.db.QueryRow(ctx, getMediaByTokenIdentifiersIgnoringStatus, arg.Chain, arg.ContractAddress, arg.TokenID)
	var i TokenMedia
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Version,
		&i.Active,
		&i.Media,
		&i.ProcessingJobID,
		&i.Deleted,
	)
	return i, err
}

const getMembershipByMembershipId = `-- name: GetMembershipByMembershipId :one
SELECT id, deleted, version, created_at, last_updated, token_id, name, asset_url, owners FROM membership WHERE id = $1 AND deleted = false
`

func (q *Queries) GetMembershipByMembershipId(ctx context.Context, id persist.DBID) (Membership, error) {
	row := q.db.QueryRow(ctx, getMembershipByMembershipId, id)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.TokenID,
		&i.Name,
		&i.AssetUrl,
		&i.Owners,
	)
	return i, err
}

const getMentionByID = `-- name: GetMentionByID :one
select id, post_id, comment_id, user_id, start, length, created_at, deleted, community_id from mentions where id = $1 and not deleted
`

func (q *Queries) GetMentionByID(ctx context.Context, id persist.DBID) (Mention, error) {
	row := q.db.QueryRow(ctx, getMentionByID, id)
	var i Mention
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.CommentID,
		&i.UserID,
		&i.Start,
		&i.Length,
		&i.CreatedAt,
		&i.Deleted,
		&i.CommunityID,
	)
	return i, err
}

const getMerchDiscountCodeByTokenID = `-- name: GetMerchDiscountCodeByTokenID :one
select discount_code from merch where token_id = $1 and redeemed = true and deleted = false
`

func (q *Queries) GetMerchDiscountCodeByTokenID(ctx context.Context, tokenHex persist.HexTokenID) (sql.NullString, error) {
	row := q.db.QueryRow(ctx, getMerchDiscountCodeByTokenID, tokenHex)
	var discount_code sql.NullString
	err := row.Scan(&discount_code)
	return discount_code, err
}

const getMostActiveUsers = `-- name: GetMostActiveUsers :many
WITH ag AS (
    SELECT actor_id, COUNT(*) AS admire_given
    FROM admires
    WHERE created_at >= NOW() - INTERVAL '7 days' AND deleted = false
    GROUP BY actor_id
),
ar AS (
    SELECT p.actor_id, COUNT(*) AS admire_received
    FROM posts p
    JOIN admires a ON p.id = a.post_id
    WHERE a.created_at >= NOW() - INTERVAL '7 days' AND a.deleted = false
    GROUP BY p.actor_id
),
cm AS (
    SELECT actor_id, COUNT(id) AS comments_made
    FROM comments
    WHERE created_at >= NOW() - INTERVAL '7 days' AND deleted = false and removed = false
    GROUP BY actor_id
),
cr AS (
    SELECT p.actor_id, COUNT(c.id) AS comments_received
    FROM posts p
    JOIN comments c ON p.id = c.post_id
    WHERE p.created_at >= NOW() - INTERVAL '7 days' AND c.deleted = false and c.removed = false
    GROUP BY p.actor_id
),
scores AS (
    SELECT 
        ((COALESCE(ar.admire_received, 0) * $2::int) + 
        (COALESCE(ag.admire_given, 0) * $3::int) + 
        (COALESCE(cm.comments_made, 0) * $4::int) + 
        (COALESCE(cr.comments_received, 0) * $5::int)) AS score,
        COALESCE(nullif(ag.actor_id,''), nullif(ar.actor_id,''), nullif(cm.actor_id,''), nullif(cr.actor_id,'')) AS actor_id,
        COALESCE(ag.admire_given, 0) AS admires_given,
        COALESCE(ar.admire_received, 0) AS admires_received,
        COALESCE(cm.comments_made, 0) AS comments_made,
        COALESCE(cr.comments_received, 0) AS comments_received
    FROM ag
    FULL OUTER JOIN ar using(actor_id)
    FULL OUTER JOIN cm using(actor_id)
    FULL OUTER JOIN cr using(actor_id)
)
SELECT scores.score, scores.actor_id, scores.admires_given, scores.admires_received, scores.comments_made, scores.comments_received, users.traits
FROM scores
join users on scores.actor_id = users.id
WHERE users.deleted = false AND users.universal = false
AND scores.actor_id IS NOT NULL AND scores.score > 0
ORDER BY scores.score DESC
LIMIT $1
`

type GetMostActiveUsersParams struct {
	Limit                  int32 `db:"limit" json:"limit"`
	AdmireReceivedWeight   int32 `db:"admire_received_weight" json:"admire_received_weight"`
	AdmireGivenWeight      int32 `db:"admire_given_weight" json:"admire_given_weight"`
	CommentsMadeWeight     int32 `db:"comments_made_weight" json:"comments_made_weight"`
	CommentsReceivedWeight int32 `db:"comments_received_weight" json:"comments_received_weight"`
}

type GetMostActiveUsersRow struct {
	Score            int32        `db:"score" json:"score"`
	ActorID          persist.DBID `db:"actor_id" json:"actor_id"`
	AdmiresGiven     int64        `db:"admires_given" json:"admires_given"`
	AdmiresReceived  int64        `db:"admires_received" json:"admires_received"`
	CommentsMade     int64        `db:"comments_made" json:"comments_made"`
	CommentsReceived int64        `db:"comments_received" json:"comments_received"`
	Traits           pgtype.JSONB `db:"traits" json:"traits"`
}

func (q *Queries) GetMostActiveUsers(ctx context.Context, arg GetMostActiveUsersParams) ([]GetMostActiveUsersRow, error) {
	rows, err := q.db.Query(ctx, getMostActiveUsers,
		arg.Limit,
		arg.AdmireReceivedWeight,
		arg.AdmireGivenWeight,
		arg.CommentsMadeWeight,
		arg.CommentsReceivedWeight,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostActiveUsersRow
	for rows.Next() {
		var i GetMostActiveUsersRow
		if err := rows.Scan(
			&i.Score,
			&i.ActorID,
			&i.AdmiresGiven,
			&i.AdmiresReceived,
			&i.CommentsMade,
			&i.CommentsReceived,
			&i.Traits,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRecentNotificationByOwnerIDForAction = `-- name: GetMostRecentNotificationByOwnerIDForAction :one
select id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id from notifications
    where owner_id = $1
    and action = $2
    and deleted = false
    and (not $6::bool or feed_event_id = $3)
    and (not $7::bool or post_id = $4)
    and (not $8::bool or comment_id = $5)
    order by created_at desc
    limit 1
`

type GetMostRecentNotificationByOwnerIDForActionParams struct {
	OwnerID          persist.DBID   `db:"owner_id" json:"owner_id"`
	Action           persist.Action `db:"action" json:"action"`
	FeedEventID      persist.DBID   `db:"feed_event_id" json:"feed_event_id"`
	PostID           persist.DBID   `db:"post_id" json:"post_id"`
	CommentID        persist.DBID   `db:"comment_id" json:"comment_id"`
	OnlyForFeedEvent bool           `db:"only_for_feed_event" json:"only_for_feed_event"`
	OnlyForPost      bool           `db:"only_for_post" json:"only_for_post"`
	OnlyForComment   bool           `db:"only_for_comment" json:"only_for_comment"`
}

func (q *Queries) GetMostRecentNotificationByOwnerIDForAction(ctx context.Context, arg GetMostRecentNotificationByOwnerIDForActionParams) (Notification, error) {
	row := q.db.QueryRow(ctx, getMostRecentNotificationByOwnerIDForAction,
		arg.OwnerID,
		arg.Action,
		arg.FeedEventID,
		arg.PostID,
		arg.CommentID,
		arg.OnlyForFeedEvent,
		arg.OnlyForPost,
		arg.OnlyForComment,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const getMostRecentNotificationByOwnerIDTokenIDForAction = `-- name: GetMostRecentNotificationByOwnerIDTokenIDForAction :one
select id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id from notifications
    where owner_id = $1
    and token_id = $2
    and action = $3
    and deleted = false
    and (not $6::bool or feed_event_id = $4)
    and (not $7::bool or post_id = $5)
    order by created_at desc
    limit 1
`

type GetMostRecentNotificationByOwnerIDTokenIDForActionParams struct {
	OwnerID          persist.DBID   `db:"owner_id" json:"owner_id"`
	TokenID          persist.DBID   `db:"token_id" json:"token_id"`
	Action           persist.Action `db:"action" json:"action"`
	FeedEventID      persist.DBID   `db:"feed_event_id" json:"feed_event_id"`
	PostID           persist.DBID   `db:"post_id" json:"post_id"`
	OnlyForFeedEvent bool           `db:"only_for_feed_event" json:"only_for_feed_event"`
	OnlyForPost      bool           `db:"only_for_post" json:"only_for_post"`
}

func (q *Queries) GetMostRecentNotificationByOwnerIDTokenIDForAction(ctx context.Context, arg GetMostRecentNotificationByOwnerIDTokenIDForActionParams) (Notification, error) {
	row := q.db.QueryRow(ctx, getMostRecentNotificationByOwnerIDTokenIDForAction,
		arg.OwnerID,
		arg.TokenID,
		arg.Action,
		arg.FeedEventID,
		arg.PostID,
		arg.OnlyForFeedEvent,
		arg.OnlyForPost,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id FROM notifications WHERE id = $1 AND deleted = false
`

func (q *Queries) GetNotificationByID(ctx context.Context, id persist.DBID) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.FeedEventID,
		&i.CommentID,
		&i.GalleryID,
		&i.Seen,
		&i.Amount,
		&i.PostID,
		&i.TokenID,
		&i.MentionID,
		&i.CommunityID,
	)
	return i, err
}

const getNotificationsByOwnerIDForActionAfter = `-- name: GetNotificationsByOwnerIDForActionAfter :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id FROM notifications
    WHERE owner_id = $1 AND action = $2 AND deleted = false AND created_at > $3
    ORDER BY created_at DESC
`

type GetNotificationsByOwnerIDForActionAfterParams struct {
	OwnerID      persist.DBID   `db:"owner_id" json:"owner_id"`
	Action       persist.Action `db:"action" json:"action"`
	CreatedAfter time.Time      `db:"created_after" json:"created_after"`
}

func (q *Queries) GetNotificationsByOwnerIDForActionAfter(ctx context.Context, arg GetNotificationsByOwnerIDForActionAfterParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByOwnerIDForActionAfter, arg.OwnerID, arg.Action, arg.CreatedAfter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
			&i.PostID,
			&i.TokenID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOnboardingUserRecommendations = `-- name: GetOnboardingUserRecommendations :many
with sources as (
    select id from users where (traits->>'top_activity')::bool
    union all select recommended_user_id from top_recommended_users
    union all select user_id from user_internal_recommendations
), top_recs as (select sources.id from sources group by sources.id order by count(id) desc, random())
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_gallery, users.primary_wallet_id, users.user_experiences, users.profile_image_id, users.persona from users join top_recs using(id) where not users.deleted and not users.universal limit $1
`

func (q *Queries) GetOnboardingUserRecommendations(ctx context.Context, limit int32) ([]User, error) {
	rows, err := q.db.Query(ctx, getOnboardingUserRecommendations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByID = `-- name: GetPostByID :one
SELECT id, version, token_ids, contract_ids, actor_id, caption, created_at, last_updated, deleted, is_first_post, user_mint_url FROM posts WHERE id = $1 AND deleted = false
`

func (q *Queries) GetPostByID(ctx context.Context, id persist.DBID) (Post, error) {
	row := q.db.QueryRow(ctx, getPostByID, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.TokenIds,
		&i.ContractIds,
		&i.ActorID,
		&i.Caption,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.IsFirstPost,
		&i.UserMintUrl,
	)
	return i, err
}

const getPotentialENSProfileImageByUserId = `-- name: GetPotentialENSProfileImageByUserId :one
select token_definitions.id, token_definitions.created_at, token_definitions.last_updated, token_definitions.deleted, token_definitions.name, token_definitions.description, token_definitions.token_type, token_definitions.token_id, token_definitions.external_url, token_definitions.chain, token_definitions.metadata, token_definitions.fallback_media, token_definitions.contract_address, token_definitions.contract_id, token_definitions.token_media_id, token_definitions.is_fxhash, token_medias.id, token_medias.created_at, token_medias.last_updated, token_medias.version, token_medias.active, token_medias.media, token_medias.processing_job_id, token_medias.deleted, wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type, wallets.chain, wallets.l1_chain
from token_definitions, tokens, users, token_medias, wallets, unnest(tokens.owned_by_wallets) tw(id)
where token_definitions.contract_address = $1
    and token_definitions.chain = $2
    and tokens.owner_user_id = $3
    and users.id = tokens.owner_user_id
    and tw.id = wallets.id
    and token_definitions.id = tokens.token_definition_id
    and token_definitions.token_media_id = token_medias.id
    and token_medias.active
    and nullif(token_medias.media->>'profile_image_url', '') is not null
    and not users.deleted
    and not token_medias.deleted
    and not wallets.deleted
    and not token_definitions.deleted
    and not tokens.deleted
order by tw.id = users.primary_wallet_id desc, tokens.id desc
limit 1
`

type GetPotentialENSProfileImageByUserIdParams struct {
	EnsAddress persist.Address `db:"ens_address" json:"ens_address"`
	Chain      persist.Chain   `db:"chain" json:"chain"`
	UserID     persist.DBID    `db:"user_id" json:"user_id"`
}

type GetPotentialENSProfileImageByUserIdRow struct {
	TokenDefinition TokenDefinition `db:"tokendefinition" json:"tokendefinition"`
	TokenMedia      TokenMedia      `db:"tokenmedia" json:"tokenmedia"`
	Wallet          Wallet          `db:"wallet" json:"wallet"`
}

func (q *Queries) GetPotentialENSProfileImageByUserId(ctx context.Context, arg GetPotentialENSProfileImageByUserIdParams) (GetPotentialENSProfileImageByUserIdRow, error) {
	row := q.db.QueryRow(ctx, getPotentialENSProfileImageByUserId, arg.EnsAddress, arg.Chain, arg.UserID)
	var i GetPotentialENSProfileImageByUserIdRow
	err := row.Scan(
		&i.TokenDefinition.ID,
		&i.TokenDefinition.CreatedAt,
		&i.TokenDefinition.LastUpdated,
		&i.TokenDefinition.Deleted,
		&i.TokenDefinition.Name,
		&i.TokenDefinition.Description,
		&i.TokenDefinition.TokenType,
		&i.TokenDefinition.TokenID,
		&i.TokenDefinition.ExternalUrl,
		&i.TokenDefinition.Chain,
		&i.TokenDefinition.Metadata,
		&i.TokenDefinition.FallbackMedia,
		&i.TokenDefinition.ContractAddress,
		&i.TokenDefinition.ContractID,
		&i.TokenDefinition.TokenMediaID,
		&i.TokenDefinition.IsFxhash,
		&i.TokenMedia.ID,
		&i.TokenMedia.CreatedAt,
		&i.TokenMedia.LastUpdated,
		&i.TokenMedia.Version,
		&i.TokenMedia.Active,
		&i.TokenMedia.Media,
		&i.TokenMedia.ProcessingJobID,
		&i.TokenMedia.Deleted,
		&i.Wallet.ID,
		&i.Wallet.CreatedAt,
		&i.Wallet.LastUpdated,
		&i.Wallet.Deleted,
		&i.Wallet.Version,
		&i.Wallet.Address,
		&i.Wallet.WalletType,
		&i.Wallet.Chain,
		&i.Wallet.L1Chain,
	)
	return i, err
}

const getPreviewURLsByContractIdAndUserId = `-- name: GetPreviewURLsByContractIdAndUserId :many
select coalesce(nullif(tm.media->>'thumbnail_url', ''), nullif(tm.media->>'media_url', ''))::varchar as thumbnail_url
from tokens t
join token_definitions td on t.token_definition_id = td.id
join token_medias tm on td.token_media_id = tm.id
where t.owner_user_id = $1
	and t.contract_id = $2
	and t.displayable
	and (tm.media ->> 'thumbnail_url' != '' or tm.media->>'media_type' = 'image')
	and not t.deleted
	and not td.deleted
	and not tm.deleted
	and tm.active
order by t.id limit 3
`

type GetPreviewURLsByContractIdAndUserIdParams struct {
	OwnerID    persist.DBID `db:"owner_id" json:"owner_id"`
	ContractID persist.DBID `db:"contract_id" json:"contract_id"`
}

func (q *Queries) GetPreviewURLsByContractIdAndUserId(ctx context.Context, arg GetPreviewURLsByContractIdAndUserIdParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getPreviewURLsByContractIdAndUserId, arg.OwnerID, arg.ContractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var thumbnail_url string
		if err := rows.Scan(&thumbnail_url); err != nil {
			return nil, err
		}
		items = append(items, thumbnail_url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPushTokenByPushToken = `-- name: GetPushTokenByPushToken :one
select id, user_id, push_token, created_at, deleted from push_notification_tokens where push_token = $1 and deleted = false
`

func (q *Queries) GetPushTokenByPushToken(ctx context.Context, pushToken string) (PushNotificationToken, error) {
	row := q.db.QueryRow(ctx, getPushTokenByPushToken, pushToken)
	var i PushNotificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PushToken,
		&i.CreatedAt,
		&i.Deleted,
	)
	return i, err
}

const getPushTokensByIDs = `-- name: GetPushTokensByIDs :many
with keys as (
    select unnest ($1::text[]) as id
         , generate_subscripts($1::text[], 1) as index
)
select t.id, t.user_id, t.push_token, t.created_at, t.deleted from keys k join push_notification_tokens t on t.id = k.id and t.deleted = false
    order by k.index
`

func (q *Queries) GetPushTokensByIDs(ctx context.Context, ids []string) ([]PushNotificationToken, error) {
	rows, err := q.db.Query(ctx, getPushTokensByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PushNotificationToken
	for rows.Next() {
		var i PushNotificationToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PushToken,
			&i.CreatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPushTokensByUserID = `-- name: GetPushTokensByUserID :many
select id, user_id, push_token, created_at, deleted from push_notification_tokens where user_id = $1 and deleted = false
`

func (q *Queries) GetPushTokensByUserID(ctx context.Context, userID persist.DBID) ([]PushNotificationToken, error) {
	rows, err := q.db.Query(ctx, getPushTokensByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PushNotificationToken
	for rows.Next() {
		var i PushNotificationToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PushToken,
			&i.CreatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentUnseenNotifications = `-- name: GetRecentUnseenNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false and created_at > $2 order by created_at desc limit $3
`

type GetRecentUnseenNotificationsParams struct {
	OwnerID      persist.DBID `db:"owner_id" json:"owner_id"`
	CreatedAfter time.Time    `db:"created_after" json:"created_after"`
	Lim          int32        `db:"lim" json:"lim"`
}

func (q *Queries) GetRecentUnseenNotifications(ctx context.Context, arg GetRecentUnseenNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getRecentUnseenNotifications, arg.OwnerID, arg.CreatedAfter, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
			&i.PostID,
			&i.TokenID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReprocessJobRangeByID = `-- name: GetReprocessJobRangeByID :one
select id, token_start_id, token_end_id from reprocess_jobs where id = $1
`

func (q *Queries) GetReprocessJobRangeByID(ctx context.Context, id int) (ReprocessJob, error) {
	row := q.db.QueryRow(ctx, getReprocessJobRangeByID, id)
	var i ReprocessJob
	err := row.Scan(&i.ID, &i.TokenStartID, &i.TokenEndID)
	return i, err
}

const getSVGTokensWithContractsByIDs = `-- name: GetSVGTokensWithContractsByIDs :many
SELECT
    tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.collectors_note, tokens.quantity, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.contract_id, tokens.is_user_marked_spam, tokens.last_synced, tokens.is_creator_token, tokens.token_definition_id, tokens.is_holder_token, tokens.displayable,
    contracts.id, contracts.deleted, contracts.version, contracts.created_at, contracts.last_updated, contracts.name, contracts.symbol, contracts.address, contracts.creator_address, contracts.chain, contracts.profile_banner_url, contracts.profile_image_url, contracts.badge_url, contracts.description, contracts.owner_address, contracts.is_provider_marked_spam, contracts.parent_id, contracts.override_creator_user_id, contracts.l1_chain,
    (
        SELECT wallets.address
        FROM wallets
        WHERE wallets.id = ANY(tokens.owned_by_wallets) and wallets.deleted = false
        LIMIT 1
    ) AS wallet_address
FROM tokens
JOIN contracts ON contracts.id = tokens.contract_id
LEFT JOIN token_medias on token_medias.id = tokens.token_media_id
WHERE tokens.deleted = false
AND token_medias.active = true
AND token_medias.media->>'media_type' = 'svg'
AND tokens.id >= $1 AND tokens.id < $2
ORDER BY tokens.id
`

type GetSVGTokensWithContractsByIDsParams struct {
	StartID persist.DBID `db:"start_id" json:"start_id"`
	EndID   persist.DBID `db:"end_id" json:"end_id"`
}

type GetSVGTokensWithContractsByIDsRow struct {
	ID                    persist.DBID      `db:"id" json:"id"`
	Deleted               bool              `db:"deleted" json:"deleted"`
	Version               sql.NullInt32     `db:"version" json:"version"`
	CreatedAt             time.Time         `db:"created_at" json:"created_at"`
	LastUpdated           time.Time         `db:"last_updated" json:"last_updated"`
	CollectorsNote        sql.NullString    `db:"collectors_note" json:"collectors_note"`
	Quantity              persist.HexString `db:"quantity" json:"quantity"`
	BlockNumber           sql.NullInt64     `db:"block_number" json:"block_number"`
	OwnerUserID           persist.DBID      `db:"owner_user_id" json:"owner_user_id"`
	OwnedByWallets        persist.DBIDList  `db:"owned_by_wallets" json:"owned_by_wallets"`
	ContractID            persist.DBID      `db:"contract_id" json:"contract_id"`
	IsUserMarkedSpam      sql.NullBool      `db:"is_user_marked_spam" json:"is_user_marked_spam"`
	LastSynced            time.Time         `db:"last_synced" json:"last_synced"`
	IsCreatorToken        bool              `db:"is_creator_token" json:"is_creator_token"`
	TokenDefinitionID     persist.DBID      `db:"token_definition_id" json:"token_definition_id"`
	IsHolderToken         bool              `db:"is_holder_token" json:"is_holder_token"`
	Displayable           bool              `db:"displayable" json:"displayable"`
	ID_2                  persist.DBID      `db:"id_2" json:"id_2"`
	Deleted_2             bool              `db:"deleted_2" json:"deleted_2"`
	Version_2             sql.NullInt32     `db:"version_2" json:"version_2"`
	CreatedAt_2           time.Time         `db:"created_at_2" json:"created_at_2"`
	LastUpdated_2         time.Time         `db:"last_updated_2" json:"last_updated_2"`
	Name                  sql.NullString    `db:"name" json:"name"`
	Symbol                sql.NullString    `db:"symbol" json:"symbol"`
	Address               persist.Address   `db:"address" json:"address"`
	CreatorAddress        persist.Address   `db:"creator_address" json:"creator_address"`
	Chain                 persist.Chain     `db:"chain" json:"chain"`
	ProfileBannerUrl      sql.NullString    `db:"profile_banner_url" json:"profile_banner_url"`
	ProfileImageUrl       sql.NullString    `db:"profile_image_url" json:"profile_image_url"`
	BadgeUrl              sql.NullString    `db:"badge_url" json:"badge_url"`
	Description           sql.NullString    `db:"description" json:"description"`
	OwnerAddress          persist.Address   `db:"owner_address" json:"owner_address"`
	IsProviderMarkedSpam  bool              `db:"is_provider_marked_spam" json:"is_provider_marked_spam"`
	ParentID              persist.DBID      `db:"parent_id" json:"parent_id"`
	OverrideCreatorUserID persist.DBID      `db:"override_creator_user_id" json:"override_creator_user_id"`
	L1Chain               persist.L1Chain   `db:"l1_chain" json:"l1_chain"`
	WalletAddress         persist.Address   `db:"wallet_address" json:"wallet_address"`
}

func (q *Queries) GetSVGTokensWithContractsByIDs(ctx context.Context, arg GetSVGTokensWithContractsByIDsParams) ([]GetSVGTokensWithContractsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getSVGTokensWithContractsByIDs, arg.StartID, arg.EndID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSVGTokensWithContractsByIDsRow
	for rows.Next() {
		var i GetSVGTokensWithContractsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.CollectorsNote,
			&i.Quantity,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.ContractID,
			&i.IsUserMarkedSpam,
			&i.LastSynced,
			&i.IsCreatorToken,
			&i.TokenDefinitionID,
			&i.IsHolderToken,
			&i.Displayable,
			&i.ID_2,
			&i.Deleted_2,
			&i.Version_2,
			&i.CreatedAt_2,
			&i.LastUpdated_2,
			&i.Name,
			&i.Symbol,
			&i.Address,
			&i.CreatorAddress,
			&i.Chain,
			&i.ProfileBannerUrl,
			&i.ProfileImageUrl,
			&i.BadgeUrl,
			&i.Description,
			&i.OwnerAddress,
			&i.IsProviderMarkedSpam,
			&i.ParentID,
			&i.OverrideCreatorUserID,
			&i.L1Chain,
			&i.WalletAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSocialAuthByUserID = `-- name: GetSocialAuthByUserID :one
select id, deleted, version, created_at, last_updated, user_id, provider, access_token, refresh_token from pii.socials_auth where user_id = $1 and provider = $2 and deleted = false
`

type GetSocialAuthByUserIDParams struct {
	UserID   persist.DBID           `db:"user_id" json:"user_id"`
	Provider persist.SocialProvider `db:"provider" json:"provider"`
}

func (q *Queries) GetSocialAuthByUserID(ctx context.Context, arg GetSocialAuthByUserIDParams) (PiiSocialsAuth, error) {
	row := q.db.QueryRow(ctx, getSocialAuthByUserID, arg.UserID, arg.Provider)
	var i PiiSocialsAuth
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.UserID,
		&i.Provider,
		&i.AccessToken,
		&i.RefreshToken,
	)
	return i, err
}

const getSocialConnections = `-- name: GetSocialConnections :many
select s.social_id, s.social_username, s.social_displayname, s.social_profile_image, user_view.id as user_id, user_view.created_at as user_created_at, (f.id is not null)::bool as already_following
from (select unnest($1::varchar[]) as social_id, unnest($2::varchar[]) as social_username, unnest($3::varchar[]) as social_displayname, unnest($4::varchar[]) as social_profile_image) as s
    inner join pii.user_view on user_view.pii_socials->$5::text->>'id'::varchar = s.social_id and user_view.deleted = false
    left outer join follows f on f.follower = $6 and f.followee = user_view.id and f.deleted = false
where case when $7::bool then f.id is null else true end
order by (f.id is not null,user_view.created_at,user_view.id)
`

type GetSocialConnectionsParams struct {
	SocialIds           []string     `db:"social_ids" json:"social_ids"`
	SocialUsernames     []string     `db:"social_usernames" json:"social_usernames"`
	SocialDisplaynames  []string     `db:"social_displaynames" json:"social_displaynames"`
	SocialProfileImages []string     `db:"social_profile_images" json:"social_profile_images"`
	Social              string       `db:"social" json:"social"`
	UserID              persist.DBID `db:"user_id" json:"user_id"`
	OnlyUnfollowing     bool         `db:"only_unfollowing" json:"only_unfollowing"`
}

type GetSocialConnectionsRow struct {
	SocialID           interface{}  `db:"social_id" json:"social_id"`
	SocialUsername     interface{}  `db:"social_username" json:"social_username"`
	SocialDisplayname  interface{}  `db:"social_displayname" json:"social_displayname"`
	SocialProfileImage interface{}  `db:"social_profile_image" json:"social_profile_image"`
	UserID             persist.DBID `db:"user_id" json:"user_id"`
	UserCreatedAt      time.Time    `db:"user_created_at" json:"user_created_at"`
	AlreadyFollowing   bool         `db:"already_following" json:"already_following"`
}

func (q *Queries) GetSocialConnections(ctx context.Context, arg GetSocialConnectionsParams) ([]GetSocialConnectionsRow, error) {
	rows, err := q.db.Query(ctx, getSocialConnections,
		arg.SocialIds,
		arg.SocialUsernames,
		arg.SocialDisplaynames,
		arg.SocialProfileImages,
		arg.Social,
		arg.UserID,
		arg.OnlyUnfollowing,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSocialConnectionsRow
	for rows.Next() {
		var i GetSocialConnectionsRow
		if err := rows.Scan(
			&i.SocialID,
			&i.SocialUsername,
			&i.SocialDisplayname,
			&i.SocialProfileImage,
			&i.UserID,
			&i.UserCreatedAt,
			&i.AlreadyFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSocialConnectionsPaginate = `-- name: GetSocialConnectionsPaginate :many
select s.social_id, s.social_username, s.social_displayname, s.social_profile_image, user_view.id as user_id, user_view.created_at as user_created_at, (f.id is not null)::bool as already_following
from (select unnest($2::varchar[]) as social_id, unnest($3::varchar[]) as social_username, unnest($4::varchar[]) as social_displayname, unnest($5::varchar[]) as social_profile_image) as s
    inner join pii.user_view on user_view.pii_socials->$6::text->>'id'::varchar = s.social_id and user_view.deleted = false
    left outer join follows f on f.follower = $7 and f.followee = user_view.id and f.deleted = false
where case when $8::bool then f.id is null else true end
    and (f.id is not null,user_view.created_at,user_view.id) < ($9::bool, $10::timestamptz, $11)
    and (f.id is not null,user_view.created_at,user_view.id) > ($12::bool, $13::timestamptz, $14)
order by case when $15::bool then (f.id is not null,user_view.created_at,user_view.id) end asc,
    case when not $15::bool then (f.id is not null,user_view.created_at,user_view.id) end desc
limit $1
`

type GetSocialConnectionsPaginateParams struct {
	Limit               int32        `db:"limit" json:"limit"`
	SocialIds           []string     `db:"social_ids" json:"social_ids"`
	SocialUsernames     []string     `db:"social_usernames" json:"social_usernames"`
	SocialDisplaynames  []string     `db:"social_displaynames" json:"social_displaynames"`
	SocialProfileImages []string     `db:"social_profile_images" json:"social_profile_images"`
	Social              string       `db:"social" json:"social"`
	UserID              persist.DBID `db:"user_id" json:"user_id"`
	OnlyUnfollowing     bool         `db:"only_unfollowing" json:"only_unfollowing"`
	CurBeforeFollowing  bool         `db:"cur_before_following" json:"cur_before_following"`
	CurBeforeTime       time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID         persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterFollowing   bool         `db:"cur_after_following" json:"cur_after_following"`
	CurAfterTime        time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID          persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward       bool         `db:"paging_forward" json:"paging_forward"`
}

type GetSocialConnectionsPaginateRow struct {
	SocialID           interface{}  `db:"social_id" json:"social_id"`
	SocialUsername     interface{}  `db:"social_username" json:"social_username"`
	SocialDisplayname  interface{}  `db:"social_displayname" json:"social_displayname"`
	SocialProfileImage interface{}  `db:"social_profile_image" json:"social_profile_image"`
	UserID             persist.DBID `db:"user_id" json:"user_id"`
	UserCreatedAt      time.Time    `db:"user_created_at" json:"user_created_at"`
	AlreadyFollowing   bool         `db:"already_following" json:"already_following"`
}

// this query will take in enoug info to create a sort of fake table of social accounts matching them up to users in gallery with twitter connected.
// it will also go and search for whether the specified user follows any of the users returned
func (q *Queries) GetSocialConnectionsPaginate(ctx context.Context, arg GetSocialConnectionsPaginateParams) ([]GetSocialConnectionsPaginateRow, error) {
	rows, err := q.db.Query(ctx, getSocialConnectionsPaginate,
		arg.Limit,
		arg.SocialIds,
		arg.SocialUsernames,
		arg.SocialDisplaynames,
		arg.SocialProfileImages,
		arg.Social,
		arg.UserID,
		arg.OnlyUnfollowing,
		arg.CurBeforeFollowing,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterFollowing,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSocialConnectionsPaginateRow
	for rows.Next() {
		var i GetSocialConnectionsPaginateRow
		if err := rows.Scan(
			&i.SocialID,
			&i.SocialUsername,
			&i.SocialDisplayname,
			&i.SocialProfileImage,
			&i.UserID,
			&i.UserCreatedAt,
			&i.AlreadyFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSocialsByUserID = `-- name: GetSocialsByUserID :one
select pii_socials from pii.user_view where id = $1
`

func (q *Queries) GetSocialsByUserID(ctx context.Context, id persist.DBID) (persist.Socials, error) {
	row := q.db.QueryRow(ctx, getSocialsByUserID, id)
	var pii_socials persist.Socials
	err := row.Scan(&pii_socials)
	return pii_socials, err
}

const getTokenById = `-- name: GetTokenById :one
select t.id, t.deleted, t.version, t.created_at, t.last_updated, t.collectors_note, t.quantity, t.block_number, t.owner_user_id, t.owned_by_wallets, t.contract_id, t.is_user_marked_spam, t.last_synced, t.is_creator_token, t.token_definition_id, t.is_holder_token, t.displayable, td.id, td.created_at, td.last_updated, td.deleted, td.name, td.description, td.token_type, td.token_id, td.external_url, td.chain, td.metadata, td.fallback_media, td.contract_address, td.contract_id, td.token_media_id, td.is_fxhash
from tokens t
join token_definitions td on t.token_definition_id = td.id
where t.id = $1 and t.displayable and t.deleted = false and td.deleted = false
`

type GetTokenByIdRow struct {
	Token           Token           `db:"token" json:"token"`
	TokenDefinition TokenDefinition `db:"tokendefinition" json:"tokendefinition"`
}

func (q *Queries) GetTokenById(ctx context.Context, id persist.DBID) (GetTokenByIdRow, error) {
	row := q.db.QueryRow(ctx, getTokenById, id)
	var i GetTokenByIdRow
	err := row.Scan(
		&i.Token.ID,
		&i.Token.Deleted,
		&i.Token.Version,
		&i.Token.CreatedAt,
		&i.Token.LastUpdated,
		&i.Token.CollectorsNote,
		&i.Token.Quantity,
		&i.Token.BlockNumber,
		&i.Token.OwnerUserID,
		&i.Token.OwnedByWallets,
		&i.Token.ContractID,
		&i.Token.IsUserMarkedSpam,
		&i.Token.LastSynced,
		&i.Token.IsCreatorToken,
		&i.Token.TokenDefinitionID,
		&i.Token.IsHolderToken,
		&i.Token.Displayable,
		&i.TokenDefinition.ID,
		&i.TokenDefinition.CreatedAt,
		&i.TokenDefinition.LastUpdated,
		&i.TokenDefinition.Deleted,
		&i.TokenDefinition.Name,
		&i.TokenDefinition.Description,
		&i.TokenDefinition.TokenType,
		&i.TokenDefinition.TokenID,
		&i.TokenDefinition.ExternalUrl,
		&i.TokenDefinition.Chain,
		&i.TokenDefinition.Metadata,
		&i.TokenDefinition.FallbackMedia,
		&i.TokenDefinition.ContractAddress,
		&i.TokenDefinition.ContractID,
		&i.TokenDefinition.TokenMediaID,
		&i.TokenDefinition.IsFxhash,
	)
	return i, err
}

const getTokenByUserTokenIdentifiers = `-- name: GetTokenByUserTokenIdentifiers :one
select t.id, t.deleted, t.version, t.created_at, t.last_updated, t.collectors_note, t.quantity, t.block_number, t.owner_user_id, t.owned_by_wallets, t.contract_id, t.is_user_marked_spam, t.last_synced, t.is_creator_token, t.token_definition_id, t.is_holder_token, t.displayable, td.id, td.created_at, td.last_updated, td.deleted, td.name, td.description, td.token_type, td.token_id, td.external_url, td.chain, td.metadata, td.fallback_media, td.contract_address, td.contract_id, td.token_media_id, td.is_fxhash, c.id, c.deleted, c.version, c.created_at, c.last_updated, c.name, c.symbol, c.address, c.creator_address, c.chain, c.profile_banner_url, c.profile_image_url, c.badge_url, c.description, c.owner_address, c.is_provider_marked_spam, c.parent_id, c.override_creator_user_id, c.l1_chain
from tokens t, token_definitions td, contracts c
where t.token_definition_id = td.id
    and td.contract_id = c.id
    and t.owner_user_id = $1
    and td.token_id = $2
    and td.chain = $3
    and td.contract_address = $4
    and t.displayable
    and not t.deleted
    and not td.deleted
    and not c.deleted
`

type GetTokenByUserTokenIdentifiersParams struct {
	OwnerID         persist.DBID       `db:"owner_id" json:"owner_id"`
	TokenID         persist.HexTokenID `db:"token_id" json:"token_id"`
	Chain           persist.Chain      `db:"chain" json:"chain"`
	ContractAddress persist.Address    `db:"contract_address" json:"contract_address"`
}

type GetTokenByUserTokenIdentifiersRow struct {
	Token           Token           `db:"token" json:"token"`
	TokenDefinition TokenDefinition `db:"tokendefinition" json:"tokendefinition"`
	Contract        Contract        `db:"contract" json:"contract"`
}

func (q *Queries) GetTokenByUserTokenIdentifiers(ctx context.Context, arg GetTokenByUserTokenIdentifiersParams) (GetTokenByUserTokenIdentifiersRow, error) {
	row := q.db.QueryRow(ctx, getTokenByUserTokenIdentifiers,
		arg.OwnerID,
		arg.TokenID,
		arg.Chain,
		arg.ContractAddress,
	)
	var i GetTokenByUserTokenIdentifiersRow
	err := row.Scan(
		&i.Token.ID,
		&i.Token.Deleted,
		&i.Token.Version,
		&i.Token.CreatedAt,
		&i.Token.LastUpdated,
		&i.Token.CollectorsNote,
		&i.Token.Quantity,
		&i.Token.BlockNumber,
		&i.Token.OwnerUserID,
		&i.Token.OwnedByWallets,
		&i.Token.ContractID,
		&i.Token.IsUserMarkedSpam,
		&i.Token.LastSynced,
		&i.Token.IsCreatorToken,
		&i.Token.TokenDefinitionID,
		&i.Token.IsHolderToken,
		&i.Token.Displayable,
		&i.TokenDefinition.ID,
		&i.TokenDefinition.CreatedAt,
		&i.TokenDefinition.LastUpdated,
		&i.TokenDefinition.Deleted,
		&i.TokenDefinition.Name,
		&i.TokenDefinition.Description,
		&i.TokenDefinition.TokenType,
		&i.TokenDefinition.TokenID,
		&i.TokenDefinition.ExternalUrl,
		&i.TokenDefinition.Chain,
		&i.TokenDefinition.Metadata,
		&i.TokenDefinition.FallbackMedia,
		&i.TokenDefinition.ContractAddress,
		&i.TokenDefinition.ContractID,
		&i.TokenDefinition.TokenMediaID,
		&i.TokenDefinition.IsFxhash,
		&i.Contract.ID,
		&i.Contract.Deleted,
		&i.Contract.Version,
		&i.Contract.CreatedAt,
		&i.Contract.LastUpdated,
		&i.Contract.Name,
		&i.Contract.Symbol,
		&i.Contract.Address,
		&i.Contract.CreatorAddress,
		&i.Contract.Chain,
		&i.Contract.ProfileBannerUrl,
		&i.Contract.ProfileImageUrl,
		&i.Contract.BadgeUrl,
		&i.Contract.Description,
		&i.Contract.OwnerAddress,
		&i.Contract.IsProviderMarkedSpam,
		&i.Contract.ParentID,
		&i.Contract.OverrideCreatorUserID,
		&i.Contract.L1Chain,
	)
	return i, err
}

const getTokenDefinitionById = `-- name: GetTokenDefinitionById :one
select id, created_at, last_updated, deleted, name, description, token_type, token_id, external_url, chain, metadata, fallback_media, contract_address, contract_id, token_media_id, is_fxhash from token_definitions where id = $1 and not deleted
`

func (q *Queries) GetTokenDefinitionById(ctx context.Context, id persist.DBID) (TokenDefinition, error) {
	row := q.db.QueryRow(ctx, getTokenDefinitionById, id)
	var i TokenDefinition
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Name,
		&i.Description,
		&i.TokenType,
		&i.TokenID,
		&i.ExternalUrl,
		&i.Chain,
		&i.Metadata,
		&i.FallbackMedia,
		&i.ContractAddress,
		&i.ContractID,
		&i.TokenMediaID,
		&i.IsFxhash,
	)
	return i, err
}

const getTokenDefinitionByTokenDbid = `-- name: GetTokenDefinitionByTokenDbid :one
select token_definitions.id, token_definitions.created_at, token_definitions.last_updated, token_definitions.deleted, token_definitions.name, token_definitions.description, token_definitions.token_type, token_definitions.token_id, token_definitions.external_url, token_definitions.chain, token_definitions.metadata, token_definitions.fallback_media, token_definitions.contract_address, token_definitions.contract_id, token_definitions.token_media_id, token_definitions.is_fxhash
from token_definitions, tokens
where token_definitions.id = tokens.token_definition_id
    and tokens.id = $1
    and not tokens.deleted
    and not token_definitions.deleted
`

func (q *Queries) GetTokenDefinitionByTokenDbid(ctx context.Context, id persist.DBID) (TokenDefinition, error) {
	row := q.db.QueryRow(ctx, getTokenDefinitionByTokenDbid, id)
	var i TokenDefinition
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Name,
		&i.Description,
		&i.TokenType,
		&i.TokenID,
		&i.ExternalUrl,
		&i.Chain,
		&i.Metadata,
		&i.FallbackMedia,
		&i.ContractAddress,
		&i.ContractID,
		&i.TokenMediaID,
		&i.IsFxhash,
	)
	return i, err
}

const getTokenDefinitionByTokenIdentifiers = `-- name: GetTokenDefinitionByTokenIdentifiers :one
select id, created_at, last_updated, deleted, name, description, token_type, token_id, external_url, chain, metadata, fallback_media, contract_address, contract_id, token_media_id, is_fxhash
from token_definitions
where (chain, contract_address, token_id) = ($1, $2, $3) and not deleted
`

type GetTokenDefinitionByTokenIdentifiersParams struct {
	Chain           persist.Chain      `db:"chain" json:"chain"`
	ContractAddress persist.Address    `db:"contract_address" json:"contract_address"`
	TokenID         persist.HexTokenID `db:"token_id" json:"token_id"`
}

func (q *Queries) GetTokenDefinitionByTokenIdentifiers(ctx context.Context, arg GetTokenDefinitionByTokenIdentifiersParams) (TokenDefinition, error) {
	row := q.db.QueryRow(ctx, getTokenDefinitionByTokenIdentifiers, arg.Chain, arg.ContractAddress, arg.TokenID)
	var i TokenDefinition
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Name,
		&i.Description,
		&i.TokenType,
		&i.TokenID,
		&i.ExternalUrl,
		&i.Chain,
		&i.Metadata,
		&i.FallbackMedia,
		&i.ContractAddress,
		&i.ContractID,
		&i.TokenMediaID,
		&i.IsFxhash,
	)
	return i, err
}

const getTokenFullDetailsByContractId = `-- name: GetTokenFullDetailsByContractId :many
select tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.collectors_note, tokens.quantity, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.contract_id, tokens.is_user_marked_spam, tokens.last_synced, tokens.is_creator_token, tokens.token_definition_id, tokens.is_holder_token, tokens.displayable, token_definitions.id, token_definitions.created_at, token_definitions.last_updated, token_definitions.deleted, token_definitions.name, token_definitions.description, token_definitions.token_type, token_definitions.token_id, token_definitions.external_url, token_definitions.chain, token_definitions.metadata, token_definitions.fallback_media, token_definitions.contract_address, token_definitions.contract_id, token_definitions.token_media_id, token_definitions.is_fxhash, contracts.id, contracts.deleted, contracts.version, contracts.created_at, contracts.last_updated, contracts.name, contracts.symbol, contracts.address, contracts.creator_address, contracts.chain, contracts.profile_banner_url, contracts.profile_image_url, contracts.badge_url, contracts.description, contracts.owner_address, contracts.is_provider_marked_spam, contracts.parent_id, contracts.override_creator_user_id, contracts.l1_chain
from tokens
join token_definitions on tokens.token_definition_id = token_definitions.id
join contracts on token_definitions.contract_id = contracts.id
where contracts.id = $1 and tokens.displayable and not tokens.deleted and not token_definitions.deleted and not contracts.deleted
order by tokens.block_number desc
`

type GetTokenFullDetailsByContractIdRow struct {
	Token           Token           `db:"token" json:"token"`
	TokenDefinition TokenDefinition `db:"tokendefinition" json:"tokendefinition"`
	Contract        Contract        `db:"contract" json:"contract"`
}

func (q *Queries) GetTokenFullDetailsByContractId(ctx context.Context, id persist.DBID) ([]GetTokenFullDetailsByContractIdRow, error) {
	rows, err := q.db.Query(ctx, getTokenFullDetailsByContractId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTokenFullDetailsByContractIdRow
	for rows.Next() {
		var i GetTokenFullDetailsByContractIdRow
		if err := rows.Scan(
			&i.Token.ID,
			&i.Token.Deleted,
			&i.Token.Version,
			&i.Token.CreatedAt,
			&i.Token.LastUpdated,
			&i.Token.CollectorsNote,
			&i.Token.Quantity,
			&i.Token.BlockNumber,
			&i.Token.OwnerUserID,
			&i.Token.OwnedByWallets,
			&i.Token.ContractID,
			&i.Token.IsUserMarkedSpam,
			&i.Token.LastSynced,
			&i.Token.IsCreatorToken,
			&i.Token.TokenDefinitionID,
			&i.Token.IsHolderToken,
			&i.Token.Displayable,
			&i.TokenDefinition.ID,
			&i.TokenDefinition.CreatedAt,
			&i.TokenDefinition.LastUpdated,
			&i.TokenDefinition.Deleted,
			&i.TokenDefinition.Name,
			&i.TokenDefinition.Description,
			&i.TokenDefinition.TokenType,
			&i.TokenDefinition.TokenID,
			&i.TokenDefinition.ExternalUrl,
			&i.TokenDefinition.Chain,
			&i.TokenDefinition.Metadata,
			&i.TokenDefinition.FallbackMedia,
			&i.TokenDefinition.ContractAddress,
			&i.TokenDefinition.ContractID,
			&i.TokenDefinition.TokenMediaID,
			&i.TokenDefinition.IsFxhash,
			&i.Contract.ID,
			&i.Contract.Deleted,
			&i.Contract.Version,
			&i.Contract.CreatedAt,
			&i.Contract.LastUpdated,
			&i.Contract.Name,
			&i.Contract.Symbol,
			&i.Contract.Address,
			&i.Contract.CreatorAddress,
			&i.Contract.Chain,
			&i.Contract.ProfileBannerUrl,
			&i.Contract.ProfileImageUrl,
			&i.Contract.BadgeUrl,
			&i.Contract.Description,
			&i.Contract.OwnerAddress,
			&i.Contract.IsProviderMarkedSpam,
			&i.Contract.ParentID,
			&i.Contract.OverrideCreatorUserID,
			&i.Contract.L1Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenFullDetailsByUserId = `-- name: GetTokenFullDetailsByUserId :many
select tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.collectors_note, tokens.quantity, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.contract_id, tokens.is_user_marked_spam, tokens.last_synced, tokens.is_creator_token, tokens.token_definition_id, tokens.is_holder_token, tokens.displayable, token_definitions.id, token_definitions.created_at, token_definitions.last_updated, token_definitions.deleted, token_definitions.name, token_definitions.description, token_definitions.token_type, token_definitions.token_id, token_definitions.external_url, token_definitions.chain, token_definitions.metadata, token_definitions.fallback_media, token_definitions.contract_address, token_definitions.contract_id, token_definitions.token_media_id, token_definitions.is_fxhash, contracts.id, contracts.deleted, contracts.version, contracts.created_at, contracts.last_updated, contracts.name, contracts.symbol, contracts.address, contracts.creator_address, contracts.chain, contracts.profile_banner_url, contracts.profile_image_url, contracts.badge_url, contracts.description, contracts.owner_address, contracts.is_provider_marked_spam, contracts.parent_id, contracts.override_creator_user_id, contracts.l1_chain
from tokens
join token_definitions on tokens.token_definition_id = token_definitions.id
join contracts on token_definitions.contract_id = contracts.id
where tokens.owner_user_id = $1 and tokens.displayable and not tokens.deleted and not token_definitions.deleted and not contracts.deleted
order by tokens.block_number desc
`

type GetTokenFullDetailsByUserIdRow struct {
	Token           Token           `db:"token" json:"token"`
	TokenDefinition TokenDefinition `db:"tokendefinition" json:"tokendefinition"`
	Contract        Contract        `db:"contract" json:"contract"`
}

func (q *Queries) GetTokenFullDetailsByUserId(ctx context.Context, ownerUserID persist.DBID) ([]GetTokenFullDetailsByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getTokenFullDetailsByUserId, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTokenFullDetailsByUserIdRow
	for rows.Next() {
		var i GetTokenFullDetailsByUserIdRow
		if err := rows.Scan(
			&i.Token.ID,
			&i.Token.Deleted,
			&i.Token.Version,
			&i.Token.CreatedAt,
			&i.Token.LastUpdated,
			&i.Token.CollectorsNote,
			&i.Token.Quantity,
			&i.Token.BlockNumber,
			&i.Token.OwnerUserID,
			&i.Token.OwnedByWallets,
			&i.Token.ContractID,
			&i.Token.IsUserMarkedSpam,
			&i.Token.LastSynced,
			&i.Token.IsCreatorToken,
			&i.Token.TokenDefinitionID,
			&i.Token.IsHolderToken,
			&i.Token.Displayable,
			&i.TokenDefinition.ID,
			&i.TokenDefinition.CreatedAt,
			&i.TokenDefinition.LastUpdated,
			&i.TokenDefinition.Deleted,
			&i.TokenDefinition.Name,
			&i.TokenDefinition.Description,
			&i.TokenDefinition.TokenType,
			&i.TokenDefinition.TokenID,
			&i.TokenDefinition.ExternalUrl,
			&i.TokenDefinition.Chain,
			&i.TokenDefinition.Metadata,
			&i.TokenDefinition.FallbackMedia,
			&i.TokenDefinition.ContractAddress,
			&i.TokenDefinition.ContractID,
			&i.TokenDefinition.TokenMediaID,
			&i.TokenDefinition.IsFxhash,
			&i.Contract.ID,
			&i.Contract.Deleted,
			&i.Contract.Version,
			&i.Contract.CreatedAt,
			&i.Contract.LastUpdated,
			&i.Contract.Name,
			&i.Contract.Symbol,
			&i.Contract.Address,
			&i.Contract.CreatorAddress,
			&i.Contract.Chain,
			&i.Contract.ProfileBannerUrl,
			&i.Contract.ProfileImageUrl,
			&i.Contract.BadgeUrl,
			&i.Contract.Description,
			&i.Contract.OwnerAddress,
			&i.Contract.IsProviderMarkedSpam,
			&i.Contract.ParentID,
			&i.Contract.OverrideCreatorUserID,
			&i.Contract.L1Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenFullDetailsByUserTokenIdentifiers = `-- name: GetTokenFullDetailsByUserTokenIdentifiers :one
select tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.collectors_note, tokens.quantity, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.contract_id, tokens.is_user_marked_spam, tokens.last_synced, tokens.is_creator_token, tokens.token_definition_id, tokens.is_holder_token, tokens.displayable, token_definitions.id, token_definitions.created_at, token_definitions.last_updated, token_definitions.deleted, token_definitions.name, token_definitions.description, token_definitions.token_type, token_definitions.token_id, token_definitions.external_url, token_definitions.chain, token_definitions.metadata, token_definitions.fallback_media, token_definitions.contract_address, token_definitions.contract_id, token_definitions.token_media_id, token_definitions.is_fxhash, contracts.id, contracts.deleted, contracts.version, contracts.created_at, contracts.last_updated, contracts.name, contracts.symbol, contracts.address, contracts.creator_address, contracts.chain, contracts.profile_banner_url, contracts.profile_image_url, contracts.badge_url, contracts.description, contracts.owner_address, contracts.is_provider_marked_spam, contracts.parent_id, contracts.override_creator_user_id, contracts.l1_chain
from tokens
join token_definitions on tokens.token_definition_id = token_definitions.id
join contracts on token_definitions.contract_id = contracts.id
where tokens.owner_user_id = $1 
    and (token_definitions.chain, token_definitions.contract_address, token_definitions.token_id) = ($2, $3, $4)
    and tokens.displayable
    and not tokens.deleted
    and not token_definitions.deleted
    and not contracts.deleted
order by tokens.block_number desc
`

type GetTokenFullDetailsByUserTokenIdentifiersParams struct {
	OwnerUserID     persist.DBID       `db:"owner_user_id" json:"owner_user_id"`
	Chain           persist.Chain      `db:"chain" json:"chain"`
	ContractAddress persist.Address    `db:"contract_address" json:"contract_address"`
	TokenID         persist.HexTokenID `db:"token_id" json:"token_id"`
}

type GetTokenFullDetailsByUserTokenIdentifiersRow struct {
	Token           Token           `db:"token" json:"token"`
	TokenDefinition TokenDefinition `db:"tokendefinition" json:"tokendefinition"`
	Contract        Contract        `db:"contract" json:"contract"`
}

func (q *Queries) GetTokenFullDetailsByUserTokenIdentifiers(ctx context.Context, arg GetTokenFullDetailsByUserTokenIdentifiersParams) (GetTokenFullDetailsByUserTokenIdentifiersRow, error) {
	row := q.db.QueryRow(ctx, getTokenFullDetailsByUserTokenIdentifiers,
		arg.OwnerUserID,
		arg.Chain,
		arg.ContractAddress,
		arg.TokenID,
	)
	var i GetTokenFullDetailsByUserTokenIdentifiersRow
	err := row.Scan(
		&i.Token.ID,
		&i.Token.Deleted,
		&i.Token.Version,
		&i.Token.CreatedAt,
		&i.Token.LastUpdated,
		&i.Token.CollectorsNote,
		&i.Token.Quantity,
		&i.Token.BlockNumber,
		&i.Token.OwnerUserID,
		&i.Token.OwnedByWallets,
		&i.Token.ContractID,
		&i.Token.IsUserMarkedSpam,
		&i.Token.LastSynced,
		&i.Token.IsCreatorToken,
		&i.Token.TokenDefinitionID,
		&i.Token.IsHolderToken,
		&i.Token.Displayable,
		&i.TokenDefinition.ID,
		&i.TokenDefinition.CreatedAt,
		&i.TokenDefinition.LastUpdated,
		&i.TokenDefinition.Deleted,
		&i.TokenDefinition.Name,
		&i.TokenDefinition.Description,
		&i.TokenDefinition.TokenType,
		&i.TokenDefinition.TokenID,
		&i.TokenDefinition.ExternalUrl,
		&i.TokenDefinition.Chain,
		&i.TokenDefinition.Metadata,
		&i.TokenDefinition.FallbackMedia,
		&i.TokenDefinition.ContractAddress,
		&i.TokenDefinition.ContractID,
		&i.TokenDefinition.TokenMediaID,
		&i.TokenDefinition.IsFxhash,
		&i.Contract.ID,
		&i.Contract.Deleted,
		&i.Contract.Version,
		&i.Contract.CreatedAt,
		&i.Contract.LastUpdated,
		&i.Contract.Name,
		&i.Contract.Symbol,
		&i.Contract.Address,
		&i.Contract.CreatorAddress,
		&i.Contract.Chain,
		&i.Contract.ProfileBannerUrl,
		&i.Contract.ProfileImageUrl,
		&i.Contract.BadgeUrl,
		&i.Contract.Description,
		&i.Contract.OwnerAddress,
		&i.Contract.IsProviderMarkedSpam,
		&i.Contract.ParentID,
		&i.Contract.OverrideCreatorUserID,
		&i.Contract.L1Chain,
	)
	return i, err
}

const getTokensByContractIdPaginate = `-- name: GetTokensByContractIdPaginate :many
select t.id, t.deleted, t.version, t.created_at, t.last_updated, t.collectors_note, t.quantity, t.block_number, t.owner_user_id, t.owned_by_wallets, t.contract_id, t.is_user_marked_spam, t.last_synced, t.is_creator_token, t.token_definition_id, t.is_holder_token, t.displayable, td.id, td.created_at, td.last_updated, td.deleted, td.name, td.description, td.token_type, td.token_id, td.external_url, td.chain, td.metadata, td.fallback_media, td.contract_address, td.contract_id, td.token_media_id, td.is_fxhash, c.id, c.deleted, c.version, c.created_at, c.last_updated, c.name, c.symbol, c.address, c.creator_address, c.chain, c.profile_banner_url, c.profile_image_url, c.badge_url, c.description, c.owner_address, c.is_provider_marked_spam, c.parent_id, c.override_creator_user_id, c.l1_chain, u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_gallery, u.primary_wallet_id, u.user_experiences, u.profile_image_id, u.persona from tokens t
    join token_definitions td on t.token_definition_id = td.id
    join users u on u.id = t.owner_user_id
    join contracts c on t.contract_id = c.id
    where (c.id = $1 or c.parent_id = $1)
    and t.displayable
    and t.deleted = false
    and c.deleted = false
    and td.deleted = false
    and (not $3::bool or u.universal = false)
    and (u.universal,t.created_at,t.id) < ($4, $5::timestamptz, $6)
    and (u.universal,t.created_at,t.id) > ($7, $8::timestamptz, $9)
    order by case when $10::bool then (u.universal,t.created_at,t.id) end asc,
             case when not $10::bool then (u.universal,t.created_at,t.id) end desc
    limit $2
`

type GetTokensByContractIdPaginateParams struct {
	ID                 persist.DBID `db:"id" json:"id"`
	Limit              int32        `db:"limit" json:"limit"`
	GalleryUsersOnly   bool         `db:"gallery_users_only" json:"gallery_users_only"`
	CurBeforeUniversal bool         `db:"cur_before_universal" json:"cur_before_universal"`
	CurBeforeTime      time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID        persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterUniversal  bool         `db:"cur_after_universal" json:"cur_after_universal"`
	CurAfterTime       time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID         persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward      bool         `db:"paging_forward" json:"paging_forward"`
}

type GetTokensByContractIdPaginateRow struct {
	Token           Token           `db:"token" json:"token"`
	TokenDefinition TokenDefinition `db:"tokendefinition" json:"tokendefinition"`
	Contract        Contract        `db:"contract" json:"contract"`
	User            User            `db:"user" json:"user"`
}

func (q *Queries) GetTokensByContractIdPaginate(ctx context.Context, arg GetTokensByContractIdPaginateParams) ([]GetTokensByContractIdPaginateRow, error) {
	rows, err := q.db.Query(ctx, getTokensByContractIdPaginate,
		arg.ID,
		arg.Limit,
		arg.GalleryUsersOnly,
		arg.CurBeforeUniversal,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterUniversal,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTokensByContractIdPaginateRow
	for rows.Next() {
		var i GetTokensByContractIdPaginateRow
		if err := rows.Scan(
			&i.Token.ID,
			&i.Token.Deleted,
			&i.Token.Version,
			&i.Token.CreatedAt,
			&i.Token.LastUpdated,
			&i.Token.CollectorsNote,
			&i.Token.Quantity,
			&i.Token.BlockNumber,
			&i.Token.OwnerUserID,
			&i.Token.OwnedByWallets,
			&i.Token.ContractID,
			&i.Token.IsUserMarkedSpam,
			&i.Token.LastSynced,
			&i.Token.IsCreatorToken,
			&i.Token.TokenDefinitionID,
			&i.Token.IsHolderToken,
			&i.Token.Displayable,
			&i.TokenDefinition.ID,
			&i.TokenDefinition.CreatedAt,
			&i.TokenDefinition.LastUpdated,
			&i.TokenDefinition.Deleted,
			&i.TokenDefinition.Name,
			&i.TokenDefinition.Description,
			&i.TokenDefinition.TokenType,
			&i.TokenDefinition.TokenID,
			&i.TokenDefinition.ExternalUrl,
			&i.TokenDefinition.Chain,
			&i.TokenDefinition.Metadata,
			&i.TokenDefinition.FallbackMedia,
			&i.TokenDefinition.ContractAddress,
			&i.TokenDefinition.ContractID,
			&i.TokenDefinition.TokenMediaID,
			&i.TokenDefinition.IsFxhash,
			&i.Contract.ID,
			&i.Contract.Deleted,
			&i.Contract.Version,
			&i.Contract.CreatedAt,
			&i.Contract.LastUpdated,
			&i.Contract.Name,
			&i.Contract.Symbol,
			&i.Contract.Address,
			&i.Contract.CreatorAddress,
			&i.Contract.Chain,
			&i.Contract.ProfileBannerUrl,
			&i.Contract.ProfileImageUrl,
			&i.Contract.BadgeUrl,
			&i.Contract.Description,
			&i.Contract.OwnerAddress,
			&i.Contract.IsProviderMarkedSpam,
			&i.Contract.ParentID,
			&i.Contract.OverrideCreatorUserID,
			&i.Contract.L1Chain,
			&i.User.ID,
			&i.User.Deleted,
			&i.User.Version,
			&i.User.LastUpdated,
			&i.User.CreatedAt,
			&i.User.Username,
			&i.User.UsernameIdempotent,
			&i.User.Wallets,
			&i.User.Bio,
			&i.User.Traits,
			&i.User.Universal,
			&i.User.NotificationSettings,
			&i.User.EmailUnsubscriptions,
			&i.User.FeaturedGallery,
			&i.User.PrimaryWalletID,
			&i.User.UserExperiences,
			&i.User.ProfileImageID,
			&i.User.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCollectionsForCommunity = `-- name: GetTopCollectionsForCommunity :many
with contract_tokens as (
	select t.id, t.owner_user_id
	from tokens t
	join contracts c on t.contract_id = c.id
	where not t.deleted
	  and not c.deleted
	  and t.displayable
	  and c.chain = $1
	  and c.address = $2
),
ranking as (
	select col.id, rank() over (order by count(col.id) desc, col.created_at desc) score
	from collections col
	join contract_tokens on col.owner_user_id = contract_tokens.owner_user_id and contract_tokens.id = any(col.nfts)
	join users on col.owner_user_id = users.id
	where not col.deleted and not col.hidden and not users.deleted
	group by col.id
)
select collections.id from collections join ranking using(id) where score <= 100 order by score asc
`

type GetTopCollectionsForCommunityParams struct {
	Chain   persist.Chain   `db:"chain" json:"chain"`
	Address persist.Address `db:"address" json:"address"`
}

func (q *Queries) GetTopCollectionsForCommunity(ctx context.Context, arg GetTopCollectionsForCommunityParams) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, getTopCollectionsForCommunity, arg.Chain, arg.Address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var id persist.DBID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCommunitiesByPosts = `-- name: GetTopCommunitiesByPosts :many
with post_report as (
    select posts.id post_id, unnest(token_ids) token_id
    from posts
    where posts.created_at >= $1 and not posts.deleted
)
select coalesce(token_community.id, contract_community.id) id
from post_report
    join tokens on post_report.token_id = tokens.id
    join token_definitions on tokens.token_definition_id = token_definitions.id
    left join token_community_memberships on token_definitions.id = token_community_memberships.token_definition_id
    left join communities token_community on token_community_memberships.community_id = token_community.id
    left join communities contract_community on token_definitions.contract_id = contract_community.contract_id
    left join admires on post_report.post_id = admires.post_id
    left join comments on comments.post_id = post_report.post_id
where not admires.deleted and not comments.deleted and not tokens.deleted
group by coalesce(token_community.id, contract_community.id)
order by count(distinct admires.id) + count(distinct comments.id) desc
`

func (q *Queries) GetTopCommunitiesByPosts(ctx context.Context, windowEnd time.Time) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, getTopCommunitiesByPosts, windowEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var id persist.DBID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopGalleriesByViews = `-- name: GetTopGalleriesByViews :many
with viewed_galleries as (
  select gallery_id id, count(id) views
  from events
  where action = 'ViewedGallery' and events.created_at > $1
  group by gallery_id
),
updated_galleries as (
    select galleries.id
    from events
    join galleries on events.collection_id = any(galleries.collections)
    where events.created_at > $1 and action = 'TokensAddedToCollection' and not galleries.deleted
    group by galleries.id
)
select viewed_galleries.id
from viewed_galleries
join updated_galleries using(id)
order by viewed_galleries.views desc
`

func (q *Queries) GetTopGalleriesByViews(ctx context.Context, windowEnd time.Time) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, getTopGalleriesByViews, windowEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var id persist.DBID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingUsersByIDs = `-- name: GetTrendingUsersByIDs :many
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_gallery, users.primary_wallet_id, users.user_experiences, users.profile_image_id, users.persona from users join unnest($1::varchar[]) with ordinality t(id, pos) using (id) where deleted = false order by t.pos asc
`

func (q *Queries) GetTrendingUsersByIDs(ctx context.Context, userIds []string) ([]User, error) {
	rows, err := q.db.Query(ctx, getTrendingUsersByIDs, userIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniqueTokenIdentifiersByTokenID = `-- name: GetUniqueTokenIdentifiersByTokenID :one
select token_definitions.token_id, token_definitions.contract_address, token_definitions.chain, tokens.quantity, array_agg(wallets.address)::varchar[] as owner_addresses 
from tokens
join token_definitions on tokens.token_definition_id = token_definitions.id
join wallets on wallets.id = any(tokens.owned_by_wallets)
where tokens.id = $1 and tokens.displayable and not tokens.deleted and not token_definitions.deleted and not wallets.deleted
group by (token_definitions.token_id, token_definitions.contract_address, token_definitions.chain, tokens.quantity) limit 1
`

type GetUniqueTokenIdentifiersByTokenIDRow struct {
	TokenID         persist.HexTokenID `db:"token_id" json:"token_id"`
	ContractAddress persist.Address    `db:"contract_address" json:"contract_address"`
	Chain           persist.Chain      `db:"chain" json:"chain"`
	Quantity        persist.HexString  `db:"quantity" json:"quantity"`
	OwnerAddresses  []string           `db:"owner_addresses" json:"owner_addresses"`
}

func (q *Queries) GetUniqueTokenIdentifiersByTokenID(ctx context.Context, id persist.DBID) (GetUniqueTokenIdentifiersByTokenIDRow, error) {
	row := q.db.QueryRow(ctx, getUniqueTokenIdentifiersByTokenID, id)
	var i GetUniqueTokenIdentifiersByTokenIDRow
	err := row.Scan(
		&i.TokenID,
		&i.ContractAddress,
		&i.Chain,
		&i.Quantity,
		&i.OwnerAddresses,
	)
	return i, err
}

const getUserByAddressAndL1 = `-- name: GetUserByAddressAndL1 :one
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_gallery, users.primary_wallet_id, users.user_experiences, users.profile_image_id, users.persona
from users, wallets
where wallets.address = $1
	and wallets.l1_chain = $2
	and array[wallets.id] <@ users.wallets
	and wallets.deleted = false
	and users.deleted = false
`

type GetUserByAddressAndL1Params struct {
	Address persist.Address `db:"address" json:"address"`
	L1Chain persist.L1Chain `db:"l1_chain" json:"l1_chain"`
}

func (q *Queries) GetUserByAddressAndL1(ctx context.Context, arg GetUserByAddressAndL1Params) (User, error) {
	row := q.db.QueryRow(ctx, getUserByAddressAndL1, arg.Address, arg.L1Chain)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.ProfileImageID,
		&i.Persona,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_gallery, primary_wallet_id, user_experiences, profile_image_id, persona FROM users WHERE id = $1 AND deleted = false
`

func (q *Queries) GetUserById(ctx context.Context, id persist.DBID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.ProfileImageID,
		&i.Persona,
	)
	return i, err
}

const getUserByPrivyDID = `-- name: GetUserByPrivyDID :one
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_gallery, u.primary_wallet_id, u.user_experiences, u.profile_image_id, u.persona from
    privy_users p
        join users u on p.user_id = u.id and not u.deleted
where
    p.privy_did = $1
    and not p.deleted
`

func (q *Queries) GetUserByPrivyDID(ctx context.Context, privyDid string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPrivyDID, privyDid)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.ProfileImageID,
		&i.Persona,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_gallery, primary_wallet_id, user_experiences, profile_image_id, persona from users where username_idempotent = lower($1) and deleted = false and universal = false
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.ProfileImageID,
		&i.Persona,
	)
	return i, err
}

const getUserByVerifiedEmailAddress = `-- name: GetUserByVerifiedEmailAddress :one
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_gallery, u.primary_wallet_id, u.user_experiences, u.profile_image_id, u.persona from users u join pii.for_users p on u.id = p.user_id
where p.pii_verified_email_address = lower($1)
  and p.deleted = false
  and u.deleted = false
`

func (q *Queries) GetUserByVerifiedEmailAddress(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByVerifiedEmailAddress, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.ProfileImageID,
		&i.Persona,
	)
	return i, err
}

const getUserByWalletID = `-- name: GetUserByWalletID :one
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_gallery, primary_wallet_id, user_experiences, profile_image_id, persona from users where array[$1::varchar]::varchar[] <@ wallets and deleted = false
`

func (q *Queries) GetUserByWalletID(ctx context.Context, wallet string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByWalletID, wallet)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.ProfileImageID,
		&i.Persona,
	)
	return i, err
}

const getUserExperiencesByUserID = `-- name: GetUserExperiencesByUserID :one
select user_experiences from users where id = $1
`

func (q *Queries) GetUserExperiencesByUserID(ctx context.Context, id persist.DBID) (pgtype.JSONB, error) {
	row := q.db.QueryRow(ctx, getUserExperiencesByUserID, id)
	var user_experiences pgtype.JSONB
	err := row.Scan(&user_experiences)
	return user_experiences, err
}

const getUserIsBlockedFromFeed = `-- name: GetUserIsBlockedFromFeed :one
select exists(select 1 from feed_blocklist where user_id = $1 and not deleted and active)
`

func (q *Queries) GetUserIsBlockedFromFeed(ctx context.Context, userID persist.DBID) (bool, error) {
	row := q.db.QueryRow(ctx, getUserIsBlockedFromFeed, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id FROM notifications WHERE owner_id = $1 AND deleted = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type GetUserNotificationsParams struct {
	OwnerID       persist.DBID `db:"owner_id" json:"owner_id"`
	Limit         int32        `db:"limit" json:"limit"`
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserNotifications,
		arg.OwnerID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
			&i.PostID,
			&i.TokenID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRolesByUserId = `-- name: GetUserRolesByUserId :many
with membership_roles(role) as (
    select (case when exists(
        select 1
        from tokens
        join token_definitions on tokens.token_definition_id = token_definitions.id
        where owner_user_id = $1
            and token_definitions.chain = $2
            and token_definitions.contract_address = $3
            and token_definitions.token_id = any($4::varchar[])
            and tokens.displayable
            and not tokens.deleted
            and not token_definitions.deleted
    ) then $5 else null end)::varchar
)
select role from user_roles where user_id = $1 and deleted = false
union
select role from membership_roles where role is not null
`

type GetUserRolesByUserIdParams struct {
	UserID                persist.DBID    `db:"user_id" json:"user_id"`
	Chain                 persist.Chain   `db:"chain" json:"chain"`
	MembershipAddress     persist.Address `db:"membership_address" json:"membership_address"`
	MembershipTokenIds    []string        `db:"membership_token_ids" json:"membership_token_ids"`
	GrantedMembershipRole string          `db:"granted_membership_role" json:"granted_membership_role"`
}

func (q *Queries) GetUserRolesByUserId(ctx context.Context, arg GetUserRolesByUserIdParams) ([]persist.Role, error) {
	rows, err := q.db.Query(ctx, getUserRolesByUserId,
		arg.UserID,
		arg.Chain,
		arg.MembershipAddress,
		arg.MembershipTokenIds,
		arg.GrantedMembershipRole,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.Role
	for rows.Next() {
		var role persist.Role
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserUnseenNotifications = `-- name: GetUserUnseenNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount, post_id, token_id, mention_id, community_id FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type GetUserUnseenNotificationsParams struct {
	OwnerID       persist.DBID `db:"owner_id" json:"owner_id"`
	Limit         int32        `db:"limit" json:"limit"`
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetUserUnseenNotifications(ctx context.Context, arg GetUserUnseenNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserUnseenNotifications,
		arg.OwnerID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
			&i.PostID,
			&i.TokenID,
			&i.MentionID,
			&i.CommunityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithPIIByID = `-- name: GetUserWithPIIByID :one
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_gallery, primary_wallet_id, user_experiences, profile_image_id, pii_unverified_email_address, pii_verified_email_address, pii_socials from pii.user_view where id = $1 and deleted = false
`

func (q *Queries) GetUserWithPIIByID(ctx context.Context, userID persist.DBID) (PiiUserView, error) {
	row := q.db.QueryRow(ctx, getUserWithPIIByID, userID)
	var i PiiUserView
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedGallery,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.ProfileImageID,
		&i.PiiUnverifiedEmailAddress,
		&i.PiiVerifiedEmailAddress,
		&i.PiiSocials,
	)
	return i, err
}

const getUsersByChainAddresses = `-- name: GetUsersByChainAddresses :many
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_gallery, users.primary_wallet_id, users.user_experiences, users.profile_image_id, users.persona,wallets.address from users, wallets where wallets.address = ANY($1::varchar[]) AND wallets.l1_chain = $2 AND ARRAY[wallets.id] <@ users.wallets AND users.deleted = false AND wallets.deleted = false
`

type GetUsersByChainAddressesParams struct {
	Addresses []string        `db:"addresses" json:"addresses"`
	L1Chain   persist.L1Chain `db:"l1_chain" json:"l1_chain"`
}

type GetUsersByChainAddressesRow struct {
	ID                   persist.DBID                     `db:"id" json:"id"`
	Deleted              bool                             `db:"deleted" json:"deleted"`
	Version              sql.NullInt32                    `db:"version" json:"version"`
	LastUpdated          time.Time                        `db:"last_updated" json:"last_updated"`
	CreatedAt            time.Time                        `db:"created_at" json:"created_at"`
	Username             sql.NullString                   `db:"username" json:"username"`
	UsernameIdempotent   sql.NullString                   `db:"username_idempotent" json:"username_idempotent"`
	Wallets              persist.WalletList               `db:"wallets" json:"wallets"`
	Bio                  sql.NullString                   `db:"bio" json:"bio"`
	Traits               pgtype.JSONB                     `db:"traits" json:"traits"`
	Universal            bool                             `db:"universal" json:"universal"`
	NotificationSettings persist.UserNotificationSettings `db:"notification_settings" json:"notification_settings"`
	EmailUnsubscriptions persist.EmailUnsubscriptions     `db:"email_unsubscriptions" json:"email_unsubscriptions"`
	FeaturedGallery      *persist.DBID                    `db:"featured_gallery" json:"featured_gallery"`
	PrimaryWalletID      persist.DBID                     `db:"primary_wallet_id" json:"primary_wallet_id"`
	UserExperiences      pgtype.JSONB                     `db:"user_experiences" json:"user_experiences"`
	ProfileImageID       persist.DBID                     `db:"profile_image_id" json:"profile_image_id"`
	Persona              persist.Persona                  `db:"persona" json:"persona"`
	Address              persist.Address                  `db:"address" json:"address"`
}

func (q *Queries) GetUsersByChainAddresses(ctx context.Context, arg GetUsersByChainAddressesParams) ([]GetUsersByChainAddressesRow, error) {
	rows, err := q.db.Query(ctx, getUsersByChainAddresses, arg.Addresses, arg.L1Chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByChainAddressesRow
	for rows.Next() {
		var i GetUsersByChainAddressesRow
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.Persona,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByFarcasterIDs = `-- name: GetUsersByFarcasterIDs :many
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_gallery, users.primary_wallet_id, users.user_experiences, users.profile_image_id, users.persona
from pii.for_users join users on for_users.user_id = users.id
where ((pii_socials -> 'Farcaster'::text) ->> 'id'::text) = any($1::varchar[]) and not users.deleted
`

func (q *Queries) GetUsersByFarcasterIDs(ctx context.Context, fids []string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByFarcasterIDs, fids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_gallery, primary_wallet_id, user_experiences, profile_image_id, persona FROM users WHERE id = ANY($2) AND deleted = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $1
`

type GetUsersByIDsParams struct {
	Limit         int32            `db:"limit" json:"limit"`
	UserIds       persist.DBIDList `db:"user_ids" json:"user_ids"`
	CurBeforeTime time.Time        `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID     `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time        `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID     `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool             `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetUsersByIDs(ctx context.Context, arg GetUsersByIDsParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs,
		arg.Limit,
		arg.UserIds,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersBySocialIDs = `-- name: GetUsersBySocialIDs :many
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_gallery, primary_wallet_id, user_experiences, profile_image_id, pii_unverified_email_address, pii_verified_email_address, pii_socials from pii.user_view u where u.pii_socials->$1::varchar->>'id' = any($2::varchar[]) and not u.deleted and not u.universal
`

type GetUsersBySocialIDsParams struct {
	SocialAccountType string   `db:"social_account_type" json:"social_account_type"`
	SocialIds         []string `db:"social_ids" json:"social_ids"`
}

func (q *Queries) GetUsersBySocialIDs(ctx context.Context, arg GetUsersBySocialIDsParams) ([]PiiUserView, error) {
	rows, err := q.db.Query(ctx, getUsersBySocialIDs, arg.SocialAccountType, arg.SocialIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PiiUserView
	for rows.Next() {
		var i PiiUserView
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.PiiUnverifiedEmailAddress,
			&i.PiiVerifiedEmailAddress,
			&i.PiiSocials,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByWalletAddressesAndChains = `-- name: GetUsersByWalletAddressesAndChains :many
WITH params AS (
    SELECT unnest($1::varchar[]) as address, unnest($2::int[]) as chain
)
SELECT wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type, wallets.chain, wallets.l1_chain, users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_gallery, users.primary_wallet_id, users.user_experiences, users.profile_image_id, users.persona
FROM wallets 
JOIN users ON wallets.id = any(users.wallets)
JOIN params ON wallets.address = params.address AND wallets.chain = params.chain
WHERE not wallets.deleted AND not users.deleted and not users.universal
`

type GetUsersByWalletAddressesAndChainsParams struct {
	WalletAddresses []string `db:"wallet_addresses" json:"wallet_addresses"`
	Chains          []int32  `db:"chains" json:"chains"`
}

type GetUsersByWalletAddressesAndChainsRow struct {
	Wallet Wallet `db:"wallet" json:"wallet"`
	User   User   `db:"user" json:"user"`
}

func (q *Queries) GetUsersByWalletAddressesAndChains(ctx context.Context, arg GetUsersByWalletAddressesAndChainsParams) ([]GetUsersByWalletAddressesAndChainsRow, error) {
	rows, err := q.db.Query(ctx, getUsersByWalletAddressesAndChains, arg.WalletAddresses, arg.Chains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByWalletAddressesAndChainsRow
	for rows.Next() {
		var i GetUsersByWalletAddressesAndChainsRow
		if err := rows.Scan(
			&i.Wallet.ID,
			&i.Wallet.CreatedAt,
			&i.Wallet.LastUpdated,
			&i.Wallet.Deleted,
			&i.Wallet.Version,
			&i.Wallet.Address,
			&i.Wallet.WalletType,
			&i.Wallet.Chain,
			&i.Wallet.L1Chain,
			&i.User.ID,
			&i.User.Deleted,
			&i.User.Version,
			&i.User.LastUpdated,
			&i.User.CreatedAt,
			&i.User.Username,
			&i.User.UsernameIdempotent,
			&i.User.Wallets,
			&i.User.Bio,
			&i.User.Traits,
			&i.User.Universal,
			&i.User.NotificationSettings,
			&i.User.EmailUnsubscriptions,
			&i.User.FeaturedGallery,
			&i.User.PrimaryWalletID,
			&i.User.UserExperiences,
			&i.User.ProfileImageID,
			&i.User.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithEmailNotificationsOnForEmailType = `-- name: GetUsersWithEmailNotificationsOnForEmailType :many
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_gallery, u.primary_wallet_id, u.user_experiences, u.profile_image_id, u.pii_unverified_email_address, u.pii_verified_email_address, u.pii_socials from pii.user_view u
    left join user_roles r on r.user_id = u.id and r.role = 'EMAIL_TESTER' and r.deleted = false
    where (u.email_unsubscriptions->>'all' = 'false' or u.email_unsubscriptions->>'all' is null)
    and (u.email_unsubscriptions->>$2::varchar = 'false' or u.email_unsubscriptions->>$2::varchar is null)
    and u.deleted = false and u.pii_verified_email_address is not null
    and (u.created_at, u.id) < ($3, $4)
    and (u.created_at, u.id) > ($5, $6)
    and ($7::bool = false or r.user_id is not null)
    order by case when $8::bool then (u.created_at, u.id) end asc,
             case when not $8::bool then (u.created_at, u.id) end desc
    limit $1
`

type GetUsersWithEmailNotificationsOnForEmailTypeParams struct {
	Limit               int32        `db:"limit" json:"limit"`
	EmailUnsubscription string       `db:"email_unsubscription" json:"email_unsubscription"`
	CurBeforeTime       time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID         persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime        time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID          persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	EmailTestersOnly    bool         `db:"email_testers_only" json:"email_testers_only"`
	PagingForward       bool         `db:"paging_forward" json:"paging_forward"`
}

// for some reason this query will not allow me to use @tags for $1
func (q *Queries) GetUsersWithEmailNotificationsOnForEmailType(ctx context.Context, arg GetUsersWithEmailNotificationsOnForEmailTypeParams) ([]PiiUserView, error) {
	rows, err := q.db.Query(ctx, getUsersWithEmailNotificationsOnForEmailType,
		arg.Limit,
		arg.EmailUnsubscription,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.EmailTestersOnly,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PiiUserView
	for rows.Next() {
		var i PiiUserView
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.PiiUnverifiedEmailAddress,
			&i.PiiVerifiedEmailAddress,
			&i.PiiSocials,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRolePaginate = `-- name: GetUsersWithRolePaginate :many
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_gallery, u.primary_wallet_id, u.user_experiences, u.profile_image_id, u.persona from users u, user_roles ur where u.deleted = false and ur.deleted = false
    and u.id = ur.user_id and ur.role = $2
    and (u.username_idempotent, u.id) < ($3::varchar, $4)
    and (u.username_idempotent, u.id) > ($5::varchar, $6)
    order by case when $7::bool then (u.username_idempotent, u.id) end asc,
             case when not $7::bool then (u.username_idempotent, u.id) end desc
    limit $1
`

type GetUsersWithRolePaginateParams struct {
	Limit         int32        `db:"limit" json:"limit"`
	Role          persist.Role `db:"role" json:"role"`
	CurBeforeKey  string       `db:"cur_before_key" json:"cur_before_key"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterKey   string       `db:"cur_after_key" json:"cur_after_key"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetUsersWithRolePaginate(ctx context.Context, arg GetUsersWithRolePaginateParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithRolePaginate,
		arg.Limit,
		arg.Role,
		arg.CurBeforeKey,
		arg.CurBeforeID,
		arg.CurAfterKey,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithTrait = `-- name: GetUsersWithTrait :many
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_gallery, primary_wallet_id, user_experiences, profile_image_id, persona FROM users WHERE (traits->$1::string) IS NOT NULL AND deleted = false
`

func (q *Queries) GetUsersWithTrait(ctx context.Context, dollar_1 string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithTrait, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedGallery,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.ProfileImageID,
			&i.Persona,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithoutSocials = `-- name: GetUsersWithoutSocials :many
select u.id, w.address, u.pii_socials->>'Lens' is null, u.pii_socials->>'Farcaster' is null from pii.user_view u join wallets w on w.id = any(u.wallets) where u.deleted = false and w.chain = 0 and w.deleted = false and u.universal = false and (u.pii_socials->>'Lens' is null or u.pii_socials->>'Farcaster' is null) order by u.created_at desc
`

type GetUsersWithoutSocialsRow struct {
	ID      persist.DBID    `db:"id" json:"id"`
	Address persist.Address `db:"address" json:"address"`
	Column3 interface{}     `db:"column_3" json:"column_3"`
	Column4 interface{}     `db:"column_4" json:"column_4"`
}

func (q *Queries) GetUsersWithoutSocials(ctx context.Context) ([]GetUsersWithoutSocialsRow, error) {
	rows, err := q.db.Query(ctx, getUsersWithoutSocials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithoutSocialsRow
	for rows.Next() {
		var i GetUsersWithoutSocialsRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Column3,
			&i.Column4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByAddressAndL1Chain = `-- name: GetWalletByAddressAndL1Chain :one
SELECT wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type, wallets.chain, wallets.l1_chain FROM wallets WHERE address = $1 AND l1_chain = $2 AND deleted = false
`

type GetWalletByAddressAndL1ChainParams struct {
	Address persist.Address `db:"address" json:"address"`
	L1Chain persist.L1Chain `db:"l1_chain" json:"l1_chain"`
}

func (q *Queries) GetWalletByAddressAndL1Chain(ctx context.Context, arg GetWalletByAddressAndL1ChainParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByAddressAndL1Chain, arg.Address, arg.L1Chain)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Version,
		&i.Address,
		&i.WalletType,
		&i.Chain,
		&i.L1Chain,
	)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, created_at, last_updated, deleted, version, address, wallet_type, chain, l1_chain FROM wallets WHERE id = $1 AND deleted = false
`

func (q *Queries) GetWalletByID(ctx context.Context, id persist.DBID) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Version,
		&i.Address,
		&i.WalletType,
		&i.Chain,
		&i.L1Chain,
	)
	return i, err
}

const getWalletsByUserID = `-- name: GetWalletsByUserID :many
SELECT w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type, w.chain, w.l1_chain FROM users u, unnest(u.wallets) WITH ORDINALITY AS a(wallet_id, wallet_ord)INNER JOIN wallets w on w.id = a.wallet_id WHERE u.id = $1 AND u.deleted = false AND w.deleted = false ORDER BY a.wallet_ord
`

func (q *Queries) GetWalletsByUserID(ctx context.Context, id persist.DBID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getWalletsByUserID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
			&i.L1Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWindowedTrendingUserIDs = `-- name: GetWindowedTrendingUserIDs :many
with viewers as (
  select gallery_id, count(distinct coalesce(actor_id, external_id)) viewer_count
  from events
  where action = 'ViewedGallery' and events.created_at >= $2
  group by gallery_id
),
edit_events as (
  select actor_id
  from events
  where action in (
    'CollectionCreated',
    'CollectorsNoteAddedToCollection',
    'CollectorsNoteAddedToToken',
    'TokensAddedToCollection',
    'GalleryInfoUpdated'
  ) and created_at >= $2
  group by actor_id
)
select users.id
from viewers, galleries, users, edit_events
where viewers.gallery_id = galleries.id
	and galleries.owner_user_id = users.id
	and users.deleted = false
	and galleries.deleted = false
  and users.id = edit_events.actor_id
group by users.id
order by row_number() over(order by sum(viewers.viewer_count) desc, max(users.created_at) desc) asc
limit $1
`

type GetWindowedTrendingUserIDsParams struct {
	Limit     int32     `db:"limit" json:"limit"`
	WindowEnd time.Time `db:"window_end" json:"window_end"`
}

func (q *Queries) GetWindowedTrendingUserIDs(ctx context.Context, arg GetWindowedTrendingUserIDsParams) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, getWindowedTrendingUserIDs, arg.Limit, arg.WindowEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var id persist.DBID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasLaterGroupedEvent = `-- name: HasLaterGroupedEvent :one
select exists(
  select 1 from events where deleted = false
  and group_id = $1
  and id > $2
)
`

type HasLaterGroupedEventParams struct {
	GroupID sql.NullString `db:"group_id" json:"group_id"`
	EventID persist.DBID   `db:"event_id" json:"event_id"`
}

func (q *Queries) HasLaterGroupedEvent(ctx context.Context, arg HasLaterGroupedEventParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasLaterGroupedEvent, arg.GroupID, arg.EventID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const insertComment = `-- name: InsertComment :one
INSERT INTO comments 
(ID, FEED_EVENT_ID, POST_ID, ACTOR_ID, REPLY_TO, TOP_LEVEL_COMMENT_ID, COMMENT) 
VALUES 
($1, $2::varchar, $3::varchar, $4, $5::varchar, 
    (CASE 
        WHEN $5::varchar IS NOT NULL THEN
            (SELECT COALESCE(c.top_level_comment_id, $5::varchar) 
             FROM comments c 
             WHERE c.id = $5::varchar)
        ELSE NULL 
    END), 
$6::varchar) 
RETURNING ID
`

type InsertCommentParams struct {
	ID        persist.DBID   `db:"id" json:"id"`
	FeedEvent sql.NullString `db:"feed_event" json:"feed_event"`
	Post      sql.NullString `db:"post" json:"post"`
	ActorID   persist.DBID   `db:"actor_id" json:"actor_id"`
	Reply     sql.NullString `db:"reply" json:"reply"`
	Comment   string         `db:"comment" json:"comment"`
}

func (q *Queries) InsertComment(ctx context.Context, arg InsertCommentParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, insertComment,
		arg.ID,
		arg.FeedEvent,
		arg.Post,
		arg.ActorID,
		arg.Reply,
		arg.Comment,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const insertCommentMention = `-- name: InsertCommentMention :one
insert into mentions (id, user_id, community_id, comment_id, start, length) values ($1, $2, $3, $4, $5, $6) returning id, post_id, comment_id, user_id, start, length, created_at, deleted, community_id
`

type InsertCommentMentionParams struct {
	ID        persist.DBID   `db:"id" json:"id"`
	User      sql.NullString `db:"user" json:"user"`
	Community sql.NullString `db:"community" json:"community"`
	CommentID persist.DBID   `db:"comment_id" json:"comment_id"`
	Start     sql.NullInt32  `db:"start" json:"start"`
	Length    sql.NullInt32  `db:"length" json:"length"`
}

func (q *Queries) InsertCommentMention(ctx context.Context, arg InsertCommentMentionParams) (Mention, error) {
	row := q.db.QueryRow(ctx, insertCommentMention,
		arg.ID,
		arg.User,
		arg.Community,
		arg.CommentID,
		arg.Start,
		arg.Length,
	)
	var i Mention
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.CommentID,
		&i.UserID,
		&i.Start,
		&i.Length,
		&i.CreatedAt,
		&i.Deleted,
		&i.CommunityID,
	)
	return i, err
}

const insertMention = `-- name: InsertMention :one
insert into mentions (id, comment_id, user_id, community_id, start, length) values ($1, $2, $5, $6, $3, $4) returning id
`

type InsertMentionParams struct {
	ID        persist.DBID   `db:"id" json:"id"`
	CommentID persist.DBID   `db:"comment_id" json:"comment_id"`
	Start     sql.NullInt32  `db:"start" json:"start"`
	Length    sql.NullInt32  `db:"length" json:"length"`
	User      sql.NullString `db:"user" json:"user"`
	Community sql.NullString `db:"community" json:"community"`
}

func (q *Queries) InsertMention(ctx context.Context, arg InsertMentionParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, insertMention,
		arg.ID,
		arg.CommentID,
		arg.Start,
		arg.Length,
		arg.User,
		arg.Community,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const insertPost = `-- name: InsertPost :one
insert into posts(id, token_ids, contract_ids, actor_id, caption, user_mint_url, is_first_post, created_at)
values ($1, $2, $3, $4, $5, $6, not exists(select 1 from posts where posts.created_at < now() and posts.actor_id = $4::varchar limit 1), now())
on conflict (actor_id, is_first_post) where is_first_post do update set is_first_post = false
returning id
`

type InsertPostParams struct {
	ID          persist.DBID     `db:"id" json:"id"`
	TokenIds    persist.DBIDList `db:"token_ids" json:"token_ids"`
	ContractIds persist.DBIDList `db:"contract_ids" json:"contract_ids"`
	ActorID     persist.DBID     `db:"actor_id" json:"actor_id"`
	Caption     sql.NullString   `db:"caption" json:"caption"`
	UserMintUrl sql.NullString   `db:"user_mint_url" json:"user_mint_url"`
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, insertPost,
		arg.ID,
		arg.TokenIds,
		arg.ContractIds,
		arg.ActorID,
		arg.Caption,
		arg.UserMintUrl,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const insertPostMention = `-- name: InsertPostMention :one
insert into mentions (id, user_id, community_id, post_id, start, length) values ($1, $2, $3, $4, $5, $6) returning id, post_id, comment_id, user_id, start, length, created_at, deleted, community_id
`

type InsertPostMentionParams struct {
	ID        persist.DBID   `db:"id" json:"id"`
	User      sql.NullString `db:"user" json:"user"`
	Community sql.NullString `db:"community" json:"community"`
	PostID    persist.DBID   `db:"post_id" json:"post_id"`
	Start     sql.NullInt32  `db:"start" json:"start"`
	Length    sql.NullInt32  `db:"length" json:"length"`
}

func (q *Queries) InsertPostMention(ctx context.Context, arg InsertPostMentionParams) (Mention, error) {
	row := q.db.QueryRow(ctx, insertPostMention,
		arg.ID,
		arg.User,
		arg.Community,
		arg.PostID,
		arg.Start,
		arg.Length,
	)
	var i Mention
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.CommentID,
		&i.UserID,
		&i.Start,
		&i.Length,
		&i.CreatedAt,
		&i.Deleted,
		&i.CommunityID,
	)
	return i, err
}

const insertSpamContracts = `-- name: InsertSpamContracts :exec
with insert_spam_contracts as (
    insert into alchemy_spam_contracts (id, chain, address, created_at, is_spam) (
        select unnest($1::varchar[])
        , unnest($2::int[])
        , unnest($3::varchar[])
        , unnest($4::timestamptz[])
        , unnest($5::bool[])
    ) on conflict(chain, address) do update set created_at = excluded.created_at, is_spam = excluded.is_spam
    returning created_at
)
delete from alchemy_spam_contracts where created_at < (select created_at from insert_spam_contracts limit 1)
`

type InsertSpamContractsParams struct {
	ID        []string    `db:"id" json:"id"`
	Chain     []int32     `db:"chain" json:"chain"`
	Address   []string    `db:"address" json:"address"`
	CreatedAt []time.Time `db:"created_at" json:"created_at"`
	IsSpam    []bool      `db:"is_spam" json:"is_spam"`
}

func (q *Queries) InsertSpamContracts(ctx context.Context, arg InsertSpamContractsParams) error {
	_, err := q.db.Exec(ctx, insertSpamContracts,
		arg.ID,
		arg.Chain,
		arg.Address,
		arg.CreatedAt,
		arg.IsSpam,
	)
	return err
}

const insertTokenPipelineResults = `-- name: InsertTokenPipelineResults :one
with insert_job(id) as (
    insert into token_processing_jobs (id, token_properties, pipeline_metadata, processing_cause, processor_version)
    values ($1, $2, $3, $4, $5)
    returning id
)
, set_conditionally_current_media_to_inactive(last_updated) as (
    insert into token_medias (id, media, processing_job_id, active, created_at, last_updated)
    (
        select $6, media, processing_job_id, false, created_at, now()
        from token_medias
        where id = (select token_media_id from token_definitions td where (td.chain, td.contract_address, td.token_id) = ($7, $8, $9) and not deleted)
        and not deleted
        and $10::bool
    )
    returning last_updated
)
, insert_new_media as (
    insert into token_medias (id, media, processing_job_id, active, created_at, last_updated)
    values ($11, $12, (select id from insert_job), $10,
        -- Using timestamps generated from set_conditionally_current_media_to_inactive ensures that the new record is only inserted after the current media is moved
        (select coalesce((select last_updated from set_conditionally_current_media_to_inactive), now())),
        (select coalesce((select last_updated from set_conditionally_current_media_to_inactive), now()))
    )
    returning id, created_at, last_updated, version, active, media, processing_job_id, deleted
)
, update_token_definition as (
    update token_definitions
    set metadata = $13,
        name = $14,
        description = $15,
        token_media_id = case
            -- If there isn't any media, use the new media regardless of its status
            when token_media_id is null then (select id from insert_new_media)
            -- Otherwise, only replace reference to new media if it is active
            when $10 then (select id from insert_new_media)
            -- If it isn't, keep the existing media
            else token_definitions.token_media_id
        end
    where (chain, contract_address, token_id) = ($7, $8, $9) and not deleted
)
select token_medias.id, token_medias.created_at, token_medias.last_updated, token_medias.version, token_medias.active, token_medias.media, token_medias.processing_job_id, token_medias.deleted from insert_new_media token_medias
`

type InsertTokenPipelineResultsParams struct {
	ProcessingJobID  persist.DBID             `db:"processing_job_id" json:"processing_job_id"`
	TokenProperties  persist.TokenProperties  `db:"token_properties" json:"token_properties"`
	PipelineMetadata persist.PipelineMetadata `db:"pipeline_metadata" json:"pipeline_metadata"`
	ProcessingCause  persist.ProcessingCause  `db:"processing_cause" json:"processing_cause"`
	ProcessorVersion string                   `db:"processor_version" json:"processor_version"`
	RetiringMediaID  persist.DBID             `db:"retiring_media_id" json:"retiring_media_id"`
	Chain            persist.Chain            `db:"chain" json:"chain"`
	ContractAddress  persist.Address          `db:"contract_address" json:"contract_address"`
	TokenID          persist.HexTokenID       `db:"token_id" json:"token_id"`
	NewMediaIsActive bool                     `db:"new_media_is_active" json:"new_media_is_active"`
	NewMediaID       persist.DBID             `db:"new_media_id" json:"new_media_id"`
	NewMedia         pgtype.JSONB             `db:"new_media" json:"new_media"`
	NewMetadata      pgtype.JSONB             `db:"new_metadata" json:"new_metadata"`
	NewName          sql.NullString           `db:"new_name" json:"new_name"`
	NewDescription   sql.NullString           `db:"new_description" json:"new_description"`
}

type InsertTokenPipelineResultsRow struct {
	TokenMedia TokenMedia `db:"tokenmedia" json:"tokenmedia"`
}

// Always return the new media that was inserted, even if its inactive so the pipeline can report metrics accurately
func (q *Queries) InsertTokenPipelineResults(ctx context.Context, arg InsertTokenPipelineResultsParams) (InsertTokenPipelineResultsRow, error) {
	row := q.db.QueryRow(ctx, insertTokenPipelineResults,
		arg.ProcessingJobID,
		arg.TokenProperties,
		arg.PipelineMetadata,
		arg.ProcessingCause,
		arg.ProcessorVersion,
		arg.RetiringMediaID,
		arg.Chain,
		arg.ContractAddress,
		arg.TokenID,
		arg.NewMediaIsActive,
		arg.NewMediaID,
		arg.NewMedia,
		arg.NewMetadata,
		arg.NewName,
		arg.NewDescription,
	)
	var i InsertTokenPipelineResultsRow
	err := row.Scan(
		&i.TokenMedia.ID,
		&i.TokenMedia.CreatedAt,
		&i.TokenMedia.LastUpdated,
		&i.TokenMedia.Version,
		&i.TokenMedia.Active,
		&i.TokenMedia.Media,
		&i.TokenMedia.ProcessingJobID,
		&i.TokenMedia.Deleted,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one
insert into users (id, username, username_idempotent, bio, universal, email_unsubscriptions) values ($1, $2, $3, $4, $5, $6) returning id
`

type InsertUserParams struct {
	ID                   persist.DBID                 `db:"id" json:"id"`
	Username             sql.NullString               `db:"username" json:"username"`
	UsernameIdempotent   sql.NullString               `db:"username_idempotent" json:"username_idempotent"`
	Bio                  sql.NullString               `db:"bio" json:"bio"`
	Universal            bool                         `db:"universal" json:"universal"`
	EmailUnsubscriptions persist.EmailUnsubscriptions `db:"email_unsubscriptions" json:"email_unsubscriptions"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, insertUser,
		arg.ID,
		arg.Username,
		arg.UsernameIdempotent,
		arg.Bio,
		arg.Universal,
		arg.EmailUnsubscriptions,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const insertWallet = `-- name: InsertWallet :exec
with new_wallet as (insert into wallets(id, address, chain, l1_chain, wallet_type) values ($1, $2, $3, $4, $5) returning id)
update users set
    primary_wallet_id = coalesce(users.primary_wallet_id, new_wallet.id),
    wallets = array_append(users.wallets, new_wallet.id)
from new_wallet
where users.id = $6 and not users.deleted
`

type InsertWalletParams struct {
	ID         persist.DBID       `db:"id" json:"id"`
	Address    persist.Address    `db:"address" json:"address"`
	Chain      persist.Chain      `db:"chain" json:"chain"`
	L1Chain    persist.L1Chain    `db:"l1_chain" json:"l1_chain"`
	WalletType persist.WalletType `db:"wallet_type" json:"wallet_type"`
	UserID     persist.DBID       `db:"user_id" json:"user_id"`
}

func (q *Queries) InsertWallet(ctx context.Context, arg InsertWalletParams) error {
	_, err := q.db.Exec(ctx, insertWallet,
		arg.ID,
		arg.Address,
		arg.Chain,
		arg.L1Chain,
		arg.WalletType,
		arg.UserID,
	)
	return err
}

const invalidateSession = `-- name: InvalidateSession :exec
update sessions set invalidated = true, active_until = least(active_until, now()), last_updated = now() where id = $1 and deleted = false and invalidated = false
`

func (q *Queries) InvalidateSession(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, invalidateSession, id)
	return err
}

const isActorActionActive = `-- name: IsActorActionActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and action = any($2)
  and created_at > $3 and created_at <= $4
)
`

type IsActorActionActiveParams struct {
	ActorID     sql.NullString     `db:"actor_id" json:"actor_id"`
	Actions     persist.ActionList `db:"actions" json:"actions"`
	WindowStart time.Time          `db:"window_start" json:"window_start"`
	WindowEnd   time.Time          `db:"window_end" json:"window_end"`
}

func (q *Queries) IsActorActionActive(ctx context.Context, arg IsActorActionActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorActionActive,
		arg.ActorID,
		arg.Actions,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorGalleryActive = `-- name: IsActorGalleryActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and gallery_id = $2
  and created_at > $3 and created_at <= $4
)
`

type IsActorGalleryActiveParams struct {
	ActorID     sql.NullString `db:"actor_id" json:"actor_id"`
	GalleryID   persist.DBID   `db:"gallery_id" json:"gallery_id"`
	WindowStart time.Time      `db:"window_start" json:"window_start"`
	WindowEnd   time.Time      `db:"window_end" json:"window_end"`
}

func (q *Queries) IsActorGalleryActive(ctx context.Context, arg IsActorGalleryActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorGalleryActive,
		arg.ActorID,
		arg.GalleryID,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSubjectActionActive = `-- name: IsActorSubjectActionActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and subject_id = $2
  and action = any($3)
  and created_at > $4 and created_at <= $5
)
`

type IsActorSubjectActionActiveParams struct {
	ActorID     sql.NullString     `db:"actor_id" json:"actor_id"`
	SubjectID   persist.DBID       `db:"subject_id" json:"subject_id"`
	Actions     persist.ActionList `db:"actions" json:"actions"`
	WindowStart time.Time          `db:"window_start" json:"window_start"`
	WindowEnd   time.Time          `db:"window_end" json:"window_end"`
}

func (q *Queries) IsActorSubjectActionActive(ctx context.Context, arg IsActorSubjectActionActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSubjectActionActive,
		arg.ActorID,
		arg.SubjectID,
		arg.Actions,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSubjectActive = `-- name: IsActorSubjectActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and subject_id = $2
  and created_at > $3 and created_at <= $4
)
`

type IsActorSubjectActiveParams struct {
	ActorID     sql.NullString `db:"actor_id" json:"actor_id"`
	SubjectID   persist.DBID   `db:"subject_id" json:"subject_id"`
	WindowStart time.Time      `db:"window_start" json:"window_start"`
	WindowEnd   time.Time      `db:"window_end" json:"window_end"`
}

func (q *Queries) IsActorSubjectActive(ctx context.Context, arg IsActorSubjectActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSubjectActive,
		arg.ActorID,
		arg.SubjectID,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isFeedEventExistsForGroup = `-- name: IsFeedEventExistsForGroup :one
SELECT exists(
  SELECT 1 FROM feed_events WHERE deleted = false
  AND group_id = $1
)
`

func (q *Queries) IsFeedEventExistsForGroup(ctx context.Context, groupID sql.NullString) (bool, error) {
	row := q.db.QueryRow(ctx, isFeedEventExistsForGroup, groupID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const paginateGlobalFeed = `-- name: PaginateGlobalFeed :many
select fe.id, fe.feed_entity_type, fe.created_at, fe.actor_id
from feed_entities fe
left join feed_blocklist fb on fe.actor_id = fb.user_id and not fb.deleted and fb.active
where (fe.created_at, fe.id) < ($1, $2)
        and (fe.created_at, fe.id) > ($3, $4)
        and (fb.user_id is null or $5 = fb.user_id)
order by
    case when $6::bool then (fe.created_at, fe.id) end asc,
    case when not $6::bool then (fe.created_at, fe.id) end desc
limit $7
`

type PaginateGlobalFeedParams struct {
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	ViewerID      persist.DBID `db:"viewer_id" json:"viewer_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
	Limit         int32        `db:"limit" json:"limit"`
}

func (q *Queries) PaginateGlobalFeed(ctx context.Context, arg PaginateGlobalFeedParams) ([]FeedEntity, error) {
	rows, err := q.db.Query(ctx, paginateGlobalFeed,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.ViewerID,
		arg.PagingForward,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedEntity
	for rows.Next() {
		var i FeedEntity
		if err := rows.Scan(
			&i.ID,
			&i.FeedEntityType,
			&i.CreatedAt,
			&i.ActorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatePersonalFeedByUserID = `-- name: PaginatePersonalFeedByUserID :many
select fe.id, fe.feed_entity_type, fe.created_at, fe.actor_id from feed_entities fe, follows fl
    where fl.deleted = false
      and fe.actor_id = fl.followee
      and fl.follower = $1
      and (fe.created_at, fe.id) < ($2, $3)
      and (fe.created_at, fe.id) > ($4, $5)
order by
    case when $6::bool then (fe.created_at, fe.id) end asc,
    case when not $6::bool then (fe.created_at, fe.id) end desc
limit $7
`

type PaginatePersonalFeedByUserIDParams struct {
	Follower      persist.DBID `db:"follower" json:"follower"`
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
	Limit         int32        `db:"limit" json:"limit"`
}

func (q *Queries) PaginatePersonalFeedByUserID(ctx context.Context, arg PaginatePersonalFeedByUserIDParams) ([]FeedEntity, error) {
	rows, err := q.db.Query(ctx, paginatePersonalFeedByUserID,
		arg.Follower,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedEntity
	for rows.Next() {
		var i FeedEntity
		if err := rows.Scan(
			&i.ID,
			&i.FeedEntityType,
			&i.CreatedAt,
			&i.ActorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatePostsByContractIDAndProjectID = `-- name: PaginatePostsByContractIDAndProjectID :many
with valid_post_ids as (
    SELECT distinct on (posts.id) posts.id
    FROM posts
        JOIN tokens on tokens.id = ANY(posts.token_ids)
            and tokens.displayable
            and tokens.deleted = false
        JOIN token_definitions on token_definitions.id = tokens.token_definition_id
            and token_definitions.contract_id = $7
            and ('x' || lpad(substring(token_definitions.token_id, 1, 16), 16, '0'))::bit(64)::bigint / 1000000 = $8::int
            and token_definitions.deleted = false
    WHERE $7 = ANY(posts.contract_ids)
      AND posts.deleted = false
)
SELECT posts.id, posts.version, posts.token_ids, posts.contract_ids, posts.actor_id, posts.caption, posts.created_at, posts.last_updated, posts.deleted, posts.is_first_post, posts.user_mint_url from posts
    join valid_post_ids on posts.id = valid_post_ids.id
WHERE (posts.created_at, posts.id) < ($1, $2)
  AND (posts.created_at, posts.id) > ($3, $4)
ORDER BY
    CASE WHEN $5::bool THEN (posts.created_at, posts.id) END ASC,
    CASE WHEN NOT $5::bool THEN (posts.created_at, posts.id) END DESC
LIMIT $6
`

type PaginatePostsByContractIDAndProjectIDParams struct {
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
	Limit         int32        `db:"limit" json:"limit"`
	ContractID    persist.DBID `db:"contract_id" json:"contract_id"`
	ProjectIDInt  int32        `db:"project_id_int" json:"project_id_int"`
}

func (q *Queries) PaginatePostsByContractIDAndProjectID(ctx context.Context, arg PaginatePostsByContractIDAndProjectIDParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, paginatePostsByContractIDAndProjectID,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
		arg.Limit,
		arg.ContractID,
		arg.ProjectIDInt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.TokenIds,
			&i.ContractIds,
			&i.ActorID,
			&i.Caption,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.IsFirstPost,
			&i.UserMintUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatePostsByUserID = `-- name: PaginatePostsByUserID :many
select id, version, token_ids, contract_ids, actor_id, caption, created_at, last_updated, deleted, is_first_post, user_mint_url
from posts
where actor_id = $1
        and (created_at, id) < ($2, $3)
        and (created_at, id) > ($4, $5)
        and not posts.deleted
order by
    case when $6::bool then (created_at, id) end asc,
    case when not $6::bool then (created_at, id) end desc
limit $7
`

type PaginatePostsByUserIDParams struct {
	UserID        persist.DBID `db:"user_id" json:"user_id"`
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
	Limit         int32        `db:"limit" json:"limit"`
}

func (q *Queries) PaginatePostsByUserID(ctx context.Context, arg PaginatePostsByUserIDParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, paginatePostsByUserID,
		arg.UserID,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.TokenIds,
			&i.ContractIds,
			&i.ActorID,
			&i.Caption,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.IsFirstPost,
			&i.UserMintUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const redeemMerch = `-- name: RedeemMerch :one
update merch set redeemed = true, token_id = $1, last_updated = now() where id = (select m.id from merch m where m.object_type = $2 and m.token_id is null and m.redeemed = false and m.deleted = false order by m.id limit 1) and token_id is null and redeemed = false returning discount_code
`

type RedeemMerchParams struct {
	TokenHex   persist.HexTokenID `db:"token_hex" json:"token_hex"`
	ObjectType int32              `db:"object_type" json:"object_type"`
}

func (q *Queries) RedeemMerch(ctx context.Context, arg RedeemMerchParams) (sql.NullString, error) {
	row := q.db.QueryRow(ctx, redeemMerch, arg.TokenHex, arg.ObjectType)
	var discount_code sql.NullString
	err := row.Scan(&discount_code)
	return discount_code, err
}

const removeCollectionFromGallery = `-- name: RemoveCollectionFromGallery :exec
update galleries set collections = array_remove(collections, $1), last_updated = now() where id = $2 and deleted = false
`

type RemoveCollectionFromGalleryParams struct {
	CollectionID interface{}  `db:"collection_id" json:"collection_id"`
	GalleryID    persist.DBID `db:"gallery_id" json:"gallery_id"`
}

func (q *Queries) RemoveCollectionFromGallery(ctx context.Context, arg RemoveCollectionFromGalleryParams) error {
	_, err := q.db.Exec(ctx, removeCollectionFromGallery, arg.CollectionID, arg.GalleryID)
	return err
}

const removeComment = `-- name: RemoveComment :exec
UPDATE comments SET REMOVED = TRUE, COMMENT = 'comment removed' WHERE ID = $1
`

func (q *Queries) RemoveComment(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, removeComment, id)
	return err
}

const removeContractOverrideCreator = `-- name: RemoveContractOverrideCreator :exec
update contracts set override_creator_user_id = null, last_updated = now() where id = $1 and deleted = false
`

func (q *Queries) RemoveContractOverrideCreator(ctx context.Context, contractID persist.DBID) error {
	_, err := q.db.Exec(ctx, removeContractOverrideCreator, contractID)
	return err
}

const removeProfileImage = `-- name: RemoveProfileImage :exec
with remove_image as (
    update profile_images set deleted = true, last_updated = now() where user_id = $1 and not deleted
)
update users set profile_image_id = null where users.id = $1 and not users.deleted
`

func (q *Queries) RemoveProfileImage(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, removeProfileImage, id)
	return err
}

const removeSocialFromUser = `-- name: RemoveSocialFromUser :exec
update pii.for_users set pii_socials = pii_socials - $1::varchar where user_id = $2
`

type RemoveSocialFromUserParams struct {
	Social string       `db:"social" json:"social"`
	UserID persist.DBID `db:"user_id" json:"user_id"`
}

func (q *Queries) RemoveSocialFromUser(ctx context.Context, arg RemoveSocialFromUserParams) error {
	_, err := q.db.Exec(ctx, removeSocialFromUser, arg.Social, arg.UserID)
	return err
}

const removeStaleCreatorStatusFromTokens = `-- name: RemoveStaleCreatorStatusFromTokens :exec
with created_contracts as (
    select contract_id, creator_user_id, chain, creator_address from contract_creators where creator_user_id = $1
)
update tokens
    set is_creator_token = false,
        last_updated = now()
    where owner_user_id = $1
      and is_creator_token = true
      and not exists(select 1 from created_contracts where created_contracts.contract_id = tokens.contract_id)
      and not deleted
`

func (q *Queries) RemoveStaleCreatorStatusFromTokens(ctx context.Context, userID persist.DBID) error {
	_, err := q.db.Exec(ctx, removeStaleCreatorStatusFromTokens, userID)
	return err
}

const removeWalletFromTokens = `-- name: RemoveWalletFromTokens :exec
update tokens t
    set owned_by_wallets = array_remove(owned_by_wallets, $1::varchar),
        last_updated = now()
    from users u
    where u.id = $2
      and t.owner_user_id = u.id
      and t.owned_by_wallets @> array[$1::varchar]
      and not u.wallets @> array[$1::varchar]
      and not u.deleted
      and not t.deleted
`

type RemoveWalletFromTokensParams struct {
	WalletID string       `db:"wallet_id" json:"wallet_id"`
	UserID   persist.DBID `db:"user_id" json:"user_id"`
}

func (q *Queries) RemoveWalletFromTokens(ctx context.Context, arg RemoveWalletFromTokensParams) error {
	_, err := q.db.Exec(ctx, removeWalletFromTokens, arg.WalletID, arg.UserID)
	return err
}

const reportPost = `-- name: ReportPost :one
with offending_post as (select id from posts where posts.id = $4 and not deleted)
insert into reported_posts (id, post_id, reporter_id, reason) (select $1, offending_post.id, $2, $3 from offending_post)
on conflict(post_id, reporter_id, reason) where not deleted do update set last_updated = now() returning id
`

type ReportPostParams struct {
	ID       persist.DBID         `db:"id" json:"id"`
	Reporter sql.NullString       `db:"reporter" json:"reporter"`
	Reason   persist.ReportReason `db:"reason" json:"reason"`
	PostID   persist.DBID         `db:"post_id" json:"post_id"`
}

func (q *Queries) ReportPost(ctx context.Context, arg ReportPostParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, reportPost,
		arg.ID,
		arg.Reporter,
		arg.Reason,
		arg.PostID,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const saveHighlightMintClaim = `-- name: SaveHighlightMintClaim :one
insert into highlight_mint_claims(id, user_id, chain, contract_address, recipient_wallet_id, collection_id, claim_id, status, error_message) values ($1, $2, $3, $4, $5, $6, $7, $8, $9) returning id
`

type SaveHighlightMintClaimParams struct {
	ID                persist.DBID          `db:"id" json:"id"`
	UserID            persist.DBID          `db:"user_id" json:"user_id"`
	Chain             persist.Chain         `db:"chain" json:"chain"`
	ContractAddress   persist.Address       `db:"contract_address" json:"contract_address"`
	RecipientWalletID persist.DBID          `db:"recipient_wallet_id" json:"recipient_wallet_id"`
	CollectionID      string                `db:"collection_id" json:"collection_id"`
	ClaimID           sql.NullString        `db:"claim_id" json:"claim_id"`
	Status            highlight.ClaimStatus `db:"status" json:"status"`
	ErrorMessage      sql.NullString        `db:"error_message" json:"error_message"`
}

func (q *Queries) SaveHighlightMintClaim(ctx context.Context, arg SaveHighlightMintClaimParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, saveHighlightMintClaim,
		arg.ID,
		arg.UserID,
		arg.Chain,
		arg.ContractAddress,
		arg.RecipientWalletID,
		arg.CollectionID,
		arg.ClaimID,
		arg.Status,
		arg.ErrorMessage,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const setContractOverrideCreator = `-- name: SetContractOverrideCreator :exec
update contracts set override_creator_user_id = $1, last_updated = now() where id = $2 and deleted = false
`

type SetContractOverrideCreatorParams struct {
	CreatorUserID persist.DBID `db:"creator_user_id" json:"creator_user_id"`
	ContractID    persist.DBID `db:"contract_id" json:"contract_id"`
}

func (q *Queries) SetContractOverrideCreator(ctx context.Context, arg SetContractOverrideCreatorParams) error {
	_, err := q.db.Exec(ctx, setContractOverrideCreator, arg.CreatorUserID, arg.ContractID)
	return err
}

const setPersonaByUserID = `-- name: SetPersonaByUserID :exec
update users set persona = $1 where id = $2 and not deleted
`

type SetPersonaByUserIDParams struct {
	Persona persist.Persona `db:"persona" json:"persona"`
	UserID  persist.DBID    `db:"user_id" json:"user_id"`
}

func (q *Queries) SetPersonaByUserID(ctx context.Context, arg SetPersonaByUserIDParams) error {
	_, err := q.db.Exec(ctx, setPersonaByUserID, arg.Persona, arg.UserID)
	return err
}

const setPrivyDIDForUser = `-- name: SetPrivyDIDForUser :exec
insert into privy_users (id, user_id, privy_did)
    values ($1, $2, $3)
    on conflict (user_id) where not deleted do update set privy_did = excluded.privy_did, last_updated = now()
`

type SetPrivyDIDForUserParams struct {
	ID       persist.DBID `db:"id" json:"id"`
	UserID   persist.DBID `db:"user_id" json:"user_id"`
	PrivyDid string       `db:"privy_did" json:"privy_did"`
}

func (q *Queries) SetPrivyDIDForUser(ctx context.Context, arg SetPrivyDIDForUserParams) error {
	_, err := q.db.Exec(ctx, setPrivyDIDForUser, arg.ID, arg.UserID, arg.PrivyDid)
	return err
}

const setProfileImageToENS = `-- name: SetProfileImageToENS :one
with profile_images as (
    insert into profile_images (id, user_id, source_type, wallet_id, ens_domain, ens_avatar_uri, deleted, last_updated)
    values ($2, $1, $3, $4, $5, $6, false, now())
    on conflict (user_id) do update set wallet_id = excluded.wallet_id
        , ens_domain = excluded.ens_domain
        , ens_avatar_uri = excluded.ens_avatar_uri
        , source_type = excluded.source_type
        , deleted = excluded.deleted
        , last_updated = excluded.last_updated
    returning id, user_id, token_id, source_type, deleted, created_at, last_updated, wallet_id, ens_avatar_uri, ens_domain
)
update users set profile_image_id = profile_images.id from profile_images where users.id = $1 and not users.deleted returning profile_images.id, profile_images.user_id, profile_images.token_id, profile_images.source_type, profile_images.deleted, profile_images.created_at, profile_images.last_updated, profile_images.wallet_id, profile_images.ens_avatar_uri, profile_images.ens_domain
`

type SetProfileImageToENSParams struct {
	UserID        persist.DBID               `db:"user_id" json:"user_id"`
	ProfileID     persist.DBID               `db:"profile_id" json:"profile_id"`
	EnsSourceType persist.ProfileImageSource `db:"ens_source_type" json:"ens_source_type"`
	WalletID      persist.DBID               `db:"wallet_id" json:"wallet_id"`
	EnsDomain     sql.NullString             `db:"ens_domain" json:"ens_domain"`
	EnsAvatarUri  sql.NullString             `db:"ens_avatar_uri" json:"ens_avatar_uri"`
}

type SetProfileImageToENSRow struct {
	ProfileImage ProfileImage `db:"profileimage" json:"profileimage"`
}

func (q *Queries) SetProfileImageToENS(ctx context.Context, arg SetProfileImageToENSParams) (SetProfileImageToENSRow, error) {
	row := q.db.QueryRow(ctx, setProfileImageToENS,
		arg.UserID,
		arg.ProfileID,
		arg.EnsSourceType,
		arg.WalletID,
		arg.EnsDomain,
		arg.EnsAvatarUri,
	)
	var i SetProfileImageToENSRow
	err := row.Scan(
		&i.ProfileImage.ID,
		&i.ProfileImage.UserID,
		&i.ProfileImage.TokenID,
		&i.ProfileImage.SourceType,
		&i.ProfileImage.Deleted,
		&i.ProfileImage.CreatedAt,
		&i.ProfileImage.LastUpdated,
		&i.ProfileImage.WalletID,
		&i.ProfileImage.EnsAvatarUri,
		&i.ProfileImage.EnsDomain,
	)
	return i, err
}

const setProfileImageToToken = `-- name: SetProfileImageToToken :exec
with new_image as (
    insert into profile_images (id, user_id, source_type, token_id, deleted, last_updated)
    values ($2, $1, $3, $4, false, now())
    on conflict (user_id) do update set token_id = excluded.token_id
        , source_type = excluded.source_type
        , deleted = excluded.deleted
        , last_updated = excluded.last_updated
    returning id
)
update users set profile_image_id = new_image.id from new_image where users.id = $1 and not deleted
`

type SetProfileImageToTokenParams struct {
	UserID          persist.DBID               `db:"user_id" json:"user_id"`
	ProfileID       persist.DBID               `db:"profile_id" json:"profile_id"`
	TokenSourceType persist.ProfileImageSource `db:"token_source_type" json:"token_source_type"`
	TokenID         persist.DBID               `db:"token_id" json:"token_id"`
}

func (q *Queries) SetProfileImageToToken(ctx context.Context, arg SetProfileImageToTokenParams) error {
	_, err := q.db.Exec(ctx, setProfileImageToToken,
		arg.UserID,
		arg.ProfileID,
		arg.TokenSourceType,
		arg.TokenID,
	)
	return err
}

const unblockUser = `-- name: UnblockUser :exec
update user_blocklist set active = false, last_updated = now() where user_id = $1 and blocked_user_id = $2 and not deleted
`

type UnblockUserParams struct {
	UserID        persist.DBID `db:"user_id" json:"user_id"`
	BlockedUserID persist.DBID `db:"blocked_user_id" json:"blocked_user_id"`
}

func (q *Queries) UnblockUser(ctx context.Context, arg UnblockUserParams) error {
	_, err := q.db.Exec(ctx, unblockUser, arg.UserID, arg.BlockedUserID)
	return err
}

const unblockUserFromFeed = `-- name: UnblockUserFromFeed :exec
update feed_blocklist set active = false where user_id = $1 and not deleted
`

func (q *Queries) UnblockUserFromFeed(ctx context.Context, userID persist.DBID) error {
	_, err := q.db.Exec(ctx, unblockUserFromFeed, userID)
	return err
}

const updateCollectionGallery = `-- name: UpdateCollectionGallery :exec
update collections set gallery_id = $1, last_updated = now() where id = $2 and deleted = false
`

type UpdateCollectionGalleryParams struct {
	GalleryID persist.DBID `db:"gallery_id" json:"gallery_id"`
	ID        persist.DBID `db:"id" json:"id"`
}

func (q *Queries) UpdateCollectionGallery(ctx context.Context, arg UpdateCollectionGalleryParams) error {
	_, err := q.db.Exec(ctx, updateCollectionGallery, arg.GalleryID, arg.ID)
	return err
}

const updateCollectionTokens = `-- name: UpdateCollectionTokens :exec
update collections set nfts = $1, last_updated = now() where id = $2 and deleted = false
`

type UpdateCollectionTokensParams struct {
	Nfts persist.DBIDList `db:"nfts" json:"nfts"`
	ID   persist.DBID     `db:"id" json:"id"`
}

func (q *Queries) UpdateCollectionTokens(ctx context.Context, arg UpdateCollectionTokensParams) error {
	_, err := q.db.Exec(ctx, updateCollectionTokens, arg.Nfts, arg.ID)
	return err
}

const updateCollectionsInfo = `-- name: UpdateCollectionsInfo :exec
with updates as (
    select unnest($1::varchar[]) as id, unnest($2::varchar[]) as name, unnest($3::varchar[]) as collectors_note, unnest($4::jsonb[]) as layout, unnest($5::jsonb[]) as token_settings, unnest($6::bool[]) as hidden
)
update collections c set collectors_note = updates.collectors_note, layout = updates.layout, token_settings = updates.token_settings, hidden = updates.hidden, name = updates.name, last_updated = now(), version = 1 from updates where c.id = updates.id and c.deleted = false
`

type UpdateCollectionsInfoParams struct {
	Ids             []string       `db:"ids" json:"ids"`
	Names           []string       `db:"names" json:"names"`
	CollectorsNotes []string       `db:"collectors_notes" json:"collectors_notes"`
	Layouts         []pgtype.JSONB `db:"layouts" json:"layouts"`
	TokenSettings   []pgtype.JSONB `db:"token_settings" json:"token_settings"`
	Hidden          []bool         `db:"hidden" json:"hidden"`
}

func (q *Queries) UpdateCollectionsInfo(ctx context.Context, arg UpdateCollectionsInfoParams) error {
	_, err := q.db.Exec(ctx, updateCollectionsInfo,
		arg.Ids,
		arg.Names,
		arg.CollectorsNotes,
		arg.Layouts,
		arg.TokenSettings,
		arg.Hidden,
	)
	return err
}

const updateEventCaptionByGroup = `-- name: UpdateEventCaptionByGroup :exec
update events set caption = $1 where group_id = $2 and deleted = false
`

type UpdateEventCaptionByGroupParams struct {
	Caption sql.NullString `db:"caption" json:"caption"`
	GroupID sql.NullString `db:"group_id" json:"group_id"`
}

func (q *Queries) UpdateEventCaptionByGroup(ctx context.Context, arg UpdateEventCaptionByGroupParams) error {
	_, err := q.db.Exec(ctx, updateEventCaptionByGroup, arg.Caption, arg.GroupID)
	return err
}

const updateFeedEventCaptionByGroup = `-- name: UpdateFeedEventCaptionByGroup :one
UPDATE feed_events SET caption = (select caption from events where events.group_id = $1) WHERE group_id = $1 AND deleted = false returning id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption, group_id
`

func (q *Queries) UpdateFeedEventCaptionByGroup(ctx context.Context, groupID sql.NullString) (FeedEvent, error) {
	row := q.db.QueryRow(ctx, updateFeedEventCaptionByGroup, groupID)
	var i FeedEvent
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.OwnerID,
		&i.Action,
		&i.Data,
		&i.EventTime,
		&i.EventIds,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const updateGalleryCollections = `-- name: UpdateGalleryCollections :exec
update galleries set collections = $1, last_updated = now() where galleries.id = $2 and galleries.deleted = false and (select count(*) from collections c where c.id = any($1) and c.gallery_id = $2 and c.deleted = false) = cardinality($1)
`

type UpdateGalleryCollectionsParams struct {
	Collections persist.DBIDList `db:"collections" json:"collections"`
	GalleryID   persist.DBID     `db:"gallery_id" json:"gallery_id"`
}

func (q *Queries) UpdateGalleryCollections(ctx context.Context, arg UpdateGalleryCollectionsParams) error {
	_, err := q.db.Exec(ctx, updateGalleryCollections, arg.Collections, arg.GalleryID)
	return err
}

const updateGalleryHidden = `-- name: UpdateGalleryHidden :one
update galleries set hidden = $1, last_updated = now() where id = $2 and deleted = false returning id, deleted, last_updated, created_at, version, owner_user_id, collections, name, description, hidden, position
`

type UpdateGalleryHiddenParams struct {
	Hidden bool         `db:"hidden" json:"hidden"`
	ID     persist.DBID `db:"id" json:"id"`
}

func (q *Queries) UpdateGalleryHidden(ctx context.Context, arg UpdateGalleryHiddenParams) (Gallery, error) {
	row := q.db.QueryRow(ctx, updateGalleryHidden, arg.Hidden, arg.ID)
	var i Gallery
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Version,
		&i.OwnerUserID,
		&i.Collections,
		&i.Name,
		&i.Description,
		&i.Hidden,
		&i.Position,
	)
	return i, err
}

const updateGalleryInfo = `-- name: UpdateGalleryInfo :exec
update galleries set name = case when $1::bool then $2 else name end, description = case when $3::bool then $4 else description end, last_updated = now() where id = $5 and deleted = false
`

type UpdateGalleryInfoParams struct {
	NameSet        bool         `db:"name_set" json:"name_set"`
	Name           string       `db:"name" json:"name"`
	DescriptionSet bool         `db:"description_set" json:"description_set"`
	Description    string       `db:"description" json:"description"`
	ID             persist.DBID `db:"id" json:"id"`
}

func (q *Queries) UpdateGalleryInfo(ctx context.Context, arg UpdateGalleryInfoParams) error {
	_, err := q.db.Exec(ctx, updateGalleryInfo,
		arg.NameSet,
		arg.Name,
		arg.DescriptionSet,
		arg.Description,
		arg.ID,
	)
	return err
}

const updateGalleryPositions = `-- name: UpdateGalleryPositions :exec
with updates as (
    select unnest($2::text[]) as id, unnest($3::text[]) as position
)
update galleries g set position = updates.position, last_updated = now() from updates where g.id = updates.id and deleted = false and g.owner_user_id = $1
`

type UpdateGalleryPositionsParams struct {
	OwnerUserID persist.DBID `db:"owner_user_id" json:"owner_user_id"`
	GalleryIds  []string     `db:"gallery_ids" json:"gallery_ids"`
	Positions   []string     `db:"positions" json:"positions"`
}

func (q *Queries) UpdateGalleryPositions(ctx context.Context, arg UpdateGalleryPositionsParams) error {
	_, err := q.db.Exec(ctx, updateGalleryPositions, arg.OwnerUserID, arg.GalleryIds, arg.Positions)
	return err
}

const updateHighlightMintClaimStatus = `-- name: UpdateHighlightMintClaimStatus :exec
update highlight_mint_claims set last_updated = now(), status = $1, error_message = $2 where id = $3
`

type UpdateHighlightMintClaimStatusParams struct {
	Status       highlight.ClaimStatus `db:"status" json:"status"`
	ErrorMessage sql.NullString        `db:"error_message" json:"error_message"`
	ID           persist.DBID          `db:"id" json:"id"`
}

func (q *Queries) UpdateHighlightMintClaimStatus(ctx context.Context, arg UpdateHighlightMintClaimStatusParams) error {
	_, err := q.db.Exec(ctx, updateHighlightMintClaimStatus, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}

const updateHighlightMintClaimStatusCompleted = `-- name: UpdateHighlightMintClaimStatusCompleted :exec
update highlight_mint_claims set last_updated = now(), status = $1, token_id = $2, error_message = null where id = $3
`

type UpdateHighlightMintClaimStatusCompletedParams struct {
	Status  highlight.ClaimStatus `db:"status" json:"status"`
	TokenID persist.DBID          `db:"token_id" json:"token_id"`
	ID      persist.DBID          `db:"id" json:"id"`
}

func (q *Queries) UpdateHighlightMintClaimStatusCompleted(ctx context.Context, arg UpdateHighlightMintClaimStatusCompletedParams) error {
	_, err := q.db.Exec(ctx, updateHighlightMintClaimStatusCompleted, arg.Status, arg.TokenID, arg.ID)
	return err
}

const updateNotification = `-- name: UpdateNotification :exec
UPDATE notifications SET data = $2, event_ids = event_ids || $3, amount = $4, last_updated = now(), seen = false WHERE id = $1 AND deleted = false AND NOT amount = $4
`

type UpdateNotificationParams struct {
	ID       persist.DBID             `db:"id" json:"id"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
	Amount   int32                    `db:"amount" json:"amount"`
}

func (q *Queries) UpdateNotification(ctx context.Context, arg UpdateNotificationParams) error {
	_, err := q.db.Exec(ctx, updateNotification,
		arg.ID,
		arg.Data,
		arg.EventIds,
		arg.Amount,
	)
	return err
}

const updateNotificationSettingsByID = `-- name: UpdateNotificationSettingsByID :exec
UPDATE users SET notification_settings = $2 WHERE id = $1
`

type UpdateNotificationSettingsByIDParams struct {
	ID                   persist.DBID                     `db:"id" json:"id"`
	NotificationSettings persist.UserNotificationSettings `db:"notification_settings" json:"notification_settings"`
}

func (q *Queries) UpdateNotificationSettingsByID(ctx context.Context, arg UpdateNotificationSettingsByIDParams) error {
	_, err := q.db.Exec(ctx, updateNotificationSettingsByID, arg.ID, arg.NotificationSettings)
	return err
}

const updatePushTickets = `-- name: UpdatePushTickets :exec
with updates as (
    select unnest($1::text[]) as id, unnest($2::timestamptz[]) as check_after, unnest($3::int[]) as num_check_attempts, unnest($4::text[]) as status, unnest($5::bool[]) as deleted
)
update push_notification_tickets t set check_after = updates.check_after, num_check_attempts = updates.num_check_attempts, status = updates.status, deleted = updates.deleted from updates where t.id = updates.id and t.deleted = false
`

type UpdatePushTicketsParams struct {
	Ids              []string    `db:"ids" json:"ids"`
	CheckAfter       []time.Time `db:"check_after" json:"check_after"`
	NumCheckAttempts []int32     `db:"num_check_attempts" json:"num_check_attempts"`
	Status           []string    `db:"status" json:"status"`
	Deleted          []bool      `db:"deleted" json:"deleted"`
}

func (q *Queries) UpdatePushTickets(ctx context.Context, arg UpdatePushTicketsParams) error {
	_, err := q.db.Exec(ctx, updatePushTickets,
		arg.Ids,
		arg.CheckAfter,
		arg.NumCheckAttempts,
		arg.Status,
		arg.Deleted,
	)
	return err
}

const updateTokenCollectorsNoteByTokenDbidUserId = `-- name: UpdateTokenCollectorsNoteByTokenDbidUserId :exec
update tokens set collectors_note = $1, last_updated = now() where id = $2 and owner_user_id = $3
`

type UpdateTokenCollectorsNoteByTokenDbidUserIdParams struct {
	CollectorsNote sql.NullString `db:"collectors_note" json:"collectors_note"`
	ID             persist.DBID   `db:"id" json:"id"`
	OwnerUserID    persist.DBID   `db:"owner_user_id" json:"owner_user_id"`
}

func (q *Queries) UpdateTokenCollectorsNoteByTokenDbidUserId(ctx context.Context, arg UpdateTokenCollectorsNoteByTokenDbidUserIdParams) error {
	_, err := q.db.Exec(ctx, updateTokenCollectorsNoteByTokenDbidUserId, arg.CollectorsNote, arg.ID, arg.OwnerUserID)
	return err
}

const updateTokenMetadataFieldsByTokenIdentifiers = `-- name: UpdateTokenMetadataFieldsByTokenIdentifiers :one
update token_definitions
set name = $1,
    description = $2,
    last_updated = now()
where token_id = $3
    and contract_id = $4
    and chain = $5
    and deleted = false
returning id, created_at, last_updated, deleted, name, description, token_type, token_id, external_url, chain, metadata, fallback_media, contract_address, contract_id, token_media_id, is_fxhash
`

type UpdateTokenMetadataFieldsByTokenIdentifiersParams struct {
	Name        sql.NullString     `db:"name" json:"name"`
	Description sql.NullString     `db:"description" json:"description"`
	TokenID     persist.HexTokenID `db:"token_id" json:"token_id"`
	ContractID  persist.DBID       `db:"contract_id" json:"contract_id"`
	Chain       persist.Chain      `db:"chain" json:"chain"`
}

func (q *Queries) UpdateTokenMetadataFieldsByTokenIdentifiers(ctx context.Context, arg UpdateTokenMetadataFieldsByTokenIdentifiersParams) (TokenDefinition, error) {
	row := q.db.QueryRow(ctx, updateTokenMetadataFieldsByTokenIdentifiers,
		arg.Name,
		arg.Description,
		arg.TokenID,
		arg.ContractID,
		arg.Chain,
	)
	var i TokenDefinition
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Name,
		&i.Description,
		&i.TokenType,
		&i.TokenID,
		&i.ExternalUrl,
		&i.Chain,
		&i.Metadata,
		&i.FallbackMedia,
		&i.ContractAddress,
		&i.ContractID,
		&i.TokenMediaID,
		&i.IsFxhash,
	)
	return i, err
}

const updateTokensAsUserMarkedSpam = `-- name: UpdateTokensAsUserMarkedSpam :exec
update tokens set is_user_marked_spam = $1, last_updated = now() where owner_user_id = $2 and id = any($3) and deleted = false
`

type UpdateTokensAsUserMarkedSpamParams struct {
	IsUserMarkedSpam sql.NullBool     `db:"is_user_marked_spam" json:"is_user_marked_spam"`
	OwnerUserID      persist.DBID     `db:"owner_user_id" json:"owner_user_id"`
	TokenIds         persist.DBIDList `db:"token_ids" json:"token_ids"`
}

func (q *Queries) UpdateTokensAsUserMarkedSpam(ctx context.Context, arg UpdateTokensAsUserMarkedSpamParams) error {
	_, err := q.db.Exec(ctx, updateTokensAsUserMarkedSpam, arg.IsUserMarkedSpam, arg.OwnerUserID, arg.TokenIds)
	return err
}

const updateTopActiveUsers = `-- name: UpdateTopActiveUsers :exec
UPDATE users
SET traits = CASE 
                WHEN id = ANY($1) THEN 
                    COALESCE(traits, '{}'::jsonb) || '{"top_activity": true}'::jsonb
                ELSE 
                    traits - 'top_activity'
             END
WHERE id = ANY($1) OR traits ? 'top_activity'
`

func (q *Queries) UpdateTopActiveUsers(ctx context.Context, topUserIds persist.DBIDList) error {
	_, err := q.db.Exec(ctx, updateTopActiveUsers, topUserIds)
	return err
}

const updateUserEmailUnsubscriptions = `-- name: UpdateUserEmailUnsubscriptions :exec
UPDATE users SET email_unsubscriptions = $2 WHERE id = $1
`

type UpdateUserEmailUnsubscriptionsParams struct {
	ID                   persist.DBID                 `db:"id" json:"id"`
	EmailUnsubscriptions persist.EmailUnsubscriptions `db:"email_unsubscriptions" json:"email_unsubscriptions"`
}

func (q *Queries) UpdateUserEmailUnsubscriptions(ctx context.Context, arg UpdateUserEmailUnsubscriptionsParams) error {
	_, err := q.db.Exec(ctx, updateUserEmailUnsubscriptions, arg.ID, arg.EmailUnsubscriptions)
	return err
}

const updateUserExperience = `-- name: UpdateUserExperience :exec
update users set user_experiences = user_experiences || $1 where id = $2
`

type UpdateUserExperienceParams struct {
	Experience pgtype.JSONB `db:"experience" json:"experience"`
	UserID     persist.DBID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUserExperience(ctx context.Context, arg UpdateUserExperienceParams) error {
	_, err := q.db.Exec(ctx, updateUserExperience, arg.Experience, arg.UserID)
	return err
}

const updateUserFeaturedGallery = `-- name: UpdateUserFeaturedGallery :exec
update users set featured_gallery = $1, last_updated = now() from galleries where users.id = $2 and galleries.id = $1 and galleries.owner_user_id = $2 and galleries.deleted = false
`

type UpdateUserFeaturedGalleryParams struct {
	GalleryID persist.DBID `db:"gallery_id" json:"gallery_id"`
	UserID    persist.DBID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUserFeaturedGallery(ctx context.Context, arg UpdateUserFeaturedGalleryParams) error {
	_, err := q.db.Exec(ctx, updateUserFeaturedGallery, arg.GalleryID, arg.UserID)
	return err
}

const updateUserPrimaryWallet = `-- name: UpdateUserPrimaryWallet :exec
update users set primary_wallet_id = $1 from wallets
    where users.id = $2 and wallets.id = $1
    and wallets.id = any(users.wallets) and wallets.deleted = false
`

type UpdateUserPrimaryWalletParams struct {
	WalletID persist.DBID `db:"wallet_id" json:"wallet_id"`
	UserID   persist.DBID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUserPrimaryWallet(ctx context.Context, arg UpdateUserPrimaryWalletParams) error {
	_, err := q.db.Exec(ctx, updateUserPrimaryWallet, arg.WalletID, arg.UserID)
	return err
}

const updateUserSocials = `-- name: UpdateUserSocials :exec
update pii.for_users set pii_socials = $1 where user_id = $2
`

type UpdateUserSocialsParams struct {
	Socials persist.Socials `db:"socials" json:"socials"`
	UserID  persist.DBID    `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUserSocials(ctx context.Context, arg UpdateUserSocialsParams) error {
	_, err := q.db.Exec(ctx, updateUserSocials, arg.Socials, arg.UserID)
	return err
}

const updateUserUnverifiedEmail = `-- name: UpdateUserUnverifiedEmail :exec
insert into pii.for_users (user_id, pii_unverified_email_address, pii_verified_email_address) values ($1, $2, null)
    on conflict (user_id) do update
        set pii_unverified_email_address = excluded.pii_unverified_email_address,
            pii_verified_email_address = excluded.pii_verified_email_address
`

type UpdateUserUnverifiedEmailParams struct {
	UserID       persist.DBID  `db:"user_id" json:"user_id"`
	EmailAddress persist.Email `db:"email_address" json:"email_address"`
}

func (q *Queries) UpdateUserUnverifiedEmail(ctx context.Context, arg UpdateUserUnverifiedEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserUnverifiedEmail, arg.UserID, arg.EmailAddress)
	return err
}

const updateUserVerifiedEmail = `-- name: UpdateUserVerifiedEmail :exec
insert into pii.for_users (user_id, pii_unverified_email_address, pii_verified_email_address) values ($1, null, $2)
    on conflict (user_id) do update
        set pii_verified_email_address = excluded.pii_verified_email_address,
            pii_unverified_email_address = excluded.pii_unverified_email_address
`

type UpdateUserVerifiedEmailParams struct {
	UserID       persist.DBID  `db:"user_id" json:"user_id"`
	EmailAddress persist.Email `db:"email_address" json:"email_address"`
}

func (q *Queries) UpdateUserVerifiedEmail(ctx context.Context, arg UpdateUserVerifiedEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserVerifiedEmail, arg.UserID, arg.EmailAddress)
	return err
}

const upsertSession = `-- name: UpsertSession :one
insert into sessions (id, user_id,
                      created_at, created_with_user_agent, created_with_platform, created_with_os,
                      last_refreshed, last_user_agent, last_platform, last_os, current_refresh_id, active_until, invalidated, last_updated, deleted)
    values ($1, $2, now(), $3, $4, $5, now(), $3, $4, $5, $6, $7, false, now(), false)
    on conflict (id) where deleted = false do update set
        last_refreshed = case when sessions.invalidated then sessions.last_refreshed else excluded.last_refreshed end,
        last_user_agent = case when sessions.invalidated then sessions.last_user_agent else excluded.last_user_agent end,
        last_platform = case when sessions.invalidated then sessions.last_platform else excluded.last_platform end,
        last_os = case when sessions.invalidated then sessions.last_os else excluded.last_os end,
        current_refresh_id = case when sessions.invalidated then sessions.current_refresh_id else excluded.current_refresh_id end,
        last_updated = case when sessions.invalidated then sessions.last_updated else excluded.last_updated end,
        active_until = case when sessions.invalidated then sessions.active_until else greatest(sessions.active_until, excluded.active_until) end
    returning id, user_id, created_at, created_with_user_agent, created_with_platform, created_with_os, last_refreshed, last_user_agent, last_platform, last_os, current_refresh_id, active_until, invalidated, last_updated, deleted
`

type UpsertSessionParams struct {
	ID               persist.DBID `db:"id" json:"id"`
	UserID           persist.DBID `db:"user_id" json:"user_id"`
	UserAgent        string       `db:"user_agent" json:"user_agent"`
	Platform         string       `db:"platform" json:"platform"`
	Os               string       `db:"os" json:"os"`
	CurrentRefreshID string       `db:"current_refresh_id" json:"current_refresh_id"`
	ActiveUntil      time.Time    `db:"active_until" json:"active_until"`
}

func (q *Queries) UpsertSession(ctx context.Context, arg UpsertSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, upsertSession,
		arg.ID,
		arg.UserID,
		arg.UserAgent,
		arg.Platform,
		arg.Os,
		arg.CurrentRefreshID,
		arg.ActiveUntil,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.CreatedWithUserAgent,
		&i.CreatedWithPlatform,
		&i.CreatedWithOs,
		&i.LastRefreshed,
		&i.LastUserAgent,
		&i.LastPlatform,
		&i.LastOs,
		&i.CurrentRefreshID,
		&i.ActiveUntil,
		&i.Invalidated,
		&i.LastUpdated,
		&i.Deleted,
	)
	return i, err
}

const upsertSocialOAuth = `-- name: UpsertSocialOAuth :exec
insert into pii.socials_auth (id, user_id, provider, access_token, refresh_token) values ($1, $2, $3, $4, $5) on conflict (user_id, provider) where deleted = false do update set access_token = $4, refresh_token = $5, last_updated = now()
`

type UpsertSocialOAuthParams struct {
	ID           persist.DBID           `db:"id" json:"id"`
	UserID       persist.DBID           `db:"user_id" json:"user_id"`
	Provider     persist.SocialProvider `db:"provider" json:"provider"`
	AccessToken  sql.NullString         `db:"access_token" json:"access_token"`
	RefreshToken sql.NullString         `db:"refresh_token" json:"refresh_token"`
}

func (q *Queries) UpsertSocialOAuth(ctx context.Context, arg UpsertSocialOAuthParams) error {
	_, err := q.db.Exec(ctx, upsertSocialOAuth,
		arg.ID,
		arg.UserID,
		arg.Provider,
		arg.AccessToken,
		arg.RefreshToken,
	)
	return err
}

const userHasDuplicateGalleryPositions = `-- name: UserHasDuplicateGalleryPositions :one
select exists(select position,count(*) from galleries where owner_user_id = $1 and deleted = false group by position having count(*) > 1)
`

func (q *Queries) UserHasDuplicateGalleryPositions(ctx context.Context, ownerUserID persist.DBID) (bool, error) {
	row := q.db.QueryRow(ctx, userHasDuplicateGalleryPositions, ownerUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userOwnsCollection = `-- name: UserOwnsCollection :one
select exists(select 1 from collections where id = $1 and owner_user_id = $2 and deleted = false)
`

type UserOwnsCollectionParams struct {
	ID          persist.DBID `db:"id" json:"id"`
	OwnerUserID persist.DBID `db:"owner_user_id" json:"owner_user_id"`
}

func (q *Queries) UserOwnsCollection(ctx context.Context, arg UserOwnsCollectionParams) (bool, error) {
	row := q.db.QueryRow(ctx, userOwnsCollection, arg.ID, arg.OwnerUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userOwnsGallery = `-- name: UserOwnsGallery :one
select exists(select 1 from galleries where id = $1 and owner_user_id = $2 and deleted = false)
`

type UserOwnsGalleryParams struct {
	ID          persist.DBID `db:"id" json:"id"`
	OwnerUserID persist.DBID `db:"owner_user_id" json:"owner_user_id"`
}

func (q *Queries) UserOwnsGallery(ctx context.Context, arg UserOwnsGalleryParams) (bool, error) {
	row := q.db.QueryRow(ctx, userOwnsGallery, arg.ID, arg.OwnerUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const usersFollowUser = `-- name: UsersFollowUser :many
select (follows.id is not null)::bool
from (
    select unnest($2::varchar[]) as id,
    generate_subscripts($2::varchar[], 1) as index
    ) user_ids
left join follows on follows.follower = user_ids.id and followee = $1 and not deleted
order by user_ids.index
`

type UsersFollowUserParams struct {
	Followee    persist.DBID `db:"followee" json:"followee"`
	FollowedIds []string     `db:"followed_ids" json:"followed_ids"`
}

func (q *Queries) UsersFollowUser(ctx context.Context, arg UsersFollowUserParams) ([]bool, error) {
	rows, err := q.db.Query(ctx, usersFollowUser, arg.Followee, arg.FollowedIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []bool
	for rows.Next() {
		var column_1 bool
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
