// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: recommend.sql

package coredb

import (
	"context"
	"time"

	"github.com/mikeydub/go-gallery/service/persist"
)

const getFollowEdgesByUserID = `-- name: GetFollowEdgesByUserID :many
select f.followee, f.last_updated from follows f where f.follower = $1 and f.deleted = false
`

type GetFollowEdgesByUserIDRow struct {
	Followee    persist.DBID
	LastUpdated time.Time
}

func (q *Queries) GetFollowEdgesByUserID(ctx context.Context, follower persist.DBID) ([]GetFollowEdgesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getFollowEdgesByUserID, follower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowEdgesByUserIDRow
	for rows.Next() {
		var i GetFollowEdgesByUserIDRow
		if err := rows.Scan(&i.Followee, &i.LastUpdated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowGraphSource = `-- name: GetFollowGraphSource :many
select
	follows.follower,
	follows.followee
from
	follows,
	users as followers,
	users as followees,
	-- only recommend users that have content displayed
	(
		select
			owner_user_id
		from collections
		where
			cardinality(nfts) > 0
		and hidden is false
		and deleted is false group by owner_user_id) displayed
where
	follows.follower = followers.id
	and followers.deleted is false
	and follows.followee = followees.id
	and followees.deleted is false
	and follows.deleted = false
	and followees.id = displayed.owner_user_id
`

type GetFollowGraphSourceRow struct {
	Follower persist.DBID
	Followee persist.DBID
}

func (q *Queries) GetFollowGraphSource(ctx context.Context) ([]GetFollowGraphSourceRow, error) {
	rows, err := q.db.Query(ctx, getFollowGraphSource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowGraphSourceRow
	for rows.Next() {
		var i GetFollowGraphSourceRow
		if err := rows.Scan(&i.Follower, &i.Followee); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRecommendedUserIDs = `-- name: GetTopRecommendedUserIDs :many
select recommended_user_id from top_recommended_users
`

func (q *Queries) GetTopRecommendedUserIDs(ctx context.Context) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, getTopRecommendedUserIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var recommended_user_id persist.DBID
		if err := rows.Scan(&recommended_user_id); err != nil {
			return nil, err
		}
		items = append(items, recommended_user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatedRecommendationResults = `-- name: UpdatedRecommendationResults :exec
insert into recommendation_results
(
  id
  , user_id
  , recommended_user_id
) (
  select
    unnest($1::varchar[])
    , unnest($2::varchar[])
    , unnest($3::varchar[])
)
on conflict (user_id, recommended_user_id, version) where deleted = false
do update set
  recommended_count = recommendation_results.recommended_count + 1,
  last_updated = now()
`

type UpdatedRecommendationResultsParams struct {
	ID                []string
	UserID            []string
	RecommendedUserID []string
}

func (q *Queries) UpdatedRecommendationResults(ctx context.Context, arg UpdatedRecommendationResultsParams) error {
	_, err := q.db.Exec(ctx, updatedRecommendationResults, arg.ID, arg.UserID, arg.RecommendedUserID)
	return err
}
