// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: recommend.sql

package coredb

import (
	"context"
	"time"

	"github.com/mikeydub/go-gallery/service/persist"
)

const feedEntityScoring = `-- name: FeedEntityScoring :many
with ids as (
    select id, feed_entity_type, created_at, actor_id
    from feed_entities fe
    where 
      fe.created_at >= $1
      and ($2::bool or fe.actor_id != $3::varchar)
      and ($4::bool or feed_entity_type != $5)
), selected_posts as (
    select
      ids.id,
      ids.feed_entity_type,
      ids.created_at,
      p.actor_id,
      p.contract_ids,
      count(distinct c.id) + count(distinct a.id) interactions
    from ids
    join posts p on p.id = ids.id and feed_entity_type = $5
    left join comments c on c.post_id = ids.id
    left join admires a on a.post_id = ids.id
    group by ids.id, ids.feed_entity_type, ids.created_at, p.actor_id, p.contract_ids
), feed_event_contract_ids as (
    select t.feed_event_id feed_event_id, array_agg(t.contract_id) contract_ids
    from (
      select f.id feed_event_id, c.id contract_id
      from ids,
        feed_events f,
        lateral jsonb_each((data->>'gallery_new_token_ids')::jsonb) x(key, value),
        jsonb_array_elements_text(x.value) tid(id),
        tokens t,
        contracts c
      where
        ids.id = f.id
        and feed_entity_type = $6
        and tid.id = t.id
        and c.id = t.contract
        and not t.deleted
        and not c.deleted
      group by 1, 2
    ) t
    group by 1
), selected_events as (
    select
      ids.id,
      ids.feed_entity_type,
      ids.created_at,
      ids.actor_id,
      feed_event_contract_ids.contract_ids,
      count(distinct c.id) + count(distinct a.id) interactions
    from ids
    join feed_events e on e.id = ids.id and feed_entity_type = $6
    left join comments c on c.feed_event_id = ids.id
    left join admires a on a.feed_event_id = ids.id
    left join feed_event_contract_ids on feed_event_contract_ids.feed_event_id = ids.id
    where not action = any($7::varchar[])
    group by ids.id, ids.feed_entity_type, ids.created_at, ids.actor_id, feed_event_contract_ids.contract_ids
)
select id, feed_entity_type, created_at, actor_id, contract_ids, interactions from selected_posts
union all
select id, feed_entity_type, created_at, actor_id, contract_ids, interactions from selected_events
`

type FeedEntityScoringParams struct {
	WindowEnd           time.Time `json:"window_end"`
	IncludeViewer       bool      `json:"include_viewer"`
	ViewerID            string    `json:"viewer_id"`
	IncludePosts        bool      `json:"include_posts"`
	PostEntityType      int32     `json:"post_entity_type"`
	FeedEventEntityType int32     `json:"feed_event_entity_type"`
	ExcludedFeedActions []string  `json:"excluded_feed_actions"`
}

type FeedEntityScoringRow struct {
	ID             persist.DBID     `json:"id"`
	FeedEntityType int32            `json:"feed_entity_type"`
	CreatedAt      time.Time        `json:"created_at"`
	ActorID        persist.DBID     `json:"actor_id"`
	ContractIds    persist.DBIDList `json:"contract_ids"`
	Interactions   int32            `json:"interactions"`
}

func (q *Queries) FeedEntityScoring(ctx context.Context, arg FeedEntityScoringParams) ([]FeedEntityScoringRow, error) {
	rows, err := q.db.Query(ctx, feedEntityScoring,
		arg.WindowEnd,
		arg.IncludeViewer,
		arg.ViewerID,
		arg.IncludePosts,
		arg.PostEntityType,
		arg.FeedEventEntityType,
		arg.ExcludedFeedActions,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedEntityScoringRow
	for rows.Next() {
		var i FeedEntityScoringRow
		if err := rows.Scan(
			&i.ID,
			&i.FeedEntityType,
			&i.CreatedAt,
			&i.ActorID,
			&i.ContractIds,
			&i.Interactions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContractLabels = `-- name: GetContractLabels :many
select user_id, contract_id, displayed
from owned_contracts
where contract_id not in (
  select id from contracts where chain || ':' || address = any($1::varchar[])
) and displayed
`

type GetContractLabelsRow struct {
	UserID     persist.DBID `json:"user_id"`
	ContractID persist.DBID `json:"contract_id"`
	Displayed  bool         `json:"displayed"`
}

func (q *Queries) GetContractLabels(ctx context.Context, excludedContracts []string) ([]GetContractLabelsRow, error) {
	rows, err := q.db.Query(ctx, getContractLabels, excludedContracts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContractLabelsRow
	for rows.Next() {
		var i GetContractLabelsRow
		if err := rows.Scan(&i.UserID, &i.ContractID, &i.Displayed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowEdgesByUserID = `-- name: GetFollowEdgesByUserID :many
select id, follower, followee, deleted, created_at, last_updated from follows f where f.follower = $1 and f.deleted = false
`

func (q *Queries) GetFollowEdgesByUserID(ctx context.Context, follower persist.DBID) ([]Follow, error) {
	rows, err := q.db.Query(ctx, getFollowEdgesByUserID, follower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Follow
	for rows.Next() {
		var i Follow
		if err := rows.Scan(
			&i.ID,
			&i.Follower,
			&i.Followee,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowGraphSource = `-- name: GetFollowGraphSource :many
select
  follows.follower,
  follows.followee
from
  follows,
  users as followers,
  users as followees,
  (
    select owner_user_id
    from collections
    where cardinality(nfts) > 0 and deleted = false
    group by owner_user_id
  ) displaying
where
  follows.follower = followers.id
  and follows.followee = displaying.owner_user_id
  and followers.deleted is false
  and follows.followee = followees.id
  and followees.deleted is false
  and follows.deleted = false
`

type GetFollowGraphSourceRow struct {
	Follower persist.DBID `json:"follower"`
	Followee persist.DBID `json:"followee"`
}

func (q *Queries) GetFollowGraphSource(ctx context.Context) ([]GetFollowGraphSourceRow, error) {
	rows, err := q.db.Query(ctx, getFollowGraphSource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowGraphSourceRow
	for rows.Next() {
		var i GetFollowGraphSourceRow
		if err := rows.Scan(&i.Follower, &i.Followee); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRecommendedUserIDs = `-- name: GetTopRecommendedUserIDs :many
select recommended_user_id from top_recommended_users
`

func (q *Queries) GetTopRecommendedUserIDs(ctx context.Context) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, getTopRecommendedUserIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var recommended_user_id persist.DBID
		if err := rows.Scan(&recommended_user_id); err != nil {
			return nil, err
		}
		items = append(items, recommended_user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLabels = `-- name: GetUserLabels :many
select follower id from follows where not deleted group by 1
union
select followee id from follows where not deleted group by 1
union
select user_id id from owned_contracts where displayed group by 1
`

func (q *Queries) GetUserLabels(ctx context.Context) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, getUserLabels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var id persist.DBID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatedRecommendationResults = `-- name: UpdatedRecommendationResults :exec
insert into recommendation_results
(
  id
  , user_id
  , recommended_user_id
  , recommended_count
) (
  select
    unnest($1::varchar[])
    , unnest($2::varchar[])
    , unnest($3::varchar[])
    , unnest($4::int[])
)
on conflict (user_id, recommended_user_id, version) where deleted = false
do update set
  recommended_count = recommendation_results.recommended_count + excluded.recommended_count,
  last_updated = now()
`

type UpdatedRecommendationResultsParams struct {
	ID                []string `json:"id"`
	UserID            []string `json:"user_id"`
	RecommendedUserID []string `json:"recommended_user_id"`
	RecommendedCount  []int32  `json:"recommended_count"`
}

func (q *Queries) UpdatedRecommendationResults(ctx context.Context, arg UpdatedRecommendationResultsParams) error {
	_, err := q.db.Exec(ctx, updatedRecommendationResults,
		arg.ID,
		arg.UserID,
		arg.RecommendedUserID,
		arg.RecommendedCount,
	)
	return err
}
