// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: batch.go
package coredb

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgx/v4"
	"github.com/mikeydub/go-gallery/service/persist"
)

const countAdmiresByFeedEventIDBatch = `-- name: CountAdmiresByFeedEventIDBatch :batchone
SELECT count(*) FROM admires WHERE feed_event_id = $1 AND deleted = false
`

type CountAdmiresByFeedEventIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) CountAdmiresByFeedEventIDBatch(ctx context.Context, feedEventID []persist.DBID) *CountAdmiresByFeedEventIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range feedEventID {
		vals := []interface{}{
			a,
		}
		batch.Queue(countAdmiresByFeedEventIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CountAdmiresByFeedEventIDBatchBatchResults{br, 0}
}

func (b *CountAdmiresByFeedEventIDBatchBatchResults) QueryRow(f func(int, int64, error)) {
	for {
		row := b.br.QueryRow()
		var count int64
		err := row.Scan(&count)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, count, err)
		}
		b.ind++
	}
}

func (b *CountAdmiresByFeedEventIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const countCommentsByFeedEventIDBatch = `-- name: CountCommentsByFeedEventIDBatch :batchone
SELECT count(*) FROM comments WHERE feed_event_id = $1 AND deleted = false
`

type CountCommentsByFeedEventIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) CountCommentsByFeedEventIDBatch(ctx context.Context, feedEventID []persist.DBID) *CountCommentsByFeedEventIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range feedEventID {
		vals := []interface{}{
			a,
		}
		batch.Queue(countCommentsByFeedEventIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CountCommentsByFeedEventIDBatchBatchResults{br, 0}
}

func (b *CountCommentsByFeedEventIDBatchBatchResults) QueryRow(f func(int, int64, error)) {
	for {
		row := b.br.QueryRow()
		var count int64
		err := row.Scan(&count)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, count, err)
		}
		b.ind++
	}
}

func (b *CountCommentsByFeedEventIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const countInteractionsByFeedEventIDBatch = `-- name: CountInteractionsByFeedEventIDBatch :batchmany
SELECT count(*), $2::int as tag FROM admires t WHERE $2 != 0 AND t.feed_event_id = $1 AND t.deleted = false
                                                        UNION
SELECT count(*), $3::int as tag FROM comments t WHERE $3 != 0 AND t.feed_event_id = $1 AND t.deleted = false
`

type CountInteractionsByFeedEventIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type CountInteractionsByFeedEventIDBatchParams struct {
	FeedEventID persist.DBID
	AdmireTag   int32
	CommentTag  int32
}

type CountInteractionsByFeedEventIDBatchRow struct {
	Count int64
	Tag   int32
}

func (q *Queries) CountInteractionsByFeedEventIDBatch(ctx context.Context, arg []CountInteractionsByFeedEventIDBatchParams) *CountInteractionsByFeedEventIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.FeedEventID,
			a.AdmireTag,
			a.CommentTag,
		}
		batch.Queue(countInteractionsByFeedEventIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CountInteractionsByFeedEventIDBatchBatchResults{br, 0}
}

func (b *CountInteractionsByFeedEventIDBatchBatchResults) Query(f func(int, []CountInteractionsByFeedEventIDBatchRow, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []CountInteractionsByFeedEventIDBatchRow
		for rows.Next() {
			var i CountInteractionsByFeedEventIDBatchRow
			if err := rows.Scan(&i.Count, &i.Tag); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *CountInteractionsByFeedEventIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getAdmireByActorIDAndFeedEventID = `-- name: GetAdmireByActorIDAndFeedEventID :batchone
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated FROM admires WHERE actor_id = $1 AND feed_event_id = $2 AND deleted = false
`

type GetAdmireByActorIDAndFeedEventIDBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetAdmireByActorIDAndFeedEventIDParams struct {
	ActorID     persist.DBID
	FeedEventID persist.DBID
}

func (q *Queries) GetAdmireByActorIDAndFeedEventID(ctx context.Context, arg []GetAdmireByActorIDAndFeedEventIDParams) *GetAdmireByActorIDAndFeedEventIDBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ActorID,
			a.FeedEventID,
		}
		batch.Queue(getAdmireByActorIDAndFeedEventID, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAdmireByActorIDAndFeedEventIDBatchResults{br, 0}
}

func (b *GetAdmireByActorIDAndFeedEventIDBatchResults) QueryRow(f func(int, Admire, error)) {
	for {
		row := b.br.QueryRow()
		var i Admire
		err := row.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetAdmireByActorIDAndFeedEventIDBatchResults) Close() error {
	return b.br.Close()
}

const getAdmireByAdmireIDBatch = `-- name: GetAdmireByAdmireIDBatch :batchone
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated FROM admires WHERE id = $1 AND deleted = false
`

type GetAdmireByAdmireIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetAdmireByAdmireIDBatch(ctx context.Context, id []persist.DBID) *GetAdmireByAdmireIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getAdmireByAdmireIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAdmireByAdmireIDBatchBatchResults{br, 0}
}

func (b *GetAdmireByAdmireIDBatchBatchResults) QueryRow(f func(int, Admire, error)) {
	for {
		row := b.br.QueryRow()
		var i Admire
		err := row.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetAdmireByAdmireIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getAdmiresByActorIDBatch = `-- name: GetAdmiresByActorIDBatch :batchmany
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated FROM admires WHERE actor_id = $1 AND deleted = false ORDER BY created_at DESC
`

type GetAdmiresByActorIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetAdmiresByActorIDBatch(ctx context.Context, actorID []persist.DBID) *GetAdmiresByActorIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range actorID {
		vals := []interface{}{
			a,
		}
		batch.Queue(getAdmiresByActorIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAdmiresByActorIDBatchBatchResults{br, 0}
}

func (b *GetAdmiresByActorIDBatchBatchResults) Query(f func(int, []Admire, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Admire
		for rows.Next() {
			var i Admire
			if err := rows.Scan(
				&i.ID,
				&i.Version,
				&i.FeedEventID,
				&i.ActorID,
				&i.Deleted,
				&i.CreatedAt,
				&i.LastUpdated,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetAdmiresByActorIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getCollectionByIdBatch = `-- name: GetCollectionByIdBatch :batchone
SELECT id, deleted, owner_user_id, nfts, version, last_updated, created_at, hidden, collectors_note, name, layout, token_settings FROM collections WHERE id = $1 AND deleted = false
`

type GetCollectionByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetCollectionByIdBatch(ctx context.Context, id []persist.DBID) *GetCollectionByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getCollectionByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetCollectionByIdBatchBatchResults{br, 0}
}

func (b *GetCollectionByIdBatchBatchResults) QueryRow(f func(int, Collection, error)) {
	for {
		row := b.br.QueryRow()
		var i Collection
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerUserID,
			&i.Nfts,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Hidden,
			&i.CollectorsNote,
			&i.Name,
			&i.Layout,
			&i.TokenSettings,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetCollectionByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getCollectionsByGalleryIdBatch = `-- name: GetCollectionsByGalleryIdBatch :batchmany
SELECT c.id, c.deleted, c.owner_user_id, c.nfts, c.version, c.last_updated, c.created_at, c.hidden, c.collectors_note, c.name, c.layout, c.token_settings FROM galleries g, unnest(g.collections)
    WITH ORDINALITY AS x(coll_id, coll_ord)
    INNER JOIN collections c ON c.id = x.coll_id
    WHERE g.id = $1 AND g.deleted = false AND c.deleted = false ORDER BY x.coll_ord
`

type GetCollectionsByGalleryIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetCollectionsByGalleryIdBatch(ctx context.Context, id []persist.DBID) *GetCollectionsByGalleryIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getCollectionsByGalleryIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetCollectionsByGalleryIdBatchBatchResults{br, 0}
}

func (b *GetCollectionsByGalleryIdBatchBatchResults) Query(f func(int, []Collection, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Collection
		for rows.Next() {
			var i Collection
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.OwnerUserID,
				&i.Nfts,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Hidden,
				&i.CollectorsNote,
				&i.Name,
				&i.Layout,
				&i.TokenSettings,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetCollectionsByGalleryIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getCommentByCommentIDBatch = `-- name: GetCommentByCommentIDBatch :batchone
SELECT id, version, feed_event_id, actor_id, reply_to, comment, deleted, created_at, last_updated FROM comments WHERE id = $1 AND deleted = false
`

type GetCommentByCommentIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetCommentByCommentIDBatch(ctx context.Context, id []persist.DBID) *GetCommentByCommentIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getCommentByCommentIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetCommentByCommentIDBatchBatchResults{br, 0}
}

func (b *GetCommentByCommentIDBatchBatchResults) QueryRow(f func(int, Comment, error)) {
	for {
		row := b.br.QueryRow()
		var i Comment
		err := row.Scan(
			&i.ID,
			&i.Version,
			&i.FeedEventID,
			&i.ActorID,
			&i.ReplyTo,
			&i.Comment,
			&i.Deleted,
			&i.CreatedAt,
			&i.LastUpdated,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetCommentByCommentIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getCommentsByActorIDBatch = `-- name: GetCommentsByActorIDBatch :batchmany
SELECT id, version, feed_event_id, actor_id, reply_to, comment, deleted, created_at, last_updated FROM comments WHERE actor_id = $1 AND deleted = false ORDER BY created_at DESC
`

type GetCommentsByActorIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetCommentsByActorIDBatch(ctx context.Context, actorID []persist.DBID) *GetCommentsByActorIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range actorID {
		vals := []interface{}{
			a,
		}
		batch.Queue(getCommentsByActorIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetCommentsByActorIDBatchBatchResults{br, 0}
}

func (b *GetCommentsByActorIDBatchBatchResults) Query(f func(int, []Comment, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Comment
		for rows.Next() {
			var i Comment
			if err := rows.Scan(
				&i.ID,
				&i.Version,
				&i.FeedEventID,
				&i.ActorID,
				&i.ReplyTo,
				&i.Comment,
				&i.Deleted,
				&i.CreatedAt,
				&i.LastUpdated,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetCommentsByActorIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getCommentsByFeedEventIDBatch = `-- name: GetCommentsByFeedEventIDBatch :batchmany
SELECT comments.id, comments.version, feed_event_id, actor_id, reply_to, comment, comments.deleted, comments.created_at, comments.last_updated, f.id, f.version, owner_id, action, data, event_time, event_ids, f.deleted, f.last_updated, f.created_at, caption FROM comments JOIN feed_events f on f.deleted = false AND f.id = $1 WHERE feed_event_id = $1 AND deleted = false ORDER BY created_at DESC
`

type GetCommentsByFeedEventIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetCommentsByFeedEventIDBatchRow struct {
	ID            persist.DBID
	Version       int32
	FeedEventID   persist.DBID
	ActorID       persist.DBID
	ReplyTo       persist.DBID
	Comment       string
	Deleted       bool
	CreatedAt     time.Time
	LastUpdated   time.Time
	ID_2          persist.DBID
	Version_2     int32
	OwnerID       persist.DBID
	Action        persist.Action
	Data          persist.FeedEventData
	EventTime     time.Time
	EventIds      persist.DBIDList
	Deleted_2     bool
	LastUpdated_2 time.Time
	CreatedAt_2   time.Time
	Caption       sql.NullString
}

func (q *Queries) GetCommentsByFeedEventIDBatch(ctx context.Context, id []persist.DBID) *GetCommentsByFeedEventIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getCommentsByFeedEventIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetCommentsByFeedEventIDBatchBatchResults{br, 0}
}

func (b *GetCommentsByFeedEventIDBatchBatchResults) Query(f func(int, []GetCommentsByFeedEventIDBatchRow, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []GetCommentsByFeedEventIDBatchRow
		for rows.Next() {
			var i GetCommentsByFeedEventIDBatchRow
			if err := rows.Scan(
				&i.ID,
				&i.Version,
				&i.FeedEventID,
				&i.ActorID,
				&i.ReplyTo,
				&i.Comment,
				&i.Deleted,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.ID_2,
				&i.Version_2,
				&i.OwnerID,
				&i.Action,
				&i.Data,
				&i.EventTime,
				&i.EventIds,
				&i.Deleted_2,
				&i.LastUpdated_2,
				&i.CreatedAt_2,
				&i.Caption,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetCommentsByFeedEventIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getContractByChainAddressBatch = `-- name: GetContractByChainAddressBatch :batchone
select id, deleted, version, created_at, last_updated, name, symbol, address, creator_address, chain, profile_banner_url, profile_image_url, badge_url, description FROM contracts WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetContractByChainAddressBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetContractByChainAddressBatchParams struct {
	Address persist.Address
	Chain   sql.NullInt32
}

func (q *Queries) GetContractByChainAddressBatch(ctx context.Context, arg []GetContractByChainAddressBatchParams) *GetContractByChainAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Address,
			a.Chain,
		}
		batch.Queue(getContractByChainAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetContractByChainAddressBatchBatchResults{br, 0}
}

func (b *GetContractByChainAddressBatchBatchResults) QueryRow(f func(int, Contract, error)) {
	for {
		row := b.br.QueryRow()
		var i Contract
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Address,
			&i.CreatorAddress,
			&i.Chain,
			&i.ProfileBannerUrl,
			&i.ProfileImageUrl,
			&i.BadgeUrl,
			&i.Description,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetContractByChainAddressBatchBatchResults) Close() error {
	return b.br.Close()
}

const getContractsByUserIDBatch = `-- name: GetContractsByUserIDBatch :batchmany
SELECT DISTINCT ON (contracts.id) contracts.id, contracts.deleted, contracts.version, contracts.created_at, contracts.last_updated, contracts.name, contracts.symbol, contracts.address, contracts.creator_address, contracts.chain, contracts.profile_banner_url, contracts.profile_image_url, contracts.badge_url, contracts.description FROM contracts, tokens
    WHERE tokens.owner_user_id = $1 AND tokens.contract = contracts.id
    AND tokens.deleted = false AND contracts.deleted = false
`

type GetContractsByUserIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetContractsByUserIDBatch(ctx context.Context, ownerUserID []persist.DBID) *GetContractsByUserIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range ownerUserID {
		vals := []interface{}{
			a,
		}
		batch.Queue(getContractsByUserIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetContractsByUserIDBatchBatchResults{br, 0}
}

func (b *GetContractsByUserIDBatchBatchResults) Query(f func(int, []Contract, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Contract
		for rows.Next() {
			var i Contract
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Symbol,
				&i.Address,
				&i.CreatorAddress,
				&i.Chain,
				&i.ProfileBannerUrl,
				&i.ProfileImageUrl,
				&i.BadgeUrl,
				&i.Description,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetContractsByUserIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getContractsDisplayedByUserIDBatch = `-- name: GetContractsDisplayedByUserIDBatch :batchmany
SELECT DISTINCT ON (contracts.id) contracts.id, contracts.deleted, contracts.version, contracts.created_at, contracts.last_updated, contracts.name, contracts.symbol, contracts.address, contracts.creator_address, contracts.chain, contracts.profile_banner_url, contracts.profile_image_url, contracts.badge_url, contracts.description FROM contracts, tokens
JOIN collections c ON tokens.id = ANY(c.NFTS)
WHERE tokens.owner_user_id = $1 AND tokens.contract = contracts.id AND c.owner_user_id = tokens.owner_user_id
  AND tokens.deleted = false AND contracts.deleted = false
`

type GetContractsDisplayedByUserIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetContractsDisplayedByUserIDBatch(ctx context.Context, ownerUserID []persist.DBID) *GetContractsDisplayedByUserIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range ownerUserID {
		vals := []interface{}{
			a,
		}
		batch.Queue(getContractsDisplayedByUserIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetContractsDisplayedByUserIDBatchBatchResults{br, 0}
}

func (b *GetContractsDisplayedByUserIDBatchBatchResults) Query(f func(int, []Contract, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Contract
		for rows.Next() {
			var i Contract
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Symbol,
				&i.Address,
				&i.CreatorAddress,
				&i.Chain,
				&i.ProfileBannerUrl,
				&i.ProfileImageUrl,
				&i.BadgeUrl,
				&i.Description,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetContractsDisplayedByUserIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getEventByIdBatch = `-- name: GetEventByIdBatch :batchone
SELECT id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption FROM feed_events WHERE id = $1 AND deleted = false
`

type GetEventByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetEventByIdBatch(ctx context.Context, id []persist.DBID) *GetEventByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getEventByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetEventByIdBatchBatchResults{br, 0}
}

func (b *GetEventByIdBatchBatchResults) QueryRow(f func(int, FeedEvent, error)) {
	for {
		row := b.br.QueryRow()
		var i FeedEvent
		err := row.Scan(
			&i.ID,
			&i.Version,
			&i.OwnerID,
			&i.Action,
			&i.Data,
			&i.EventTime,
			&i.EventIds,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Caption,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetEventByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getFollowersByUserIdBatch = `-- name: GetFollowersByUserIdBatch :batchmany
SELECT u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings FROM follows f
    INNER JOIN users u ON f.follower = u.id
    WHERE f.followee = $1 AND f.deleted = false
    ORDER BY f.last_updated DESC
`

type GetFollowersByUserIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetFollowersByUserIdBatch(ctx context.Context, followee []persist.DBID) *GetFollowersByUserIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range followee {
		vals := []interface{}{
			a,
		}
		batch.Queue(getFollowersByUserIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetFollowersByUserIdBatchBatchResults{br, 0}
}

func (b *GetFollowersByUserIdBatchBatchResults) Query(f func(int, []User, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []User
		for rows.Next() {
			var i User
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Username,
				&i.UsernameIdempotent,
				&i.Wallets,
				&i.Bio,
				&i.Traits,
				&i.Universal,
				&i.NotificationSettings,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetFollowersByUserIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getFollowingByUserIdBatch = `-- name: GetFollowingByUserIdBatch :batchmany
SELECT u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings FROM follows f
    INNER JOIN users u ON f.followee = u.id
    WHERE f.follower = $1 AND f.deleted = false
    ORDER BY f.last_updated DESC
`

type GetFollowingByUserIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetFollowingByUserIdBatch(ctx context.Context, follower []persist.DBID) *GetFollowingByUserIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range follower {
		vals := []interface{}{
			a,
		}
		batch.Queue(getFollowingByUserIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetFollowingByUserIdBatchBatchResults{br, 0}
}

func (b *GetFollowingByUserIdBatchBatchResults) Query(f func(int, []User, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []User
		for rows.Next() {
			var i User
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Username,
				&i.UsernameIdempotent,
				&i.Wallets,
				&i.Bio,
				&i.Traits,
				&i.Universal,
				&i.NotificationSettings,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetFollowingByUserIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getGalleriesByUserIdBatch = `-- name: GetGalleriesByUserIdBatch :batchmany
SELECT id, deleted, last_updated, created_at, version, owner_user_id, collections FROM galleries WHERE owner_user_id = $1 AND deleted = false
`

type GetGalleriesByUserIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetGalleriesByUserIdBatch(ctx context.Context, ownerUserID []persist.DBID) *GetGalleriesByUserIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range ownerUserID {
		vals := []interface{}{
			a,
		}
		batch.Queue(getGalleriesByUserIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetGalleriesByUserIdBatchBatchResults{br, 0}
}

func (b *GetGalleriesByUserIdBatchBatchResults) Query(f func(int, []Gallery, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Gallery
		for rows.Next() {
			var i Gallery
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Version,
				&i.OwnerUserID,
				&i.Collections,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetGalleriesByUserIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getGalleryByCollectionIdBatch = `-- name: GetGalleryByCollectionIdBatch :batchone
SELECT g.id, g.deleted, g.last_updated, g.created_at, g.version, g.owner_user_id, g.collections FROM galleries g, collections c WHERE c.id = $1 AND c.deleted = false AND $1 = ANY(g.collections) AND g.deleted = false
`

type GetGalleryByCollectionIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetGalleryByCollectionIdBatch(ctx context.Context, id []persist.DBID) *GetGalleryByCollectionIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getGalleryByCollectionIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetGalleryByCollectionIdBatchBatchResults{br, 0}
}

func (b *GetGalleryByCollectionIdBatchBatchResults) QueryRow(f func(int, Gallery, error)) {
	for {
		row := b.br.QueryRow()
		var i Gallery
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Version,
			&i.OwnerUserID,
			&i.Collections,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetGalleryByCollectionIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getGalleryByIdBatch = `-- name: GetGalleryByIdBatch :batchone
SELECT id, deleted, last_updated, created_at, version, owner_user_id, collections FROM galleries WHERE id = $1 AND deleted = false
`

type GetGalleryByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetGalleryByIdBatch(ctx context.Context, id []persist.DBID) *GetGalleryByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getGalleryByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetGalleryByIdBatchBatchResults{br, 0}
}

func (b *GetGalleryByIdBatchBatchResults) QueryRow(f func(int, Gallery, error)) {
	for {
		row := b.br.QueryRow()
		var i Gallery
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Version,
			&i.OwnerUserID,
			&i.Collections,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetGalleryByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getMembershipByMembershipIdBatch = `-- name: GetMembershipByMembershipIdBatch :batchone
SELECT id, deleted, version, created_at, last_updated, token_id, name, asset_url, owners FROM membership WHERE id = $1 AND deleted = false
`

type GetMembershipByMembershipIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetMembershipByMembershipIdBatch(ctx context.Context, id []persist.DBID) *GetMembershipByMembershipIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getMembershipByMembershipIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetMembershipByMembershipIdBatchBatchResults{br, 0}
}

func (b *GetMembershipByMembershipIdBatchBatchResults) QueryRow(f func(int, Membership, error)) {
	for {
		row := b.br.QueryRow()
		var i Membership
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.TokenID,
			&i.Name,
			&i.AssetUrl,
			&i.Owners,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetMembershipByMembershipIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getNewTokensByFeedEventIdBatch = `-- name: GetNewTokensByFeedEventIdBatch :batchmany
WITH new_tokens AS (
    SELECT added.id, row_number() OVER () added_order
    FROM (SELECT jsonb_array_elements_text(data -> 'collection_new_token_ids') id FROM feed_events f WHERE f.id = $1 AND f.deleted = false) added
)
SELECT t.id, t.deleted, t.version, t.created_at, t.last_updated, t.name, t.description, t.collectors_note, t.media, t.token_uri, t.token_type, t.token_id, t.quantity, t.ownership_history, t.token_metadata, t.external_url, t.block_number, t.owner_user_id, t.owned_by_wallets, t.chain, t.contract, t.is_user_marked_spam, t.is_provider_marked_spam FROM new_tokens a JOIN tokens t ON a.id = t.id AND t.deleted = false ORDER BY a.added_order
`

type GetNewTokensByFeedEventIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetNewTokensByFeedEventIdBatch(ctx context.Context, id []persist.DBID) *GetNewTokensByFeedEventIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getNewTokensByFeedEventIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetNewTokensByFeedEventIdBatchBatchResults{br, 0}
}

func (b *GetNewTokensByFeedEventIdBatchBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.Media,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnedByWallets,
				&i.Chain,
				&i.Contract,
				&i.IsUserMarkedSpam,
				&i.IsProviderMarkedSpam,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetNewTokensByFeedEventIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getNotificationByIDBatch = `-- name: GetNotificationByIDBatch :batchone
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount FROM notifications WHERE id = $1 AND deleted = false
`

type GetNotificationByIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetNotificationByIDBatch(ctx context.Context, id []persist.DBID) *GetNotificationByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getNotificationByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetNotificationByIDBatchBatchResults{br, 0}
}

func (b *GetNotificationByIDBatchBatchResults) QueryRow(f func(int, Notification, error)) {
	for {
		row := b.br.QueryRow()
		var i Notification
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.FeedEventID,
			&i.CommentID,
			&i.GalleryID,
			&i.Seen,
			&i.Amount,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetNotificationByIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getOwnersByContractIdBatchPaginate = `-- name: GetOwnersByContractIdBatchPaginate :batchmany
SELECT DISTINCT ON (result.id) result.id, result.deleted, result.version, result.last_updated, result.created_at, result.username, result.username_idempotent, result.wallets, result.bio, result.traits, result.universal, result.notification_settings FROM (SELECT users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings FROM users, tokens
    WHERE tokens.contract = $1 AND tokens.owner_user_id = users.id
    AND (NOT $3::bool OR users.universal = false)
    AND tokens.deleted = false AND users.deleted = false
    AND (users.universal,users.created_at,users.id) < ($4, $5::timestamptz, $6)
    AND (users.universal,users.created_at,users.id) > ($7, $8::timestamptz, $9)
    ORDER BY CASE WHEN $10::bool THEN (users.universal,users.created_at,users.id) END ASC,
        CASE WHEN NOT $10::bool THEN (users.universal,users.created_at,users.id) END DESC) AS result LIMIT $2
`

type GetOwnersByContractIdBatchPaginateBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetOwnersByContractIdBatchPaginateParams struct {
	Contract           persist.DBID
	Limit              int32
	GalleryUsersOnly   bool
	CurBeforeUniversal bool
	CurBeforeTime      time.Time
	CurBeforeID        persist.DBID
	CurAfterUniversal  bool
	CurAfterTime       time.Time
	CurAfterID         persist.DBID
	PagingForward      bool
}

func (q *Queries) GetOwnersByContractIdBatchPaginate(ctx context.Context, arg []GetOwnersByContractIdBatchPaginateParams) *GetOwnersByContractIdBatchPaginateBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Contract,
			a.Limit,
			a.GalleryUsersOnly,
			a.CurBeforeUniversal,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterUniversal,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
		}
		batch.Queue(getOwnersByContractIdBatchPaginate, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetOwnersByContractIdBatchPaginateBatchResults{br, 0}
}

func (b *GetOwnersByContractIdBatchPaginateBatchResults) Query(f func(int, []User, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []User
		for rows.Next() {
			var i User
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Username,
				&i.UsernameIdempotent,
				&i.Wallets,
				&i.Bio,
				&i.Traits,
				&i.Universal,
				&i.NotificationSettings,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetOwnersByContractIdBatchPaginateBatchResults) Close() error {
	return b.br.Close()
}

const getTokenByIdBatch = `-- name: GetTokenByIdBatch :batchone
SELECT id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam FROM tokens WHERE id = $1 AND deleted = false
`

type GetTokenByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetTokenByIdBatch(ctx context.Context, id []persist.DBID) *GetTokenByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokenByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokenByIdBatchBatchResults{br, 0}
}

func (b *GetTokenByIdBatchBatchResults) QueryRow(f func(int, Token, error)) {
	for {
		row := b.br.QueryRow()
		var i Token
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetTokenByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokenOwnerByIDBatch = `-- name: GetTokenOwnerByIDBatch :batchone
SELECT u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings FROM tokens t
    JOIN users u ON u.id = t.owner_user_id
    WHERE t.id = $1 AND t.deleted = false AND u.deleted = false
`

type GetTokenOwnerByIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetTokenOwnerByIDBatch(ctx context.Context, id []persist.DBID) *GetTokenOwnerByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokenOwnerByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokenOwnerByIDBatchBatchResults{br, 0}
}

func (b *GetTokenOwnerByIDBatchBatchResults) QueryRow(f func(int, User, error)) {
	for {
		row := b.br.QueryRow()
		var i User
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetTokenOwnerByIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokensByCollectionIdBatch = `-- name: GetTokensByCollectionIdBatch :batchmany
SELECT t.id, t.deleted, t.version, t.created_at, t.last_updated, t.name, t.description, t.collectors_note, t.media, t.token_uri, t.token_type, t.token_id, t.quantity, t.ownership_history, t.token_metadata, t.external_url, t.block_number, t.owner_user_id, t.owned_by_wallets, t.chain, t.contract, t.is_user_marked_spam, t.is_provider_marked_spam FROM users u, collections c, unnest(c.nfts)
    WITH ORDINALITY AS x(nft_id, nft_ord)
    INNER JOIN tokens t ON t.id = x.nft_id
    WHERE u.id = t.owner_user_id AND t.owned_by_wallets && u.wallets
    AND c.id = $1 AND u.deleted = false AND c.deleted = false AND t.deleted = false ORDER BY x.nft_ord
`

type GetTokensByCollectionIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetTokensByCollectionIdBatch(ctx context.Context, id []persist.DBID) *GetTokensByCollectionIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokensByCollectionIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokensByCollectionIdBatchBatchResults{br, 0}
}

func (b *GetTokensByCollectionIdBatchBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.Media,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnedByWallets,
				&i.Chain,
				&i.Contract,
				&i.IsUserMarkedSpam,
				&i.IsProviderMarkedSpam,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetTokensByCollectionIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokensByContractIdBatch = `-- name: GetTokensByContractIdBatch :batchmany
SELECT id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam FROM tokens WHERE contract = $1 AND deleted = false
    ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

type GetTokensByContractIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetTokensByContractIdBatch(ctx context.Context, contract []persist.DBID) *GetTokensByContractIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range contract {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokensByContractIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokensByContractIdBatchBatchResults{br, 0}
}

func (b *GetTokensByContractIdBatchBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.Media,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnedByWallets,
				&i.Chain,
				&i.Contract,
				&i.IsUserMarkedSpam,
				&i.IsProviderMarkedSpam,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetTokensByContractIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokensByContractIdBatchPaginate = `-- name: GetTokensByContractIdBatchPaginate :batchmany
SELECT t.id, t.deleted, t.version, t.created_at, t.last_updated, t.name, t.description, t.collectors_note, t.media, t.token_uri, t.token_type, t.token_id, t.quantity, t.ownership_history, t.token_metadata, t.external_url, t.block_number, t.owner_user_id, t.owned_by_wallets, t.chain, t.contract, t.is_user_marked_spam, t.is_provider_marked_spam FROM tokens t
    JOIN users u ON u.id = t.owner_user_id
    WHERE t.contract = $1 AND t.deleted = false
    AND (NOT $3::bool OR u.universal = false)
    AND (u.universal,t.created_at,t.id) < ($4, $5::timestamptz, $6)
    AND (u.universal,t.created_at,t.id) > ($7, $8::timestamptz, $9)
    ORDER BY CASE WHEN $10::bool THEN (u.universal,t.created_at,t.id) END ASC,
             CASE WHEN NOT $10::bool THEN (u.universal,t.created_at,t.id) END DESC
    LIMIT $2
`

type GetTokensByContractIdBatchPaginateBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetTokensByContractIdBatchPaginateParams struct {
	Contract           persist.DBID
	Limit              int32
	GalleryUsersOnly   bool
	CurBeforeUniversal bool
	CurBeforeTime      time.Time
	CurBeforeID        persist.DBID
	CurAfterUniversal  bool
	CurAfterTime       time.Time
	CurAfterID         persist.DBID
	PagingForward      bool
}

func (q *Queries) GetTokensByContractIdBatchPaginate(ctx context.Context, arg []GetTokensByContractIdBatchPaginateParams) *GetTokensByContractIdBatchPaginateBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Contract,
			a.Limit,
			a.GalleryUsersOnly,
			a.CurBeforeUniversal,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterUniversal,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
		}
		batch.Queue(getTokensByContractIdBatchPaginate, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokensByContractIdBatchPaginateBatchResults{br, 0}
}

func (b *GetTokensByContractIdBatchPaginateBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.Media,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnedByWallets,
				&i.Chain,
				&i.Contract,
				&i.IsUserMarkedSpam,
				&i.IsProviderMarkedSpam,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetTokensByContractIdBatchPaginateBatchResults) Close() error {
	return b.br.Close()
}

const getTokensByUserIdAndChainBatch = `-- name: GetTokensByUserIdAndChainBatch :batchmany
SELECT tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.name, tokens.description, tokens.collectors_note, tokens.media, tokens.token_uri, tokens.token_type, tokens.token_id, tokens.quantity, tokens.ownership_history, tokens.token_metadata, tokens.external_url, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.chain, tokens.contract, tokens.is_user_marked_spam, tokens.is_provider_marked_spam FROM tokens, users
WHERE tokens.owner_user_id = $1 AND users.id = $1
  AND tokens.owned_by_wallets && users.wallets
  AND tokens.deleted = false AND users.deleted = false
  AND tokens.chain = $2
ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

type GetTokensByUserIdAndChainBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetTokensByUserIdAndChainBatchParams struct {
	OwnerUserID persist.DBID
	Chain       sql.NullInt32
}

func (q *Queries) GetTokensByUserIdAndChainBatch(ctx context.Context, arg []GetTokensByUserIdAndChainBatchParams) *GetTokensByUserIdAndChainBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OwnerUserID,
			a.Chain,
		}
		batch.Queue(getTokensByUserIdAndChainBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokensByUserIdAndChainBatchBatchResults{br, 0}
}

func (b *GetTokensByUserIdAndChainBatchBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.Media,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnedByWallets,
				&i.Chain,
				&i.Contract,
				&i.IsUserMarkedSpam,
				&i.IsProviderMarkedSpam,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetTokensByUserIdAndChainBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokensByUserIdAndContractIDBatch = `-- name: GetTokensByUserIdAndContractIDBatch :batchmany
SELECT tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.name, tokens.description, tokens.collectors_note, tokens.media, tokens.token_uri, tokens.token_type, tokens.token_id, tokens.quantity, tokens.ownership_history, tokens.token_metadata, tokens.external_url, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.chain, tokens.contract, tokens.is_user_marked_spam, tokens.is_provider_marked_spam FROM tokens, users
    WHERE tokens.owner_user_id = $1 AND users.id = $1
      AND tokens.owned_by_wallets && users.wallets
      AND tokens.contract = $2
      AND tokens.deleted = false AND users.deleted = false
    ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

type GetTokensByUserIdAndContractIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetTokensByUserIdAndContractIDBatchParams struct {
	OwnerUserID persist.DBID
	Contract    persist.DBID
}

func (q *Queries) GetTokensByUserIdAndContractIDBatch(ctx context.Context, arg []GetTokensByUserIdAndContractIDBatchParams) *GetTokensByUserIdAndContractIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OwnerUserID,
			a.Contract,
		}
		batch.Queue(getTokensByUserIdAndContractIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokensByUserIdAndContractIDBatchBatchResults{br, 0}
}

func (b *GetTokensByUserIdAndContractIDBatchBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.Media,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnedByWallets,
				&i.Chain,
				&i.Contract,
				&i.IsUserMarkedSpam,
				&i.IsProviderMarkedSpam,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetTokensByUserIdAndContractIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokensByUserIdBatch = `-- name: GetTokensByUserIdBatch :batchmany
SELECT tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.name, tokens.description, tokens.collectors_note, tokens.media, tokens.token_uri, tokens.token_type, tokens.token_id, tokens.quantity, tokens.ownership_history, tokens.token_metadata, tokens.external_url, tokens.block_number, tokens.owner_user_id, tokens.owned_by_wallets, tokens.chain, tokens.contract, tokens.is_user_marked_spam, tokens.is_provider_marked_spam FROM tokens, users
    WHERE tokens.owner_user_id = $1 AND users.id = $1
      AND tokens.owned_by_wallets && users.wallets
      AND tokens.deleted = false AND users.deleted = false
    ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

type GetTokensByUserIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetTokensByUserIdBatch(ctx context.Context, ownerUserID []persist.DBID) *GetTokensByUserIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range ownerUserID {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokensByUserIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokensByUserIdBatchBatchResults{br, 0}
}

func (b *GetTokensByUserIdBatchBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.Media,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnedByWallets,
				&i.Chain,
				&i.Contract,
				&i.IsUserMarkedSpam,
				&i.IsProviderMarkedSpam,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetTokensByUserIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getTokensByWalletIdsBatch = `-- name: GetTokensByWalletIdsBatch :batchmany
SELECT id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam FROM tokens WHERE owned_by_wallets && $1 AND deleted = false
    ORDER BY tokens.created_at DESC, tokens.name DESC, tokens.id DESC
`

type GetTokensByWalletIdsBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetTokensByWalletIdsBatch(ctx context.Context, ownedByWallets []persist.DBIDList) *GetTokensByWalletIdsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range ownedByWallets {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokensByWalletIdsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokensByWalletIdsBatchBatchResults{br, 0}
}

func (b *GetTokensByWalletIdsBatchBatchResults) Query(f func(int, []Token, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Token
		for rows.Next() {
			var i Token
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Name,
				&i.Description,
				&i.CollectorsNote,
				&i.Media,
				&i.TokenUri,
				&i.TokenType,
				&i.TokenID,
				&i.Quantity,
				&i.OwnershipHistory,
				&i.TokenMetadata,
				&i.ExternalUrl,
				&i.BlockNumber,
				&i.OwnerUserID,
				&i.OwnedByWallets,
				&i.Chain,
				&i.Contract,
				&i.IsUserMarkedSpam,
				&i.IsProviderMarkedSpam,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetTokensByWalletIdsBatchBatchResults) Close() error {
	return b.br.Close()
}

const getUserByIdBatch = `-- name: GetUserByIdBatch :batchone
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings FROM users WHERE id = $1 AND deleted = false
`

type GetUserByIdBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetUserByIdBatch(ctx context.Context, id []persist.DBID) *GetUserByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUserByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserByIdBatchBatchResults{br, 0}
}

func (b *GetUserByIdBatchBatchResults) QueryRow(f func(int, User, error)) {
	for {
		row := b.br.QueryRow()
		var i User
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetUserByIdBatchBatchResults) Close() error {
	return b.br.Close()
}

const getUserByUsernameBatch = `-- name: GetUserByUsernameBatch :batchone
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings FROM users WHERE username_idempotent = lower($1) AND deleted = false
`

type GetUserByUsernameBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetUserByUsernameBatch(ctx context.Context, lower []string) *GetUserByUsernameBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range lower {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUserByUsernameBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserByUsernameBatchBatchResults{br, 0}
}

func (b *GetUserByUsernameBatchBatchResults) QueryRow(f func(int, User, error)) {
	for {
		row := b.br.QueryRow()
		var i User
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetUserByUsernameBatchBatchResults) Close() error {
	return b.br.Close()
}

const getUserNotificationsBatch = `-- name: GetUserNotificationsBatch :batchmany
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, feed_event_id, comment_id, gallery_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type GetUserNotificationsBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetUserNotificationsBatchParams struct {
	OwnerID       persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUserNotificationsBatch(ctx context.Context, arg []GetUserNotificationsBatchParams) *GetUserNotificationsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OwnerID,
			a.Limit,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
		}
		batch.Queue(getUserNotificationsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserNotificationsBatchBatchResults{br, 0}
}

func (b *GetUserNotificationsBatchBatchResults) Query(f func(int, []Notification, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Notification
		for rows.Next() {
			var i Notification
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.OwnerID,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Action,
				&i.Data,
				&i.EventIds,
				&i.FeedEventID,
				&i.CommentID,
				&i.GalleryID,
				&i.Seen,
				&i.Amount,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetUserNotificationsBatchBatchResults) Close() error {
	return b.br.Close()
}

const getUsersWithTraitBatch = `-- name: GetUsersWithTraitBatch :batchmany
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings FROM users WHERE (traits->$1::string) IS NOT NULL AND deleted = false
`

type GetUsersWithTraitBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetUsersWithTraitBatch(ctx context.Context, dollar_1 []string) *GetUsersWithTraitBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range dollar_1 {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUsersWithTraitBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUsersWithTraitBatchBatchResults{br, 0}
}

func (b *GetUsersWithTraitBatchBatchResults) Query(f func(int, []User, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []User
		for rows.Next() {
			var i User
			if err := rows.Scan(
				&i.ID,
				&i.Deleted,
				&i.Version,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Username,
				&i.UsernameIdempotent,
				&i.Wallets,
				&i.Bio,
				&i.Traits,
				&i.Universal,
				&i.NotificationSettings,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetUsersWithTraitBatchBatchResults) Close() error {
	return b.br.Close()
}

const getWalletByChainAddressBatch = `-- name: GetWalletByChainAddressBatch :batchone
SELECT wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type, wallets.chain FROM wallets WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetWalletByChainAddressBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type GetWalletByChainAddressBatchParams struct {
	Address persist.Address
	Chain   sql.NullInt32
}

func (q *Queries) GetWalletByChainAddressBatch(ctx context.Context, arg []GetWalletByChainAddressBatchParams) *GetWalletByChainAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Address,
			a.Chain,
		}
		batch.Queue(getWalletByChainAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetWalletByChainAddressBatchBatchResults{br, 0}
}

func (b *GetWalletByChainAddressBatchBatchResults) QueryRow(f func(int, Wallet, error)) {
	for {
		row := b.br.QueryRow()
		var i Wallet
		err := row.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetWalletByChainAddressBatchBatchResults) Close() error {
	return b.br.Close()
}

const getWalletByIDBatch = `-- name: GetWalletByIDBatch :batchone
SELECT id, created_at, last_updated, deleted, version, address, wallet_type, chain FROM wallets WHERE id = $1 AND deleted = false
`

type GetWalletByIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetWalletByIDBatch(ctx context.Context, id []persist.DBID) *GetWalletByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getWalletByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetWalletByIDBatchBatchResults{br, 0}
}

func (b *GetWalletByIDBatchBatchResults) QueryRow(f func(int, Wallet, error)) {
	for {
		row := b.br.QueryRow()
		var i Wallet
		err := row.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
		)
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, i, err)
		}
		b.ind++
	}
}

func (b *GetWalletByIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const getWalletsByUserIDBatch = `-- name: GetWalletsByUserIDBatch :batchmany
SELECT w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type, w.chain FROM users u, unnest(u.wallets) WITH ORDINALITY AS a(wallet_id, wallet_ord)INNER JOIN wallets w on w.id = a.wallet_id WHERE u.id = $1 AND u.deleted = false AND w.deleted = false ORDER BY a.wallet_ord
`

type GetWalletsByUserIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) GetWalletsByUserIDBatch(ctx context.Context, id []persist.DBID) *GetWalletsByUserIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getWalletsByUserIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetWalletsByUserIDBatchBatchResults{br, 0}
}

func (b *GetWalletsByUserIDBatchBatchResults) Query(f func(int, []Wallet, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Wallet
		for rows.Next() {
			var i Wallet
			if err := rows.Scan(
				&i.ID,
				&i.CreatedAt,
				&i.LastUpdated,
				&i.Deleted,
				&i.Version,
				&i.Address,
				&i.WalletType,
				&i.Chain,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *GetWalletsByUserIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const paginateAdmiresByFeedEventIDBatch = `-- name: PaginateAdmiresByFeedEventIDBatch :batchmany
SELECT id, version, feed_event_id, actor_id, deleted, created_at, last_updated FROM admires WHERE feed_event_id = $1 AND deleted = false
    AND (created_at, id) < ($3, $4) AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type PaginateAdmiresByFeedEventIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type PaginateAdmiresByFeedEventIDBatchParams struct {
	FeedEventID   persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) PaginateAdmiresByFeedEventIDBatch(ctx context.Context, arg []PaginateAdmiresByFeedEventIDBatchParams) *PaginateAdmiresByFeedEventIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.FeedEventID,
			a.Limit,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
		}
		batch.Queue(paginateAdmiresByFeedEventIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &PaginateAdmiresByFeedEventIDBatchBatchResults{br, 0}
}

func (b *PaginateAdmiresByFeedEventIDBatchBatchResults) Query(f func(int, []Admire, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Admire
		for rows.Next() {
			var i Admire
			if err := rows.Scan(
				&i.ID,
				&i.Version,
				&i.FeedEventID,
				&i.ActorID,
				&i.Deleted,
				&i.CreatedAt,
				&i.LastUpdated,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *PaginateAdmiresByFeedEventIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const paginateCommentsByFeedEventIDBatch = `-- name: PaginateCommentsByFeedEventIDBatch :batchmany
SELECT id, version, feed_event_id, actor_id, reply_to, comment, deleted, created_at, last_updated FROM comments WHERE feed_event_id = $1 AND deleted = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type PaginateCommentsByFeedEventIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type PaginateCommentsByFeedEventIDBatchParams struct {
	FeedEventID   persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) PaginateCommentsByFeedEventIDBatch(ctx context.Context, arg []PaginateCommentsByFeedEventIDBatchParams) *PaginateCommentsByFeedEventIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.FeedEventID,
			a.Limit,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
		}
		batch.Queue(paginateCommentsByFeedEventIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &PaginateCommentsByFeedEventIDBatchBatchResults{br, 0}
}

func (b *PaginateCommentsByFeedEventIDBatchBatchResults) Query(f func(int, []Comment, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []Comment
		for rows.Next() {
			var i Comment
			if err := rows.Scan(
				&i.ID,
				&i.Version,
				&i.FeedEventID,
				&i.ActorID,
				&i.ReplyTo,
				&i.Comment,
				&i.Deleted,
				&i.CreatedAt,
				&i.LastUpdated,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *PaginateCommentsByFeedEventIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const paginateGlobalFeed = `-- name: PaginateGlobalFeed :batchmany
SELECT id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption FROM feed_events WHERE deleted = false
    AND (event_time, id) < ($2, $3)
    AND (event_time, id) > ($4, $5)
    ORDER BY CASE WHEN $6::bool THEN (event_time, id) END ASC,
            CASE WHEN NOT $6::bool THEN (event_time, id) END DESC
    LIMIT $1
`

type PaginateGlobalFeedBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type PaginateGlobalFeedParams struct {
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) PaginateGlobalFeed(ctx context.Context, arg []PaginateGlobalFeedParams) *PaginateGlobalFeedBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Limit,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
		}
		batch.Queue(paginateGlobalFeed, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &PaginateGlobalFeedBatchResults{br, 0}
}

func (b *PaginateGlobalFeedBatchResults) Query(f func(int, []FeedEvent, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []FeedEvent
		for rows.Next() {
			var i FeedEvent
			if err := rows.Scan(
				&i.ID,
				&i.Version,
				&i.OwnerID,
				&i.Action,
				&i.Data,
				&i.EventTime,
				&i.EventIds,
				&i.Deleted,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Caption,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *PaginateGlobalFeedBatchResults) Close() error {
	return b.br.Close()
}

const paginateInteractionsByFeedEventIDBatch = `-- name: PaginateInteractionsByFeedEventIDBatch :batchmany
SELECT interactions.created_At, interactions.id, interactions.tag FROM (
    SELECT t.created_at, t.id, $3::int as tag FROM admires t WHERE $3 != 0 AND t.feed_event_id = $1 AND t.deleted = false
        AND (t.created_at, t.id) < ($4, $5) AND (t.created_at, t.id) > ($6, $7)
                                                                    UNION
    SELECT t.created_at, t.id, $8::int as tag FROM comments t WHERE $8 != 0 AND t.feed_event_id = $1 AND t.deleted = false
        AND (t.created_at, t.id) < ($4, $5) AND (t.created_at, t.id) > ($6, $7)
) as interactions

ORDER BY CASE WHEN $9::bool THEN (created_at, id) END ASC,
         CASE WHEN NOT $9::bool THEN (created_at, id) END DESC
LIMIT $2
`

type PaginateInteractionsByFeedEventIDBatchBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type PaginateInteractionsByFeedEventIDBatchParams struct {
	FeedEventID   persist.DBID
	Limit         int32
	AdmireTag     int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	CommentTag    int32
	PagingForward bool
}

type PaginateInteractionsByFeedEventIDBatchRow struct {
	CreatedAt time.Time
	ID        persist.DBID
	Tag       int32
}

func (q *Queries) PaginateInteractionsByFeedEventIDBatch(ctx context.Context, arg []PaginateInteractionsByFeedEventIDBatchParams) *PaginateInteractionsByFeedEventIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.FeedEventID,
			a.Limit,
			a.AdmireTag,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterTime,
			a.CurAfterID,
			a.CommentTag,
			a.PagingForward,
		}
		batch.Queue(paginateInteractionsByFeedEventIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &PaginateInteractionsByFeedEventIDBatchBatchResults{br, 0}
}

func (b *PaginateInteractionsByFeedEventIDBatchBatchResults) Query(f func(int, []PaginateInteractionsByFeedEventIDBatchRow, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []PaginateInteractionsByFeedEventIDBatchRow
		for rows.Next() {
			var i PaginateInteractionsByFeedEventIDBatchRow
			if err := rows.Scan(&i.CreatedAt, &i.ID, &i.Tag); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *PaginateInteractionsByFeedEventIDBatchBatchResults) Close() error {
	return b.br.Close()
}

const paginatePersonalFeedByUserID = `-- name: PaginatePersonalFeedByUserID :batchmany
SELECT fe.id, fe.version, fe.owner_id, fe.action, fe.data, fe.event_time, fe.event_ids, fe.deleted, fe.last_updated, fe.created_at, fe.caption FROM feed_events fe, follows fl WHERE fe.deleted = false AND fl.deleted = false
    AND fe.owner_id = fl.followee AND fl.follower = $1
    AND (fe.event_time, fe.id) < ($3, $4)
    AND (fe.event_time, fe.id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (fe.event_time, fe.id) END ASC,
            CASE WHEN NOT $7::bool THEN (fe.event_time, fe.id) END DESC
    LIMIT $2
`

type PaginatePersonalFeedByUserIDBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type PaginatePersonalFeedByUserIDParams struct {
	Follower      persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) PaginatePersonalFeedByUserID(ctx context.Context, arg []PaginatePersonalFeedByUserIDParams) *PaginatePersonalFeedByUserIDBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Follower,
			a.Limit,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
		}
		batch.Queue(paginatePersonalFeedByUserID, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &PaginatePersonalFeedByUserIDBatchResults{br, 0}
}

func (b *PaginatePersonalFeedByUserIDBatchResults) Query(f func(int, []FeedEvent, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []FeedEvent
		for rows.Next() {
			var i FeedEvent
			if err := rows.Scan(
				&i.ID,
				&i.Version,
				&i.OwnerID,
				&i.Action,
				&i.Data,
				&i.EventTime,
				&i.EventIds,
				&i.Deleted,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Caption,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *PaginatePersonalFeedByUserIDBatchResults) Close() error {
	return b.br.Close()
}

const paginateUserFeedByUserID = `-- name: PaginateUserFeedByUserID :batchmany
SELECT id, version, owner_id, action, data, event_time, event_ids, deleted, last_updated, created_at, caption FROM feed_events WHERE owner_id = $1 AND deleted = false
    AND (event_time, id) < ($3, $4)
    AND (event_time, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (event_time, id) END ASC,
            CASE WHEN NOT $7::bool THEN (event_time, id) END DESC
    LIMIT $2
`

type PaginateUserFeedByUserIDBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type PaginateUserFeedByUserIDParams struct {
	OwnerID       persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) PaginateUserFeedByUserID(ctx context.Context, arg []PaginateUserFeedByUserIDParams) *PaginateUserFeedByUserIDBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OwnerID,
			a.Limit,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
		}
		batch.Queue(paginateUserFeedByUserID, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &PaginateUserFeedByUserIDBatchResults{br, 0}
}

func (b *PaginateUserFeedByUserIDBatchResults) Query(f func(int, []FeedEvent, error)) {
	for {
		rows, err := b.br.Query()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		defer rows.Close()
		var items []FeedEvent
		for rows.Next() {
			var i FeedEvent
			if err := rows.Scan(
				&i.ID,
				&i.Version,
				&i.OwnerID,
				&i.Action,
				&i.Data,
				&i.EventTime,
				&i.EventIds,
				&i.Deleted,
				&i.LastUpdated,
				&i.CreatedAt,
				&i.Caption,
			); err != nil {
				break
			}
			items = append(items, i)
		}

		if f != nil {
			f(b.ind, items, rows.Err())
		}
		b.ind++
	}
}

func (b *PaginateUserFeedByUserIDBatchResults) Close() error {
	return b.br.Close()
}
