// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: token_gallery.sql

package coredb

import (
	"context"
	"time"

	"github.com/jackc/pgtype"
	"github.com/mikeydub/go-gallery/service/persist"
)

const upsertTokens = `-- name: UpsertTokens :many
insert into tokens
(
  id
  , deleted
  , version
  , created_at
  , last_updated
  , name
  , description
  , collectors_note
  , media
  , token_type
  , token_id
  , quantity
  , ownership_history
  , token_metadata
  , external_url
  , block_number
  , owner_user_id
  , owned_by_wallets
  , chain
  , contract
  , is_user_marked_spam
  , is_provider_marked_spam
  , last_synced
  , token_uri
) (
  select
    id
    , deleted 
    , version
    , created_at
    , last_updated
    , name
    , description
    , collectors_note
    , media
    , token_type
    , token_id
    , quantity
    , string_to_array(ownership_history_serialized, $1)::jsonb[] as ownership_history
    , token_metadata
    , external_url
    , block_number
    , owner_user_id
    , string_to_array(owned_by_wallets_serialized, $1)::varchar[] as owned_by_wallets
    , chain
    , contract
    , is_user_marked_spam
    , is_provider_marked_spam
    , last_synced
    , token_uri
  from (
    select
      unnest($2::varchar[]) as id
      , unnest($3::boolean[]) as deleted
      , unnest($4::int[]) as version
      , unnest($5::timestamptz[]) as created_at
      , unnest($6::timestamptz[]) as last_updated
      , unnest($7::varchar[]) as name
      , unnest($8::varchar[]) as description
      , unnest($9::varchar[]) as collectors_note
      , unnest($10::jsonb[]) as media
      , unnest($11::varchar[]) as token_type
      , unnest($12::varchar[]) as token_id
      , unnest($13::varchar[]) as quantity
      , unnest($14::varchar[]) as ownership_history_serialized
      , unnest($15::jsonb[]) as token_metadata
      , unnest($16::varchar[]) as external_url
      , unnest($17::bigint[]) as block_number
      , unnest($18::varchar[]) as owner_user_id
      , unnest($19::varchar[]) as owned_by_wallets_serialized
      , unnest($20::int[]) as chain
      , unnest($21::varchar[]) as contract
      , unnest($22::bool[]) as is_user_marked_spam
      , unnest($23::bool[]) as is_provider_marked_spam
      , unnest($24::timestamptz[]) as last_synced
      , unnest($25::varchar[]) as token_uri
  ) bulk_upsert
)
on conflict (token_id, contract, chain, owner_user_id) where deleted = false
do update set
  media = excluded.media
  , token_type = excluded.token_type
  , chain = excluded.chain
  , name = excluded.name
  , description = excluded.description
  , token_uri = excluded.token_uri
  , quantity = excluded.quantity
  , owner_user_id = excluded.owner_user_id
  , owned_by_wallets = excluded.owned_by_wallets
  , ownership_history = tokens.ownership_history || excluded.ownership_history
  , token_metadata = excluded.token_metadata
  , external_url = excluded.external_url
  , block_number = excluded.block_number
  , version = excluded.version
  , last_updated = excluded.last_updated
  , is_user_marked_spam = tokens.is_user_marked_spam
  , is_provider_marked_spam = excluded.is_provider_marked_spam
  , last_synced = greatest(excluded.last_synced,tokens.last_synced)
returning id, created_at, last_updated, last_synced
`

type UpsertTokensParams struct {
	Delim                      string
	ID                         []string
	Deleted                    []bool
	Version                    []int32
	CreatedAt                  []time.Time
	LastUpdated                []time.Time
	Name                       []string
	Description                []string
	CollectorsNote             []string
	Media                      []pgtype.JSONB
	TokenType                  []string
	TokenID                    []string
	Quantity                   []string
	OwnershipHistorySerialized []string
	TokenMetadata              []pgtype.JSONB
	ExternalUrl                []string
	BlockNumber                []int64
	OwnerUserID                []string
	OwnedByWalletsSerialized   []string
	Chain                      []int32
	Contract                   []string
	IsUserMarkedSpam           []bool
	IsProviderMarkedSpam       []bool
	LastSynced                 []time.Time
	TokenUri                   []string
}

type UpsertTokensRow struct {
	ID          persist.DBID
	CreatedAt   time.Time
	LastUpdated time.Time
	LastSynced  time.Time
}

func (q *Queries) UpsertTokens(ctx context.Context, arg UpsertTokensParams) ([]UpsertTokensRow, error) {
	rows, err := q.db.Query(ctx, upsertTokens,
		arg.Delim,
		arg.ID,
		arg.Deleted,
		arg.Version,
		arg.CreatedAt,
		arg.LastUpdated,
		arg.Name,
		arg.Description,
		arg.CollectorsNote,
		arg.Media,
		arg.TokenType,
		arg.TokenID,
		arg.Quantity,
		arg.OwnershipHistorySerialized,
		arg.TokenMetadata,
		arg.ExternalUrl,
		arg.BlockNumber,
		arg.OwnerUserID,
		arg.OwnedByWalletsSerialized,
		arg.Chain,
		arg.Contract,
		arg.IsUserMarkedSpam,
		arg.IsProviderMarkedSpam,
		arg.LastSynced,
		arg.TokenUri,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpsertTokensRow
	for rows.Next() {
		var i UpsertTokensRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
