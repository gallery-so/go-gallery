// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: token_gallery.sql

package coredb

import (
	"context"

	"github.com/jackc/pgtype"
)

const upsertTokens = `-- name: UpsertTokens :many
insert into tokens
(
  id
  , deleted
  , version
  , created_at
  , last_updated
  , name
  , description
  , collectors_note
  , token_type
  , token_id
  , quantity
  , ownership_history
  , media
  , fallback_media
  , token_metadata
  , external_url
  , block_number
  , owner_user_id
  , owned_by_wallets
  , chain
  , contract
  , is_provider_marked_spam
  , last_synced
  , token_uri
  , token_media_id
) (
  select
    id
    , false
    , version
    , now()
    , now()
    , name
    , description
    , collectors_note
    , token_type
    , token_id
    , quantity
    , case when $1::bool then '{}' else ownership_history[ownership_history_start_idx::int:ownership_history_end_idx::int] end
    , media
    , fallback_media
    , token_metadata
    , external_url
    , block_number
    , owner_user_id
    , case when $1 then '{}' else owned_by_wallets[owned_by_wallets_start_idx::int:owned_by_wallets_end_idx::int] end
    , chain
    , contract
    , is_provider_marked_spam
    , now()
    , token_uri
    , (select tm.id
       from token_medias tm
       where tm.token_id = bulk_upsert.token_id
         and tm.contract_id = bulk_upsert.contract
         and tm.chain = bulk_upsert.chain
         and tm.active = true
         and tm.deleted = false
        limit 1
      ) as token_media_id
  from (
    select unnest($2::varchar[]) as id
      , unnest($3::int[]) as version
      , unnest($4::varchar[]) as name
      , unnest($5::varchar[]) as description
      , unnest($6::varchar[]) as collectors_note
      , unnest($7::varchar[]) as token_type
      , unnest($8::varchar[]) as quantity
      , $9::jsonb[] as ownership_history
      , unnest($10::int[]) as ownership_history_start_idx
      , unnest($11::int[]) as ownership_history_end_idx
      , unnest($12::jsonb[]) as media
      , unnest($13::jsonb[]) as fallback_media
      , unnest($14::jsonb[]) as token_metadata
      , unnest($15::varchar[]) as external_url
      , unnest($16::bigint[]) as block_number
      , unnest($17::varchar[]) as owner_user_id
      , $18::varchar[] as owned_by_wallets
      , unnest($19::int[]) as owned_by_wallets_start_idx
      , unnest($20::int[]) as owned_by_wallets_end_idx
      , unnest($21::bool[]) as is_provider_marked_spam
      , unnest($22::varchar[]) as token_uri
      , unnest($23::varchar[]) as token_id
      , unnest($24::varchar[]) as contract
      , unnest($25::int[]) as chain
  ) bulk_upsert
)
on conflict (token_id, contract, chain, owner_user_id) where deleted = false
do update set
  token_type = excluded.token_type
  , name = excluded.name
  , description = excluded.description
  , token_uri = excluded.token_uri
  , quantity = excluded.quantity
  , owned_by_wallets = case when $1 then tokens.owned_by_wallets else excluded.owned_by_wallets end
  , ownership_history = case when $1 then tokens.ownership_history else tokens.ownership_history || excluded.ownership_history end
  , fallback_media = excluded.fallback_media
  , token_metadata = excluded.token_metadata
  , external_url = excluded.external_url
  , block_number = excluded.block_number
  , version = excluded.version
  , last_updated = excluded.last_updated
  , is_provider_marked_spam = excluded.is_provider_marked_spam
  , last_synced = greatest(excluded.last_synced,tokens.last_synced)
returning id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam, last_synced, fallback_media, token_media_id
`

type UpsertTokensParams struct {
	UpsertingCreatorTokens   bool           `json:"upserting_creator_tokens"`
	ID                       []string       `json:"id"`
	Version                  []int32        `json:"version"`
	Name                     []string       `json:"name"`
	Description              []string       `json:"description"`
	CollectorsNote           []string       `json:"collectors_note"`
	TokenType                []string       `json:"token_type"`
	Quantity                 []string       `json:"quantity"`
	OwnershipHistory         []pgtype.JSONB `json:"ownership_history"`
	OwnershipHistoryStartIdx []int32        `json:"ownership_history_start_idx"`
	OwnershipHistoryEndIdx   []int32        `json:"ownership_history_end_idx"`
	Media                    []pgtype.JSONB `json:"media"`
	FallbackMedia            []pgtype.JSONB `json:"fallback_media"`
	TokenMetadata            []pgtype.JSONB `json:"token_metadata"`
	ExternalUrl              []string       `json:"external_url"`
	BlockNumber              []int64        `json:"block_number"`
	OwnerUserID              []string       `json:"owner_user_id"`
	OwnedByWallets           []string       `json:"owned_by_wallets"`
	OwnedByWalletsStartIdx   []int32        `json:"owned_by_wallets_start_idx"`
	OwnedByWalletsEndIdx     []int32        `json:"owned_by_wallets_end_idx"`
	IsProviderMarkedSpam     []bool         `json:"is_provider_marked_spam"`
	TokenUri                 []string       `json:"token_uri"`
	TokenID                  []string       `json:"token_id"`
	Contract                 []string       `json:"contract"`
	Chain                    []int32        `json:"chain"`
}

func (q *Queries) UpsertTokens(ctx context.Context, arg UpsertTokensParams) ([]Token, error) {
	rows, err := q.db.Query(ctx, upsertTokens,
		arg.UpsertingCreatorTokens,
		arg.ID,
		arg.Version,
		arg.Name,
		arg.Description,
		arg.CollectorsNote,
		arg.TokenType,
		arg.Quantity,
		arg.OwnershipHistory,
		arg.OwnershipHistoryStartIdx,
		arg.OwnershipHistoryEndIdx,
		arg.Media,
		arg.FallbackMedia,
		arg.TokenMetadata,
		arg.ExternalUrl,
		arg.BlockNumber,
		arg.OwnerUserID,
		arg.OwnedByWallets,
		arg.OwnedByWalletsStartIdx,
		arg.OwnedByWalletsEndIdx,
		arg.IsProviderMarkedSpam,
		arg.TokenUri,
		arg.TokenID,
		arg.Contract,
		arg.Chain,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
			&i.LastSynced,
			&i.FallbackMedia,
			&i.TokenMediaID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
