// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: token_gallery.sql

package coredb

import (
	"context"
	"time"

	"github.com/jackc/pgtype"
	"github.com/mikeydub/go-gallery/service/persist"
)

const upsertTokens = `-- name: UpsertTokens :many
insert into tokens
(
  id
  , deleted
  , version
  , created_at
  , last_updated
  , name
  , description
  , collectors_note
  , token_type
  , token_id
  , quantity
  , ownership_history
  , media
  , fallback_media
  , token_metadata
  , external_url
  , block_number
  , owner_user_id
  , owned_by_wallets
  , chain
  , contract
  , is_user_marked_spam
  , is_provider_marked_spam
  , last_synced
  , token_uri
  , token_media_id
) (
  select
    unnest(id)
    , deleted 
    , version
    , now()
    , now()
    , name
    , description
    , collectors_note
    , token_type
    , token_id
    , quantity
    , ownership_history[ownership_history_start_idx::int:ownership_history_end_idx::int]
    , media
    , fallback_media
    , token_metadata
    , external_url
    , block_number
    , owner_user_id
    , owned_by_wallets[owned_by_wallets_start_idx::int:owned_by_wallets_end_idx::int]
    , chain
    , contract
    , is_user_marked_spam
    , is_provider_marked_spam
    , last_synced
    , token_uri
    , (select tm.id
       from token_medias tm
       where tm.token_id = params.token_id
         and tm.contract_id = params.contract
         and tm.chain = params.chain
         and tm.active = true
         and tm.deleted = false
        limit 1
      ) as token_media_id
  from (
    select
      $1 as id
      , unnest($2::int[]) as version
      , unnest($3::varchar[]) as name
      , unnest($4::varchar[]) as description
      , unnest($5::varchar[]) as collectors_note
      , unnest($6::varchar[]) as token_type
      , unnest($7::varchar[]) as quantity
      , $8::jsonb[] as ownership_history
      , unnest($9::int[]) as ownership_history_start_idx
      , unnest($10::int[]) as ownership_history_end_idx
      , unnest($11::jsonb[]) as media
      , unnest($12::jsonb[]) as fallback_media
      , unnest($13::jsonb[]) as token_metadata
      , unnest($14::varchar[]) as external_url
      , unnest($15::bigint[]) as block_number
      , unnest($16::varchar[]) as owner_user_id
      , $17::varchar[] as owned_by_wallets
      , unnest($18::int[]) as owned_by_wallets_start_idx
      , unnest($19::int[]) as owned_by_wallets_end_idx
      , unnest($20::bool[]) as is_user_marked_spam
      , unnest($21::bool[]) as is_provider_marked_spam
      , unnest($22::timestamptz[]) as last_synced
      , unnest($23::varchar[]) as token_uri
      , unnest($24::varchar[]) as token_id
      , unnest($25::varchar[]) as contract
      , unnest($26::int[]) as chain
  ) params
)
on conflict (token_id, contract, chain, owner_user_id) where deleted = false
do update set
  token_type = excluded.token_type
  , name = excluded.name
  , description = excluded.description
  , token_uri = excluded.token_uri
  , quantity = excluded.quantity
  , owned_by_wallets = excluded.owned_by_wallets
  , ownership_history = tokens.ownership_history || excluded.ownership_history
  , fallback_media = excluded.fallback_media
  , token_metadata = excluded.token_metadata
  , external_url = excluded.external_url
  , block_number = excluded.block_number
  , version = excluded.version
  , last_updated = excluded.last_updated
  , is_user_marked_spam = tokens.is_user_marked_spam
  , is_provider_marked_spam = excluded.is_provider_marked_spam
  , last_synced = greatest(excluded.last_synced,tokens.last_synced)
returning id, deleted, version, created_at, last_updated, name, description, collectors_note, media, token_uri, token_type, token_id, quantity, ownership_history, token_metadata, external_url, block_number, owner_user_id, owned_by_wallets, chain, contract, is_user_marked_spam, is_provider_marked_spam, last_synced, fallback_media, token_media_id, child_contract_id
`

type UpsertTokensParams struct {
	Ids                      persist.DBIDList
	Version                  []int32
	Name                     []string
	Description              []string
	CollectorsNote           []string
	TokenType                []string
	Quantity                 []string
	OwnershipHistory         []pgtype.JSONB
	OwnershipHistoryStartIdx []int32
	OwnershipHistoryEndIdx   []int32
	Media                    []pgtype.JSONB
	FallbackMedia            []pgtype.JSONB
	TokenMetadata            []pgtype.JSONB
	ExternalUrl              []string
	BlockNumber              []int64
	OwnerUserID              []string
	OwnedByWallets           []string
	OwnedByWalletsStartIdx   []int32
	OwnedByWalletsEndIdx     []int32
	IsUserMarkedSpam         []bool
	IsProviderMarkedSpam     []bool
	LastSynced               []time.Time
	TokenUri                 []string
	TokenID                  []string
	Contract                 []string
	Chain                    []int32
}

func (q *Queries) UpsertTokens(ctx context.Context, arg UpsertTokensParams) ([]Token, error) {
	rows, err := q.db.Query(ctx, upsertTokens,
		arg.Ids,
		arg.Version,
		arg.Name,
		arg.Description,
		arg.CollectorsNote,
		arg.TokenType,
		arg.Quantity,
		arg.OwnershipHistory,
		arg.OwnershipHistoryStartIdx,
		arg.OwnershipHistoryEndIdx,
		arg.Media,
		arg.FallbackMedia,
		arg.TokenMetadata,
		arg.ExternalUrl,
		arg.BlockNumber,
		arg.OwnerUserID,
		arg.OwnedByWallets,
		arg.OwnedByWalletsStartIdx,
		arg.OwnedByWalletsEndIdx,
		arg.IsUserMarkedSpam,
		arg.IsProviderMarkedSpam,
		arg.LastSynced,
		arg.TokenUri,
		arg.TokenID,
		arg.Contract,
		arg.Chain,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Description,
			&i.CollectorsNote,
			&i.Media,
			&i.TokenUri,
			&i.TokenType,
			&i.TokenID,
			&i.Quantity,
			&i.OwnershipHistory,
			&i.TokenMetadata,
			&i.ExternalUrl,
			&i.BlockNumber,
			&i.OwnerUserID,
			&i.OwnedByWallets,
			&i.Chain,
			&i.Contract,
			&i.IsUserMarkedSpam,
			&i.IsProviderMarkedSpam,
			&i.LastSynced,
			&i.FallbackMedia,
			&i.TokenMediaID,
			&i.ChildContractID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
