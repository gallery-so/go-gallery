// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: community.sql

package coredb

import (
	"context"
)

const getCommunitiesByKeys = `-- name: GetCommunitiesByKeys :many
with keys as (
    select unnest ($1::int[]) as type
         , unnest ($2::varchar[]) as subtype
         , unnest ($3::varchar[]) as key
         , generate_subscripts($1::varchar[], 1) as batch_key_index
)
select k.batch_key_index, c.id, c.version, c.name, c.description, c.community_type, c.community_subtype, c.community_key, c.created_at, c.last_updated, c.deleted from keys k
    join communities c on
        k.type = c.community_type
        and k.subtype = c.community_subtype
        and k.key = c.community_key
    where not c.deleted
`

type GetCommunitiesByKeysParams struct {
	Types    []int32  `db:"types" json:"types"`
	Subtypes []string `db:"subtypes" json:"subtypes"`
	Keys     []string `db:"keys" json:"keys"`
}

type GetCommunitiesByKeysRow struct {
	BatchKeyIndex int32     `db:"batch_key_index" json:"batch_key_index"`
	Community     Community `db:"community" json:"community"`
}

// dataloader-config: skip=true
// Get communities by keys
func (q *Queries) GetCommunitiesByKeys(ctx context.Context, arg GetCommunitiesByKeysParams) ([]GetCommunitiesByKeysRow, error) {
	rows, err := q.db.Query(ctx, getCommunitiesByKeys, arg.Types, arg.Subtypes, arg.Keys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunitiesByKeysRow
	for rows.Next() {
		var i GetCommunitiesByKeysRow
		if err := rows.Scan(
			&i.BatchKeyIndex,
			&i.Community.ID,
			&i.Community.Version,
			&i.Community.Name,
			&i.Community.Description,
			&i.Community.CommunityType,
			&i.Community.CommunitySubtype,
			&i.Community.CommunityKey,
			&i.Community.CreatedAt,
			&i.Community.LastUpdated,
			&i.Community.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCommunities = `-- name: UpsertCommunities :many
insert into communities(id, version, name, description, community_type, community_subtype, community_key, created_at, last_updated, deleted) (
    select unnest($1::varchar[])
         , unnest($2::int[])
         , unnest($3::varchar[])
         , unnest($4::varchar[])
         , unnest($5::int[])
         , unnest($6::varchar[])
         , unnest($7::varchar[])
         , now()
         , now()
         , false
)
on conflict (community_type, community_subtype, community_key) where not deleted
    do update set version = excluded.version
                , name = coalesce(nullif(excluded.name, ''), nullif(communities.name, ''), '')
                , description = coalesce(nullif(excluded.description, ''), nullif(communities.description, ''), '')
                , last_updated = now()
                , deleted = excluded.deleted
returning id, version, name, description, community_type, community_subtype, community_key, created_at, last_updated, deleted
`

type UpsertCommunitiesParams struct {
	Ids              []string `db:"ids" json:"ids"`
	Version          []int32  `db:"version" json:"version"`
	Name             []string `db:"name" json:"name"`
	Description      []string `db:"description" json:"description"`
	CommunityType    []int32  `db:"community_type" json:"community_type"`
	CommunitySubtype []string `db:"community_subtype" json:"community_subtype"`
	CommunityKey     []string `db:"community_key" json:"community_key"`
}

func (q *Queries) UpsertCommunities(ctx context.Context, arg UpsertCommunitiesParams) ([]Community, error) {
	rows, err := q.db.Query(ctx, upsertCommunities,
		arg.Ids,
		arg.Version,
		arg.Name,
		arg.Description,
		arg.CommunityType,
		arg.CommunitySubtype,
		arg.CommunityKey,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Community
	for rows.Next() {
		var i Community
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.CommunityType,
			&i.CommunitySubtype,
			&i.CommunityKey,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContractCommunityMemberships = `-- name: UpsertContractCommunityMemberships :many
with memberships as (
    select unnest($1::varchar[]) as id
         , unnest($2::varchar[]) as contract_id
         , unnest($3::varchar[]) as community_id
         , now() as created_at
         , now() as last_updated
         , false as deleted
),
valid_memberships as (
    select memberships.id, memberships.contract_id, memberships.community_id, memberships.created_at, memberships.last_updated, memberships.deleted
    from memberships
    join communities on communities.id = memberships.community_id and not communities.deleted
    join contracts on contracts.id = memberships.contract_id and not contracts.deleted
)
insert into contract_community_memberships(id, contract_id, community_id, created_at, last_updated, deleted) (
    select id, contract_id, community_id, created_at, last_updated, deleted from valid_memberships
)
on conflict (community_id, contract_id) where not deleted
    do nothing
returning id, version, contract_id, community_id, created_at, last_updated, deleted
`

type UpsertContractCommunityMembershipsParams struct {
	Ids         []string `db:"ids" json:"ids"`
	ContractID  []string `db:"contract_id" json:"contract_id"`
	CommunityID []string `db:"community_id" json:"community_id"`
}

func (q *Queries) UpsertContractCommunityMemberships(ctx context.Context, arg UpsertContractCommunityMembershipsParams) ([]ContractCommunityMembership, error) {
	rows, err := q.db.Query(ctx, upsertContractCommunityMemberships, arg.Ids, arg.ContractID, arg.CommunityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContractCommunityMembership
	for rows.Next() {
		var i ContractCommunityMembership
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ContractID,
			&i.CommunityID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertTokenCommunityMemberships = `-- name: UpsertTokenCommunityMemberships :many
with memberships as (
    select unnest($1::varchar[]) as id
         , unnest($2::varchar[]) as token_id
         , unnest($3::varchar[]) as community_id
         , now() as created_at
         , now() as last_updated
         , false as deleted
),
valid_memberships as (
    select memberships.id, memberships.token_id, memberships.community_id, memberships.created_at, memberships.last_updated, memberships.deleted
    from memberships
    join communities on communities.id = memberships.community_id and not communities.deleted
    join tokens on tokens.id = memberships.token_id and not tokens.deleted
)
insert into token_community_memberships(id, token_id, community_id, created_at, last_updated, deleted) (
    select id, token_id, community_id, created_at, last_updated, deleted from valid_memberships
)
on conflict (community_id, token_id) where not deleted
    do nothing
returning id, version, token_id, community_id, created_at, last_updated, deleted
`

type UpsertTokenCommunityMembershipsParams struct {
	Ids         []string `db:"ids" json:"ids"`
	TokenID     []string `db:"token_id" json:"token_id"`
	CommunityID []string `db:"community_id" json:"community_id"`
}

func (q *Queries) UpsertTokenCommunityMemberships(ctx context.Context, arg UpsertTokenCommunityMembershipsParams) ([]TokenCommunityMembership, error) {
	rows, err := q.db.Query(ctx, upsertTokenCommunityMemberships, arg.Ids, arg.TokenID, arg.CommunityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenCommunityMembership
	for rows.Next() {
		var i TokenCommunityMembership
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.TokenID,
			&i.CommunityID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
