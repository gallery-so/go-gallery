package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/mikeydub/go-gallery/db/gen/coredb"
	emailService "github.com/mikeydub/go-gallery/emails"
	"github.com/mikeydub/go-gallery/graphql/generated"
	"github.com/mikeydub/go-gallery/graphql/model"
	"github.com/mikeydub/go-gallery/publicapi"
	"github.com/mikeydub/go-gallery/service/emails"
	"github.com/mikeydub/go-gallery/service/eth"
	"github.com/mikeydub/go-gallery/service/logger"
	"github.com/mikeydub/go-gallery/service/mediamapper"
	"github.com/mikeydub/go-gallery/service/multichain/tezos"
	"github.com/mikeydub/go-gallery/service/persist"
	sentryutil "github.com/mikeydub/go-gallery/service/sentry"
	"github.com/mikeydub/go-gallery/util"
	"github.com/mikeydub/go-gallery/validate"
)

// Admirer is the resolver for the admirer field.
func (r *admireResolver) Admirer(ctx context.Context, obj *model.Admire) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Admirer.Dbid)
}

// Source is the resolver for the source field.
func (r *admireResolver) Source(ctx context.Context, obj *model.Admire) (model.AdmireSource, error) {
	if obj.PostID != nil {
		return resolvePostByPostID(ctx, *obj.PostID)
	}
	if obj.FeedEventID != nil {
		return resolveFeedEventByEventID(ctx, *obj.FeedEventID)
	}

	return nil, fmt.Errorf("admire source not found")
}

// Admire is the resolver for the admire field.
func (r *admireFeedEventPayloadResolver) Admire(ctx context.Context, obj *model.AdmireFeedEventPayload) (*model.Admire, error) {
	return resolveAdmireByAdmireID(ctx, obj.Admire.Dbid)
}

// FeedEvent is the resolver for the feedEvent field.
func (r *admireFeedEventPayloadResolver) FeedEvent(ctx context.Context, obj *model.AdmireFeedEventPayload) (*model.FeedEvent, error) {
	return resolveFeedEventByEventID(ctx, obj.FeedEvent.Dbid)
}

// Post is the resolver for the post field.
func (r *admirePostPayloadResolver) Post(ctx context.Context, obj *model.AdmirePostPayload) (*model.Post, error) {
	return resolvePostByPostID(ctx, obj.Post.Dbid)
}

// Admire is the resolver for the admire field.
func (r *admirePostPayloadResolver) Admire(ctx context.Context, obj *model.AdmirePostPayload) (*model.Admire, error) {
	return resolveAdmireByAdmireID(ctx, obj.Admire.Dbid)
}

// Token is the resolver for the token field.
func (r *admireTokenPayloadResolver) Token(ctx context.Context, obj *model.AdmireTokenPayload) (*model.Token, error) {
	return resolveTokenByTokenID(ctx, obj.Token.Dbid)
}

// Admire is the resolver for the admire field.
func (r *admireTokenPayloadResolver) Admire(ctx context.Context, obj *model.AdmireTokenPayload) (*model.Admire, error) {
	return resolveAdmireByAdmireID(ctx, obj.Admire.Dbid)
}

// Gallery is the resolver for the gallery field.
func (r *collectionResolver) Gallery(ctx context.Context, obj *model.Collection) (*model.Gallery, error) {
	gallery, err := publicapi.For(ctx).Gallery.GetGalleryByCollectionId(ctx, obj.Dbid)

	if err != nil {
		return nil, err
	}

	return galleryToModel(ctx, *gallery), nil
}

// Tokens is the resolver for the tokens field.
func (r *collectionResolver) Tokens(ctx context.Context, obj *model.Collection, limit *int) ([]*model.CollectionToken, error) {
	tokens, err := publicapi.For(ctx).Token.GetTokensByCollectionId(ctx, obj.Dbid, limit)

	if err != nil {
		return nil, err
	}

	output := make([]*model.CollectionToken, len(tokens))
	for i, token := range tokens {
		output[i] = &model.CollectionToken{
			HelperCollectionTokenData: model.HelperCollectionTokenData{
				TokenId:      token.ID,
				CollectionId: obj.Dbid,
			},
			Token:         tokenToModel(ctx, token, &obj.Dbid),
			Collection:    obj,
			TokenSettings: nil, // handled by dedicated resolver
		}
	}

	return output, nil
}

// Owner is the resolver for the owner field.
func (r *collectionCreatedFeedEventDataResolver) Owner(ctx context.Context, obj *model.CollectionCreatedFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// Collection is the resolver for the collection field.
func (r *collectionCreatedFeedEventDataResolver) Collection(ctx context.Context, obj *model.CollectionCreatedFeedEventData) (*model.Collection, error) {
	return resolveCollectionByCollectionID(ctx, obj.Collection.Dbid)
}

// NewTokens is the resolver for the newTokens field.
func (r *collectionCreatedFeedEventDataResolver) NewTokens(ctx context.Context, obj *model.CollectionCreatedFeedEventData) ([]*model.CollectionToken, error) {
	return resolveCollectionTokensByTokenIDs(ctx, obj.CollectionID, obj.TokenIDs)
}

// Token is the resolver for the token field.
func (r *collectionTokenResolver) Token(ctx context.Context, obj *model.CollectionToken) (*model.Token, error) {
	return resolveTokenByTokenIDCollectionID(ctx, obj.HelperCollectionTokenData.TokenId, obj.CollectionId)
}

// Collection is the resolver for the collection field.
func (r *collectionTokenResolver) Collection(ctx context.Context, obj *model.CollectionToken) (*model.Collection, error) {
	return resolveCollectionByCollectionID(ctx, obj.HelperCollectionTokenData.CollectionId)
}

// TokenSettings is the resolver for the tokenSettings field.
func (r *collectionTokenResolver) TokenSettings(ctx context.Context, obj *model.CollectionToken) (*model.CollectionTokenSettings, error) {
	return resolveTokenSettingsByIDs(ctx, obj.TokenId, obj.CollectionId)
}

// Owner is the resolver for the owner field.
func (r *collectionUpdatedFeedEventDataResolver) Owner(ctx context.Context, obj *model.CollectionUpdatedFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// Collection is the resolver for the collection field.
func (r *collectionUpdatedFeedEventDataResolver) Collection(ctx context.Context, obj *model.CollectionUpdatedFeedEventData) (*model.Collection, error) {
	return resolveCollectionByCollectionID(ctx, obj.Collection.Dbid)
}

// NewTokens is the resolver for the newTokens field.
func (r *collectionUpdatedFeedEventDataResolver) NewTokens(ctx context.Context, obj *model.CollectionUpdatedFeedEventData) ([]*model.CollectionToken, error) {
	return resolveCollectionTokensByTokenIDs(ctx, obj.CollectionID, obj.TokenIDs)
}

// Owner is the resolver for the owner field.
func (r *collectorsNoteAddedToCollectionFeedEventDataResolver) Owner(ctx context.Context, obj *model.CollectorsNoteAddedToCollectionFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// Collection is the resolver for the collection field.
func (r *collectorsNoteAddedToCollectionFeedEventDataResolver) Collection(ctx context.Context, obj *model.CollectorsNoteAddedToCollectionFeedEventData) (*model.Collection, error) {
	return resolveCollectionByCollectionID(ctx, obj.Collection.Dbid)
}

// Owner is the resolver for the owner field.
func (r *collectorsNoteAddedToTokenFeedEventDataResolver) Owner(ctx context.Context, obj *model.CollectorsNoteAddedToTokenFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// Token is the resolver for the token field.
func (r *collectorsNoteAddedToTokenFeedEventDataResolver) Token(ctx context.Context, obj *model.CollectorsNoteAddedToTokenFeedEventData) (*model.CollectionToken, error) {
	return resolveCollectionTokenByID(ctx, obj.Token.Token.Dbid, obj.Token.Collection.Dbid)
}

// ReplyTo is the resolver for the replyTo field.
func (r *commentResolver) ReplyTo(ctx context.Context, obj *model.Comment) (*model.Comment, error) {
	if obj.ReplyToID == nil {
		return nil, nil
	}
	return resolveCommentByCommentID(ctx, *obj.ReplyToID)
}

// Commenter is the resolver for the commenter field.
func (r *commentResolver) Commenter(ctx context.Context, obj *model.Comment) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Commenter.Dbid)
}

// Mentions is the resolver for the mentions field.
func (r *commentResolver) Mentions(ctx context.Context, obj *model.Comment) ([]*model.Mention, error) {
	return resolveMentionsByCommentID(ctx, obj.Dbid)
}

// Replies is the resolver for the replies field.
func (r *commentResolver) Replies(ctx context.Context, obj *model.Comment, before *string, after *string, first *int, last *int) (*model.CommentsConnection, error) {
	comments, pageInfo, err := publicapi.For(ctx).Interaction.PaginateRepliesByCommentID(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	var edges []*model.CommentEdge
	for _, comment := range comments {
		edges = append(edges, &model.CommentEdge{
			Node: commentToModel(ctx, comment),
		})
	}
	return &model.CommentsConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// Source is the resolver for the source field.
func (r *commentResolver) Source(ctx context.Context, obj *model.Comment) (model.CommentSource, error) {
	if obj.PostID != nil {
		return resolvePostByPostID(ctx, *obj.PostID)
	}
	if obj.FeedEventID != nil {
		return resolveFeedEventByEventID(ctx, *obj.FeedEventID)
	}

	return nil, fmt.Errorf("comment has no source")
}

// Comment is the resolver for the comment field.
func (r *commentOnFeedEventPayloadResolver) Comment(ctx context.Context, obj *model.CommentOnFeedEventPayload) (*model.Comment, error) {
	return resolveCommentByCommentID(ctx, obj.Comment.Dbid)
}

// ReplyToComment is the resolver for the replyToComment field.
func (r *commentOnFeedEventPayloadResolver) ReplyToComment(ctx context.Context, obj *model.CommentOnFeedEventPayload) (*model.Comment, error) {
	if obj.ReplyToComment == nil {
		return nil, nil
	}
	return resolveCommentByCommentID(ctx, obj.ReplyToComment.Dbid)
}

// FeedEvent is the resolver for the feedEvent field.
func (r *commentOnFeedEventPayloadResolver) FeedEvent(ctx context.Context, obj *model.CommentOnFeedEventPayload) (*model.FeedEvent, error) {
	return resolveFeedEventByEventID(ctx, obj.FeedEvent.Dbid)
}

// Post is the resolver for the post field.
func (r *commentOnPostPayloadResolver) Post(ctx context.Context, obj *model.CommentOnPostPayload) (*model.Post, error) {
	return resolvePostByPostID(ctx, obj.Post.Dbid)
}

// Comment is the resolver for the comment field.
func (r *commentOnPostPayloadResolver) Comment(ctx context.Context, obj *model.CommentOnPostPayload) (*model.Comment, error) {
	return resolveCommentByCommentID(ctx, obj.Comment.Dbid)
}

// ReplyToComment is the resolver for the replyToComment field.
func (r *commentOnPostPayloadResolver) ReplyToComment(ctx context.Context, obj *model.CommentOnPostPayload) (*model.Comment, error) {
	if obj.ReplyToComment == nil {
		return nil, nil
	}
	return resolveCommentByCommentID(ctx, obj.ReplyToComment.Dbid)
}

// Creator is the resolver for the creator field.
func (r *communityResolver) Creator(ctx context.Context, obj *model.Community) (model.GalleryUserOrAddress, error) {
	creator, err := publicapi.For(ctx).Contract.GetContractCreatorByContractID(ctx, obj.Dbid)
	if err != nil {
		if util.ErrorAs[persist.ErrContractCreatorNotFound](err) {
			// It's normal not to find a creator for a community -- we may not have an address available.
			// If that happens, just return nil to the frontend to signify that there is no creator.
			return nil, nil
		}
		return nil, err
	}

	if creator.CreatorUserID != "" {
		return resolveGalleryUserByUserID(ctx, creator.CreatorUserID)
	}

	if creator.CreatorAddress != "" {
		return util.ToPointer(persist.NewChainAddress(creator.CreatorAddress, creator.Chain)), nil
	}

	// We should never get here: if our query returns a contract creator, there has to be an associated address or user ID.
	return nil, fmt.Errorf("contract creator for community ID=%s is invalid: must have either an address or a user ID", obj.Dbid)
}

// ParentCommunity is the resolver for the parentCommunity field.
func (r *communityResolver) ParentCommunity(ctx context.Context, obj *model.Community) (*model.CommunityLink, error) {
	if obj.HelperCommunityData.ParentID == "" {
		return nil, nil
	}

	contract, err := publicapi.For(ctx).Contract.GetContractByID(ctx, obj.ParentCommunity.Node.Dbid)
	if err != nil {
		return nil, err
	}

	obj.ParentCommunity.Node = communityToModel(ctx, *contract, obj.ParentCommunity.Node.ForceRefresh)
	return obj.ParentCommunity, nil
}

// SubCommunities is the resolver for the subCommunities field.
func (r *communityResolver) SubCommunities(ctx context.Context, obj *model.Community, before *string, after *string, first *int, last *int) (*model.CommunitiesConnection, error) {
	communities, pageInfo, err := publicapi.For(ctx).Contract.GetChildContractsByParentID(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.CommunityEdge, len(communities))
	for i, community := range communities {
		edges[i] = &model.CommunityEdge{
			Node:   communityToModel(ctx, community, util.ToPointer(false)),
			Cursor: nil, // not used by relay, but relay will complain without this field existing
		}
	}

	return &model.CommunitiesConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// TokensInCommunity is the resolver for the tokensInCommunity field.
func (r *communityResolver) TokensInCommunity(ctx context.Context, obj *model.Community, before *string, after *string, first *int, last *int, onlyGalleryUsers *bool) (*model.TokensConnection, error) {
	onlyUsers := util.GetOptionalValue(onlyGalleryUsers, true)
	forceRefresh := util.GetOptionalValue(obj.ForceRefresh, false)

	if !onlyUsers {
		err := refreshTokensInContractAsync(ctx, obj.Dbid, forceRefresh)
		if err != nil {
			return nil, err
		}
	}

	return resolveTokensByContractIDWithPagination(ctx, obj.Dbid, before, after, first, last, onlyUsers)
}

// Owners is the resolver for the owners field.
func (r *communityResolver) Owners(ctx context.Context, obj *model.Community, before *string, after *string, first *int, last *int, onlyGalleryUsers *bool) (*model.TokenHoldersConnection, error) {
	onlyUsers := util.GetOptionalValue(onlyGalleryUsers, true)
	forceRefresh := util.GetOptionalValue(obj.ForceRefresh, false)

	if !onlyUsers {
		err := refreshTokensInContractAsync(ctx, obj.Dbid, forceRefresh)
		if err != nil {
			return nil, err
		}
	}

	return resolveCommunityOwnersByContractID(ctx, obj.Dbid, before, after, first, last, onlyUsers)
}

// Posts is the resolver for the posts field.
func (r *communityResolver) Posts(ctx context.Context, obj *model.Community, before *string, after *string, first *int, last *int) (*model.PostsConnection, error) {
	return resolveCommunityPostsByContractID(ctx, obj.Dbid, before, after, first, last)
}

// TmpPostsWithProjectID is the resolver for the tmpPostsWithProjectID field.
func (r *communityResolver) TmpPostsWithProjectID(ctx context.Context, obj *model.Community, projectID int, before *string, after *string, first *int, last *int) (*model.PostsConnection, error) {
	posts, pageInfo, err := publicapi.For(ctx).Contract.GetCommunityPostsByContractIDAndProjectID(ctx, obj.Dbid, projectID, before, after, first, last)
	if err != nil {
		return nil, err
	}
	connection := postsToConnection(ctx, posts, obj.Dbid, pageInfo)
	return &connection, nil
}

// MintURL is the resolver for the mintURL field.
func (r *contractResolver) MintURL(ctx context.Context, obj *model.Contract) (*string, error) {
	c, err := publicapi.For(ctx).Contract.GetContractByID(ctx, obj.Dbid)
	if err != nil {
		return nil, err
	}

	if c.MintUrl.String != "" {
		return &c.MintUrl.String, nil
	}

	var mintURL *string

	if c.Address != "" && !c.IsProviderMarkedSpam {
		if c.Chain == persist.ChainZora {
			*mintURL = fmt.Sprintf("https://zora.co/collect/zora:%s", c.Address)
		} else if c.Chain == persist.ChainBase {
			*mintURL = fmt.Sprintf("https://mint.fun/base/%s", c.Address)
		} else if c.Chain == persist.ChainOptimism {
			*mintURL = fmt.Sprintf("https://mint.fun/op/%s", c.Address)
		} else if c.Chain == persist.ChainETH {
			*mintURL = fmt.Sprintf("https://mint.fun/ethereum/%s", c.Address)
		} else if c.Chain == persist.ChainTezos {
			contract, err := tezos.GetContractByAddress(ctx, c.Address)
			if err != nil {
				logger.For(ctx).Errorf("failed to get tezos mint URL for contractID=%s: %s", c.ID, err)
				sentryutil.ReportError(ctx, err)
			}
			*mintURL = contract.Descriptors.MintURL
		}
		// Set the mint URL so we don't have to do this again
		if mintURL != nil {
			err := publicapi.For(ctx).Contract.SetMintURL(ctx, c.ID, *mintURL)
			if err != nil {
				logger.For(ctx).Errorf("failed to set mint URL for contractID=%s: %s", c.ID, err)
				sentryutil.ReportError(ctx, err)
			}
		}
	}

	return mintURL, nil
}

// FeedEvent is the resolver for the feedEvent field.
func (r *createCollectionPayloadResolver) FeedEvent(ctx context.Context, obj *model.CreateCollectionPayload) (*model.FeedEvent, error) {
	if obj.FeedEvent.Dbid == "" {
		return nil, nil
	}
	return resolveFeedEventByEventID(ctx, obj.FeedEvent.Dbid)
}

// Wallet is the resolver for the wallet field.
func (r *ensProfileImageResolver) Wallet(ctx context.Context, obj *model.EnsProfileImage) (*model.Wallet, error) {
	if obj.HelperEnsProfileImageData.WalletID == "" {
		return nil, nil
	}
	return resolveWalletByWalletID(ctx, obj.HelperEnsProfileImageData.WalletID)
}

// Token is the resolver for the token field.
func (r *ensProfileImageResolver) Token(ctx context.Context, obj *model.EnsProfileImage) (*model.Token, error) {
	if obj.HelperEnsProfileImageData.EnsDomain == "" || obj.HelperEnsProfileImageData.UserID == "" {
		return nil, nil
	}
	return resolveTokenByEnsDomain(ctx, obj.HelperEnsProfileImageData.UserID, obj.HelperEnsProfileImageData.EnsDomain)
}

// EventData is the resolver for the eventData field.
func (r *feedEventResolver) EventData(ctx context.Context, obj *model.FeedEvent) (model.FeedEventData, error) {
	return resolveFeedEventDataByEventID(ctx, obj.Dbid)
}

// Admires is the resolver for the admires field.
func (r *feedEventResolver) Admires(ctx context.Context, obj *model.FeedEvent, before *string, after *string, first *int, last *int) (*model.FeedEventAdmiresConnection, error) {
	admires, pageInfo, err := publicapi.For(ctx).Interaction.PaginateAdmiresByFeedEventID(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	var edges []*model.FeedEventAdmireEdge
	for _, admire := range admires {
		edges = append(edges, &model.FeedEventAdmireEdge{
			Node: admireToModel(ctx, admire),
		})
	}

	return &model.FeedEventAdmiresConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// Comments is the resolver for the comments field.
func (r *feedEventResolver) Comments(ctx context.Context, obj *model.FeedEvent, before *string, after *string, first *int, last *int) (*model.FeedEventCommentsConnection, error) {
	comments, pageInfo, err := publicapi.For(ctx).Interaction.PaginateCommentsByFeedEventID(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	var edges []*model.FeedEventCommentEdge
	for _, comment := range comments {
		edges = append(edges, &model.FeedEventCommentEdge{
			Node: commentToModel(ctx, comment),
		})
	}

	return &model.FeedEventCommentsConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// Interactions is the resolver for the interactions field.
func (r *feedEventResolver) Interactions(ctx context.Context, obj *model.FeedEvent, before *string, after *string, first *int, last *int) (*model.InteractionsConnection, error) {
	interactions, pageInfo, err := publicapi.For(ctx).Interaction.PaginateInteractionsByFeedEventID(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	var edges []*model.InteractionsEdge
	for _, interaction := range interactions {
		edge := &model.InteractionsEdge{}
		if admire, ok := interaction.(coredb.Admire); ok {
			edge.Node = admireToModel(ctx, admire)
		} else if comment, ok := interaction.(coredb.Comment); ok {
			edge.Node = commentToModel(ctx, comment)
		}
		edges = append(edges, edge)
	}

	return &model.InteractionsConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// ViewerAdmire is the resolver for the viewerAdmire field.
func (r *feedEventResolver) ViewerAdmire(ctx context.Context, obj *model.FeedEvent) (*model.Admire, error) {
	api := publicapi.For(ctx)

	// If the user isn't logged in, there is no viewer
	if !api.User.IsUserLoggedIn(ctx) {
		return nil, nil
	}

	userID := api.User.GetLoggedInUserId(ctx)

	admire, err := api.Interaction.GetAdmireByActorIDAndFeedEventID(ctx, userID, obj.Dbid)
	if err != nil {
		// If getting the admire fails for any reason, just return nil. This resolver doesn't
		// return error types -- it just returns an admire (if it can find one) or nil.
		return nil, nil
	}

	return admireToModel(ctx, *admire), nil
}

// HasViewerAdmiredEvent is the resolver for the hasViewerAdmiredEvent field.
func (r *feedEventResolver) HasViewerAdmiredEvent(ctx context.Context, obj *model.FeedEvent) (*bool, error) {
	// Trivial implementation for backward compatibility; this will be removed soon
	f := false
	return &f, nil
}

// User is the resolver for the user field.
func (r *followInfoResolver) User(ctx context.Context, obj *model.FollowInfo) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.User.Dbid)
}

// User is the resolver for the user field.
func (r *followUserPayloadResolver) User(ctx context.Context, obj *model.FollowUserPayload) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.User.Dbid)
}

// TokenPreviews is the resolver for the tokenPreviews field.
func (r *galleryResolver) TokenPreviews(ctx context.Context, obj *model.Gallery) ([]*model.PreviewURLSet, error) {
	return resolveTokenPreviewsByGalleryID(ctx, obj.Dbid)
}

// Owner is the resolver for the owner field.
func (r *galleryResolver) Owner(ctx context.Context, obj *model.Gallery) (*model.GalleryUser, error) {
	gallery, err := publicapi.For(ctx).Gallery.GetGalleryById(ctx, obj.Dbid)

	if err != nil {
		return nil, err
	}

	return resolveGalleryUserByUserID(ctx, gallery.OwnerUserID)
}

// Collections is the resolver for the collections field.
func (r *galleryResolver) Collections(ctx context.Context, obj *model.Gallery) ([]*model.Collection, error) {
	return resolveCollectionsByGalleryID(ctx, obj.Dbid)
}

// Owner is the resolver for the owner field.
func (r *galleryInfoUpdatedFeedEventDataResolver) Owner(ctx context.Context, obj *model.GalleryInfoUpdatedFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// Owner is the resolver for the owner field.
func (r *galleryUpdatedFeedEventDataResolver) Owner(ctx context.Context, obj *model.GalleryUpdatedFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// Gallery is the resolver for the gallery field.
func (r *galleryUpdatedFeedEventDataResolver) Gallery(ctx context.Context, obj *model.GalleryUpdatedFeedEventData) (*model.Gallery, error) {
	return resolveGalleryByGalleryID(ctx, obj.Gallery.Dbid)
}

// SubEventDatas is the resolver for the subEventDatas field.
func (r *galleryUpdatedFeedEventDataResolver) SubEventDatas(ctx context.Context, obj *model.GalleryUpdatedFeedEventData) ([]model.FeedEventData, error) {
	return resolveSubEventDatasByFeedEventID(ctx, obj.FeedEventID)
}

// ProfileImage is the resolver for the profileImage field.
func (r *galleryUserResolver) ProfileImage(ctx context.Context, obj *model.GalleryUser) (model.ProfileImage, error) {
	pfp, err := publicapi.For(ctx).User.GetProfileImageByUserID(ctx, obj.Dbid)
	if err != nil && util.ErrorAs[persist.ErrProfileImageNotFound](err) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return profileImageToModel(ctx, pfp)
}

// PotentialEnsProfileImage is the resolver for the potentialEnsProfileImage field.
func (r *galleryUserResolver) PotentialEnsProfileImage(ctx context.Context, obj *model.GalleryUser) (*model.EnsProfileImage, error) {
	a, err := publicapi.For(ctx).User.GetPotentialENSProfileImageByUserID(ctx, obj.Dbid)
	if err != nil && (errors.Is(err, eth.ErrNoResolution) || errors.Is(err, eth.ErrNoAvatarRecord)) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return ensProfileImageToModel(ctx, obj.Dbid, a.WalletID, a.URI, a.Domain)
}

// Roles is the resolver for the roles field.
func (r *galleryUserResolver) Roles(ctx context.Context, obj *model.GalleryUser) ([]*persist.Role, error) {
	dbRoles, err := publicapi.For(ctx).User.GetUserRolesByUserID(ctx, obj.Dbid)
	if err != nil {
		return nil, err
	}

	roles := make([]*persist.Role, len(dbRoles))
	for i, role := range dbRoles {
		r := role
		roles[i] = &r
	}

	return roles, nil
}

// SocialAccounts is the resolver for the socialAccounts field.
func (r *galleryUserResolver) SocialAccounts(ctx context.Context, obj *model.GalleryUser) (*model.SocialAccounts, error) {
	return resolveUserSocialsByUserID(ctx, obj.Dbid)
}

// Tokens is the resolver for the tokens field.
func (r *galleryUserResolver) Tokens(ctx context.Context, obj *model.GalleryUser, ownershipFilter []persist.TokenOwnershipType) ([]*model.Token, error) {
	tokens, err := publicapi.For(ctx).Token.GetTokensByUserID(ctx, obj.Dbid, ownershipFilter)

	if err != nil {
		return nil, err
	}

	return tokensToModel(ctx, tokens), nil
}

// Wallets is the resolver for the wallets field.
func (r *galleryUserResolver) Wallets(ctx context.Context, obj *model.GalleryUser) ([]*model.Wallet, error) {
	return resolveWalletsByUserID(ctx, obj.Dbid)
}

// PrimaryWallet is the resolver for the primaryWallet field.
func (r *galleryUserResolver) PrimaryWallet(ctx context.Context, obj *model.GalleryUser) (*model.Wallet, error) {
	return resolvePrimaryWalletByUserID(ctx, obj.HelperGalleryUserData.UserID)
}

// FeaturedGallery is the resolver for the featuredGallery field.
func (r *galleryUserResolver) FeaturedGallery(ctx context.Context, obj *model.GalleryUser) (*model.Gallery, error) {
	if obj.HelperGalleryUserData.FeaturedGalleryID == nil {
		return nil, nil
	}

	return resolveGalleryByGalleryID(ctx, *obj.HelperGalleryUserData.FeaturedGalleryID)
}

// Galleries is the resolver for the galleries field.
func (r *galleryUserResolver) Galleries(ctx context.Context, obj *model.GalleryUser) ([]*model.Gallery, error) {
	return resolveGalleriesByUserID(ctx, obj.Dbid)
}

// Badges is the resolver for the badges field.
func (r *galleryUserResolver) Badges(ctx context.Context, obj *model.GalleryUser) ([]*model.Badge, error) {
	return resolveBadgesByUserID(ctx, obj.Dbid, obj.Traits)
}

// Followers is the resolver for the followers field.
func (r *galleryUserResolver) Followers(ctx context.Context, obj *model.GalleryUser) ([]*model.GalleryUser, error) {
	return resolveFollowersByUserID(ctx, obj.Dbid)
}

// Following is the resolver for the following field.
func (r *galleryUserResolver) Following(ctx context.Context, obj *model.GalleryUser) ([]*model.GalleryUser, error) {
	return resolveFollowingByUserID(ctx, obj.Dbid)
}

// Feed is the resolver for the feed field.
func (r *galleryUserResolver) Feed(ctx context.Context, obj *model.GalleryUser, before *string, after *string, first *int, last *int, includePosts bool) (*model.FeedConnection, error) {
	events, pageInfo, err := publicapi.For(ctx).Feed.UserFeed(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges, err := entitiesToFeedEdges(events)
	if err != nil {
		return nil, err
	}

	return &model.FeedConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// SharedFollowers is the resolver for the sharedFollowers field.
func (r *galleryUserResolver) SharedFollowers(ctx context.Context, obj *model.GalleryUser, before *string, after *string, first *int, last *int) (*model.UsersConnection, error) {
	users, pageInfo, err := publicapi.For(ctx).User.SharedFollowers(ctx, obj.UserID, before, after, first, last)
	if err != nil {
		return nil, err
	}

	return &model.UsersConnection{
		Edges:    usersToEdges(ctx, users),
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// SharedCommunities is the resolver for the sharedCommunities field.
func (r *galleryUserResolver) SharedCommunities(ctx context.Context, obj *model.GalleryUser, before *string, after *string, first *int, last *int) (*model.CommunitiesConnection, error) {
	communities, pageInfo, err := publicapi.For(ctx).User.SharedCommunities(ctx, obj.UserID, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.CommunityEdge, len(communities))
	for i, community := range communities {
		edges[i] = &model.CommunityEdge{
			Node:   communityToModel(ctx, community, util.ToPointer(false)),
			Cursor: nil, // not used by relay, but relay will complain without this field existing
		}
	}

	return &model.CommunitiesConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// CreatedCommunities is the resolver for the createdCommunities field.
func (r *galleryUserResolver) CreatedCommunities(ctx context.Context, obj *model.GalleryUser, input model.CreatedCommunitiesInput, before *string, after *string, first *int, last *int) (*model.CommunitiesConnection, error) {
	communities, pageInfo, err := publicapi.For(ctx).User.CreatedCommunities(ctx, obj.UserID, input.IncludeChains, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.CommunityEdge, len(communities))
	for i, community := range communities {
		edges[i] = &model.CommunityEdge{
			Node:   communityToModel(ctx, community, util.ToPointer(false)),
			Cursor: nil, // not used by relay, but relay will complain without this field existing
		}
	}

	return &model.CommunitiesConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// IsMemberOfCommunity is the resolver for the isMemberOfCommunity field.
func (r *galleryUserResolver) IsMemberOfCommunity(ctx context.Context, obj *model.GalleryUser, communityID persist.DBID) (bool, error) {
	return publicapi.For(ctx).User.IsMemberOfCommunity(ctx, obj.Dbid, communityID)
}

// Entity is the resolver for the entity field.
func (r *mentionResolver) Entity(ctx context.Context, obj *model.Mention) (model.MentionEntity, error) {
	if obj.CommunityID != nil {
		return resolveCommunityByID(ctx, *obj.CommunityID)
	}
	if obj.UserID != nil {
		return resolveGalleryUserByUserID(ctx, *obj.UserID)
	}
	return nil, fmt.Errorf("mention has no entity")
}

// AddUserWallet is the resolver for the addUserWallet field.
func (r *mutationResolver) AddUserWallet(ctx context.Context, chainAddress persist.ChainAddress, authMechanism model.AuthMechanism) (model.AddUserWalletPayloadOrError, error) {
	api := publicapi.For(ctx)

	authenticator, err := r.authMechanismToAuthenticator(ctx, authMechanism)
	if err != nil {
		return nil, err
	}

	err = api.User.AddWalletToUser(ctx, chainAddress, authenticator)
	if err != nil {
		return nil, err
	}

	output := &model.AddUserWalletPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// RemoveUserWallets is the resolver for the removeUserWallets field.
func (r *mutationResolver) RemoveUserWallets(ctx context.Context, walletIds []persist.DBID) (model.RemoveUserWalletsPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.User.RemoveWalletsFromUser(ctx, walletIds)
	if err != nil {
		return nil, err
	}

	output := &model.RemoveUserWalletsPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// UpdateUserInfo is the resolver for the updateUserInfo field.
func (r *mutationResolver) UpdateUserInfo(ctx context.Context, input model.UpdateUserInfoInput) (model.UpdateUserInfoPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.User.UpdateUserInfo(ctx, input.Username, input.Bio)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateUserInfoPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// RegisterUserPushToken is the resolver for the registerUserPushToken field.
func (r *mutationResolver) RegisterUserPushToken(ctx context.Context, pushToken string) (model.RegisterUserPushTokenPayloadOrError, error) {
	_, err := publicapi.For(ctx).User.CreatePushTokenForUser(ctx, pushToken)
	if err != nil {
		return nil, err
	}

	output := &model.RegisterUserPushTokenPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// UnregisterUserPushToken is the resolver for the unregisterUserPushToken field.
func (r *mutationResolver) UnregisterUserPushToken(ctx context.Context, pushToken string) (model.UnregisterUserPushTokenPayloadOrError, error) {
	err := publicapi.For(ctx).User.DeletePushTokenByPushToken(ctx, pushToken)
	if err != nil {
		return nil, err
	}

	output := &model.UnregisterUserPushTokenPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// SetProfileImage is the resolver for the setProfileImage field.
func (r *mutationResolver) SetProfileImage(ctx context.Context, input model.SetProfileImageInput) (model.SetProfileImagePayloadOrError, error) {
	err := publicapi.For(ctx).User.SetProfileImage(ctx, input.TokenID, input.WalletAddress)
	if err != nil {
		return nil, err
	}
	return &model.SetProfileImagePayload{Viewer: resolveViewer(ctx)}, nil
}

// RemoveProfileImage is the resolver for the removeProfileImage field.
func (r *mutationResolver) RemoveProfileImage(ctx context.Context) (model.RemoveProfileImagePayloadOrError, error) {
	err := publicapi.For(ctx).User.RemoveProfileImage(ctx)
	if err != nil {
		return nil, err
	}
	return &model.RemoveProfileImagePayload{Viewer: resolveViewer(ctx)}, nil
}

// ReportPost is the resolver for the reportPost field.
func (r *mutationResolver) ReportPost(ctx context.Context, postID persist.DBID, reason persist.ReportReason) (model.ReportPostPayloadOrError, error) {
	err := publicapi.For(ctx).Interaction.ReportPost(ctx, postID, reason)
	if err != nil {
		return nil, err
	}
	return model.ReportPostPayload{PostID: postID}, nil
}

// BlockUser is the resolver for the blockUser field.
func (r *mutationResolver) BlockUser(ctx context.Context, userID persist.DBID) (model.BlockUserPayloadOrError, error) {
	err := publicapi.For(ctx).User.BlockUser(ctx, userID)
	if err != nil {
		return nil, err
	}
	return model.BlockUserPayload{UserID: userID}, nil
}

// UnblockUser is the resolver for the unblockUser field.
func (r *mutationResolver) UnblockUser(ctx context.Context, userID persist.DBID) (model.UnblockUserPayloadOrError, error) {
	err := publicapi.For(ctx).User.UnblockUser(ctx, userID)
	if err != nil {
		return nil, err
	}
	return model.UnblockUserPayload{UserID: userID}, nil
}

// UpdateGalleryCollections is the resolver for the updateGalleryCollections field.
func (r *mutationResolver) UpdateGalleryCollections(ctx context.Context, input model.UpdateGalleryCollectionsInput) (model.UpdateGalleryCollectionsPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.Gallery.UpdateGalleryCollections(ctx, input.GalleryID, input.Collections)
	if err != nil {
		return nil, err
	}

	gallery, err := api.Gallery.GetGalleryById(ctx, input.GalleryID)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateGalleryCollectionsPayload{
		Gallery: galleryToModel(ctx, *gallery),
	}

	return output, nil
}

// CreateCollection is the resolver for the createCollection field.
func (r *mutationResolver) CreateCollection(ctx context.Context, input model.CreateCollectionInput) (model.CreateCollectionPayloadOrError, error) {
	api := publicapi.For(ctx)

	sectionLayout := make([]persist.CollectionSectionLayout, len(input.Layout.SectionLayout))
	for i, layout := range input.Layout.SectionLayout {
		sectionLayout[i] = persist.CollectionSectionLayout{
			Columns:    persist.NullInt32(layout.Columns),
			Whitespace: layout.Whitespace,
		}
	}

	layout := persist.TokenLayout{
		Sections:      persist.StandardizeCollectionSections(input.Layout.Sections),
		SectionLayout: sectionLayout,
	}

	settings := make(map[persist.DBID]persist.CollectionTokenSettings)
	for _, tokenSetting := range input.TokenSettings {
		settings[tokenSetting.TokenID] = persist.CollectionTokenSettings{RenderLive: tokenSetting.RenderLive, HighDefinition: tokenSetting.HighDefinition}
	}

	collection, feedEvent, err := api.Collection.CreateCollection(ctx, input.GalleryID, input.Name, input.CollectorsNote, input.Tokens, layout, settings, input.Caption)
	if err != nil {
		return nil, err
	}

	var eventModel model.FeedEvent
	if feedEvent != nil {
		eventModel = model.FeedEvent{Dbid: feedEvent.ID}
	}

	output := model.CreateCollectionPayload{
		Collection: collectionToModel(ctx, *collection),
		FeedEvent:  &eventModel,
	}

	return output, nil
}

// DeleteCollection is the resolver for the deleteCollection field.
func (r *mutationResolver) DeleteCollection(ctx context.Context, collectionID persist.DBID) (model.DeleteCollectionPayloadOrError, error) {
	api := publicapi.For(ctx)

	// Make sure the collection exists before trying to delete it
	_, err := api.Collection.GetCollectionById(ctx, collectionID)
	if err != nil {
		return nil, err
	}

	// Get the collection's parent gallery before deleting the collection
	gallery, err := api.Gallery.GetGalleryByCollectionId(ctx, collectionID)
	if err != nil {
		return nil, err
	}

	err = api.Collection.DeleteCollection(ctx, collectionID)
	if err != nil {
		return nil, err
	}

	// Deleting a collection marks the collection as "deleted" but doesn't alter the gallery,
	// so we don't need to refetch the gallery before returning it here
	output := &model.DeleteCollectionPayload{
		Gallery: galleryToModel(ctx, *gallery),
	}

	return output, nil
}

// UpdateCollectionInfo is the resolver for the updateCollectionInfo field.
func (r *mutationResolver) UpdateCollectionInfo(ctx context.Context, input model.UpdateCollectionInfoInput) (model.UpdateCollectionInfoPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.Collection.UpdateCollectionInfo(ctx, input.CollectionID, input.Name, input.CollectorsNote)

	if err != nil {
		return nil, err
	}

	collection, err := api.Collection.GetCollectionById(ctx, input.CollectionID)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateCollectionInfoPayload{
		Collection: collectionToModel(ctx, *collection),
	}

	return output, nil
}

// UpdateCollectionTokens is the resolver for the updateCollectionTokens field.
func (r *mutationResolver) UpdateCollectionTokens(ctx context.Context, input model.UpdateCollectionTokensInput) (model.UpdateCollectionTokensPayloadOrError, error) {
	api := publicapi.For(ctx)

	sectionLayout := make([]persist.CollectionSectionLayout, len(input.Layout.SectionLayout))
	for i, layout := range input.Layout.SectionLayout {
		sectionLayout[i] = persist.CollectionSectionLayout{
			Columns:    persist.NullInt32(layout.Columns),
			Whitespace: layout.Whitespace,
		}
	}

	layout := persist.TokenLayout{
		Sections:      persist.StandardizeCollectionSections(input.Layout.Sections),
		SectionLayout: sectionLayout,
	}

	settings := make(map[persist.DBID]persist.CollectionTokenSettings)
	for _, tokenSetting := range input.TokenSettings {
		settings[tokenSetting.TokenID] = persist.CollectionTokenSettings{RenderLive: tokenSetting.RenderLive, HighDefinition: tokenSetting.HighDefinition}
	}

	feedEvent, err := api.Collection.UpdateCollectionTokens(ctx, input.CollectionID, input.Tokens, layout, settings, input.Caption)
	if err != nil {
		return nil, err
	}

	collection, err := api.Collection.GetCollectionById(ctx, input.CollectionID)
	if err != nil {
		return nil, err
	}

	var eventModel model.FeedEvent
	if feedEvent != nil {
		eventModel = model.FeedEvent{Dbid: feedEvent.ID}
	}

	output := &model.UpdateCollectionTokensPayload{
		Collection: collectionToModel(ctx, *collection),
		FeedEvent:  &eventModel,
	}

	return output, nil
}

// UpdateCollectionHidden is the resolver for the updateCollectionHidden field.
func (r *mutationResolver) UpdateCollectionHidden(ctx context.Context, input model.UpdateCollectionHiddenInput) (model.UpdateCollectionHiddenPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.Collection.UpdateCollectionHidden(ctx, input.CollectionID, input.Hidden)
	if err != nil {
		return nil, err
	}

	collection, err := api.Collection.GetCollectionById(ctx, input.CollectionID)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateCollectionHiddenPayload{
		Collection: collectionToModel(ctx, *collection),
	}

	return output, nil
}

// UpdateTokenInfo is the resolver for the updateTokenInfo field.
func (r *mutationResolver) UpdateTokenInfo(ctx context.Context, input model.UpdateTokenInfoInput) (model.UpdateTokenInfoPayloadOrError, error) {
	api := publicapi.For(ctx)

	collectionID := persist.DBID("")
	if input.CollectionID != nil {
		collectionID = *input.CollectionID
	}

	err := api.Token.UpdateTokenInfo(ctx, input.TokenID, collectionID, input.CollectorsNote)
	if err != nil {
		return nil, err
	}

	token, err := api.Token.GetTokenById(ctx, input.TokenID)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateTokenInfoPayload{
		Token: tokenToModel(ctx, *token, input.CollectionID),
	}

	return output, nil
}

// SetSpamPreference is the resolver for the setSpamPreference field.
func (r *mutationResolver) SetSpamPreference(ctx context.Context, input model.SetSpamPreferenceInput) (model.SetSpamPreferencePayloadOrError, error) {
	err := publicapi.For(ctx).Token.SetSpamPreference(ctx, input.Tokens, input.IsSpam)
	if err != nil {
		return nil, err
	}

	tokens := make([]*model.Token, len(input.Tokens))
	for i, tokenID := range input.Tokens {
		tokens[i] = &model.Token{Dbid: tokenID} // Remaining fields handled by dedicated resolver
	}

	return model.SetSpamPreferencePayload{Tokens: tokens}, nil
}

// SyncTokens is the resolver for the syncTokens field.
func (r *mutationResolver) SyncTokens(ctx context.Context, chains []persist.Chain, incrementally *bool) (model.SyncTokensPayloadOrError, error) {
	api := publicapi.For(ctx)

	if len(chains) == 0 {
		chains = []persist.Chain{persist.ChainETH}
	}

	err := api.Token.SyncTokens(ctx, chains, util.FromPointer(incrementally))
	if err != nil {
		return nil, err
	}

	output := &model.SyncTokensPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// SyncCreatedTokensForNewContracts is the resolver for the syncCreatedTokensForNewContracts field.
func (r *mutationResolver) SyncCreatedTokensForNewContracts(ctx context.Context, input model.SyncCreatedTokensForNewContractsInput) (model.SyncCreatedTokensForNewContractsPayloadOrError, error) {
	chains := input.IncludeChains
	if input.IncludeChains == nil || len(input.IncludeChains) == 0 {
		chains = persist.AllChains
	}

	err := publicapi.For(ctx).Token.SyncCreatedTokensForNewContracts(ctx, chains)
	if err != nil {
		return nil, err
	}

	return &model.SyncCreatedTokensForNewContractsPayload{Viewer: resolveViewer(ctx)}, nil
}

// SyncCreatedTokensForExistingContract is the resolver for the syncCreatedTokensForExistingContract field.
func (r *mutationResolver) SyncCreatedTokensForExistingContract(ctx context.Context, input model.SyncCreatedTokensForExistingContractInput) (model.SyncCreatedTokensForExistingContractPayloadOrError, error) {
	err := publicapi.For(ctx).Token.SyncCreatedTokensForExistingContract(ctx, input.ContractID)
	if err != nil {
		return nil, err
	}

	return &model.SyncCreatedTokensForExistingContractPayload{Viewer: resolveViewer(ctx)}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, tokenID persist.DBID) (model.RefreshTokenPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.Token.RefreshToken(ctx, tokenID)
	if err != nil {
		return nil, err
	}

	token, err := resolveTokenByTokenID(ctx, tokenID)
	if err != nil {
		return nil, err
	}

	output := &model.RefreshTokenPayload{
		Token: token,
	}

	return output, nil
}

// RefreshCollection is the resolver for the refreshCollection field.
func (r *mutationResolver) RefreshCollection(ctx context.Context, collectionID persist.DBID) (model.RefreshCollectionPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.Token.RefreshCollection(ctx, collectionID)
	if err != nil {
		return nil, err
	}

	collection, err := resolveCollectionByCollectionID(ctx, collectionID)
	if err != nil {
		return nil, err
	}

	output := &model.RefreshCollectionPayload{
		Collection: collection,
	}

	return output, nil
}

// RefreshContract is the resolver for the refreshContract field.
func (r *mutationResolver) RefreshContract(ctx context.Context, contractID persist.DBID) (model.RefreshContractPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.Contract.RefreshContract(ctx, contractID)
	if err != nil {
		return nil, err
	}

	contract, err := resolveContractByContractID(ctx, contractID)
	if err != nil {
		return nil, err
	}

	output := &model.RefreshContractPayload{
		Contract: contract,
	}

	return output, nil
}

// GetAuthNonce is the resolver for the getAuthNonce field.
func (r *mutationResolver) GetAuthNonce(ctx context.Context, chainAddress persist.ChainAddress) (model.GetAuthNoncePayloadOrError, error) {
	nonce, userExists, err := publicapi.For(ctx).Auth.GetAuthNonce(ctx, chainAddress)
	if err != nil {
		return nil, err
	}
	if err != nil {
		return nil, err
	}

	output := &model.AuthNonce{
		Nonce:      &nonce,
		UserExists: &userExists,
	}

	return output, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, authMechanism model.AuthMechanism, input model.CreateUserInput) (model.CreateUserPayloadOrError, error) {
	authenticator, err := r.authMechanismToAuthenticator(ctx, authMechanism)
	if err != nil {
		return nil, err
	}

	bioStr := ""
	nameStr := ""
	descStr := ""
	positionStr := ""
	if input.Bio != nil {
		bioStr = *input.Bio
	}
	if input.GalleryName != nil {
		nameStr = *input.GalleryName
	}
	if input.GalleryDescription != nil {
		descStr = *input.GalleryDescription
	}
	if input.GalleryPosition != nil {
		positionStr = *input.GalleryPosition
	}

	var email *persist.Email
	if input.Email != nil {
		it := persist.Email(*input.Email)
		email = &it
	}

	userID, galleryID, err := publicapi.For(ctx).User.CreateUser(ctx, authenticator, input.Username, email, bioStr, nameStr, descStr, positionStr)
	if err != nil {
		return nil, err
	}

	output := &model.CreateUserPayload{
		UserID:    &userID,
		GalleryID: &galleryID,
		Viewer:    resolveViewer(ctx),
	}

	return output, nil
}

// UpdateEmail is the resolver for the updateEmail field.
func (r *mutationResolver) UpdateEmail(ctx context.Context, input model.UpdateEmailInput) (model.UpdateEmailPayloadOrError, error) {
	return updateUserEmail(ctx, input.Email)
}

// ResendVerificationEmail is the resolver for the resendVerificationEmail field.
func (r *mutationResolver) ResendVerificationEmail(ctx context.Context) (model.ResendVerificationEmailPayloadOrError, error) {
	return resendEmailVerification(ctx)
}

// UpdateEmailNotificationSettings is the resolver for the updateEmailNotificationSettings field.
func (r *mutationResolver) UpdateEmailNotificationSettings(ctx context.Context, input model.UpdateEmailNotificationSettingsInput) (model.UpdateEmailNotificationSettingsPayloadOrError, error) {
	return updateUserEmailNotificationSettings(ctx, input)
}

// UnsubscribeFromEmailType is the resolver for the unsubscribeFromEmailType field.
func (r *mutationResolver) UnsubscribeFromEmailType(ctx context.Context, input model.UnsubscribeFromEmailTypeInput) (model.UnsubscribeFromEmailTypePayloadOrError, error) {
	return unsubscribeFromEmailType(ctx, input)
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, authMechanism model.AuthMechanism) (model.LoginPayloadOrError, error) {
	authenticator, err := r.authMechanismToAuthenticator(ctx, authMechanism)
	if err != nil {
		return nil, err
	}

	userId, err := publicapi.For(ctx).Auth.Login(ctx, authenticator)
	if err != nil {
		return nil, err
	}

	output := &model.LoginPayload{
		UserID: &userId,
		Viewer: resolveViewer(ctx),
	}
	return output, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, pushTokenToUnregister *string) (*model.LogoutPayload, error) {
	if pushTokenToUnregister != nil {
		err := publicapi.For(ctx).User.DeletePushTokenByPushToken(ctx, *pushTokenToUnregister)
		if err != nil {
			logger.For(ctx).Infof("failed to delete push token %s on logout: %s\n", *pushTokenToUnregister, err)
			return nil, err
		}
	}

	publicapi.For(ctx).Auth.Logout(ctx)

	output := &model.LogoutPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// ConnectSocialAccount is the resolver for the connectSocialAccount field.
func (r *mutationResolver) ConnectSocialAccount(ctx context.Context, input model.SocialAuthMechanism, display bool) (model.ConnectSocialAccountPayloadOrError, error) {
	authenticator, err := r.socialAuthMechanismToAuthenticator(ctx, input)
	if err != nil {
		return nil, err
	}
	err = publicapi.For(ctx).User.AddSocialAccountToUser(ctx, authenticator, display)
	if err != nil {
		return nil, err
	}
	output := &model.ConnectSocialAccountPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// DisconnectSocialAccount is the resolver for the disconnectSocialAccount field.
func (r *mutationResolver) DisconnectSocialAccount(ctx context.Context, accountType persist.SocialProvider) (model.DisconnectSocialAccountPayloadOrError, error) {
	err := publicapi.For(ctx).Social.DisconnectSocialAccount(ctx, accountType)
	if err != nil {
		return nil, err
	}

	return &model.DisconnectSocialAccountPayload{
		Viewer: resolveViewer(ctx),
	}, nil
}

// UpdateSocialAccountDisplayed is the resolver for the updateSocialAccountDisplayed field.
func (r *mutationResolver) UpdateSocialAccountDisplayed(ctx context.Context, input model.UpdateSocialAccountDisplayedInput) (model.UpdateSocialAccountDisplayedPayloadOrError, error) {
	err := publicapi.For(ctx).User.UpdateUserSocialDisplayed(ctx, input.Type, input.Displayed)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateSocialAccountDisplayedPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, userID persist.DBID) (model.FollowUserPayloadOrError, error) {
	err := publicapi.For(ctx).User.FollowUser(ctx, userID)

	if err != nil {
		return nil, err
	}

	output := &model.FollowUserPayload{
		Viewer: resolveViewer(ctx),
		User: &model.GalleryUser{
			Dbid: userID, // remaining fields handled by dedicated resolver
		},
	}

	return output, err
}

// FollowAllSocialConnections is the resolver for the followAllSocialConnections field.
func (r *mutationResolver) FollowAllSocialConnections(ctx context.Context, accountType persist.SocialProvider) (model.FollowAllSocialConnectionsPayloadOrError, error) {
	err := publicapi.For(ctx).User.FollowAllSocialConnections(ctx, accountType)
	if err != nil {
		return nil, err
	}

	output := &model.FollowAllSocialConnectionsPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// UnfollowUser is the resolver for the unfollowUser field.
func (r *mutationResolver) UnfollowUser(ctx context.Context, userID persist.DBID) (model.UnfollowUserPayloadOrError, error) {
	err := publicapi.For(ctx).User.UnfollowUser(ctx, userID)

	if err != nil {
		return nil, err
	}

	output := &model.UnfollowUserPayload{
		Viewer: resolveViewer(ctx),
		User: &model.GalleryUser{
			Dbid: userID, // remaining fields handled by dedicated resolver
		},
	}

	return output, err
}

// AdmireFeedEvent is the resolver for the admireFeedEvent field.
func (r *mutationResolver) AdmireFeedEvent(ctx context.Context, feedEventID persist.DBID) (model.AdmireFeedEventPayloadOrError, error) {
	id, err := publicapi.For(ctx).Interaction.AdmireFeedEvent(ctx, feedEventID)
	if err != nil {
		return nil, err
	}
	output := &model.AdmireFeedEventPayload{
		Viewer:    resolveViewer(ctx),
		Admire:    &model.Admire{Dbid: id},
		FeedEvent: &model.FeedEvent{Dbid: feedEventID},
	}
	return output, nil
}

// AdmirePost is the resolver for the admirePost field.
func (r *mutationResolver) AdmirePost(ctx context.Context, postID persist.DBID) (model.AdmirePostPayloadOrError, error) {
	id, err := publicapi.For(ctx).Interaction.AdmirePost(ctx, postID)
	if err != nil {
		return nil, err
	}
	output := &model.AdmirePostPayload{
		Viewer: resolveViewer(ctx),
		Admire: &model.Admire{Dbid: id},
		Post:   &model.Post{Dbid: postID},
	}
	return output, nil
}

// AdmireToken is the resolver for the admireToken field.
func (r *mutationResolver) AdmireToken(ctx context.Context, tokenID persist.DBID) (model.AdmireTokenPayloadOrError, error) {
	id, err := publicapi.For(ctx).Interaction.AdmireToken(ctx, tokenID)
	if err != nil {
		return nil, err
	}
	output := &model.AdmireTokenPayload{
		Viewer: resolveViewer(ctx),
		Admire: &model.Admire{Dbid: id},
		Token:  &model.Token{Dbid: tokenID},
	}
	return output, nil
}

// RemoveAdmire is the resolver for the removeAdmire field.
func (r *mutationResolver) RemoveAdmire(ctx context.Context, admireID persist.DBID) (model.RemoveAdmirePayloadOrError, error) {
	feedEventID, postID, err := publicapi.For(ctx).Interaction.RemoveAdmire(ctx, admireID)
	if err != nil {
		return nil, err
	}

	output := &model.RemoveAdmirePayload{
		Viewer:   resolveViewer(ctx),
		AdmireID: &admireID,
		FeedEvent: &model.FeedEvent{
			Dbid: feedEventID, // remaining fields handled by dedicated resolver
		},
		Post: &model.Post{
			Dbid: postID, // remaining fields handled by dedicated resolver
		},
	}
	return output, nil
}

// CommentOnFeedEvent is the resolver for the commentOnFeedEvent field.
func (r *mutationResolver) CommentOnFeedEvent(ctx context.Context, feedEventID persist.DBID, replyToID *persist.DBID, comment string, mentions []*model.MentionInput) (model.CommentOnFeedEventPayloadOrError, error) {
	id, err := publicapi.For(ctx).Interaction.CommentOnFeedEvent(ctx, feedEventID, replyToID, mentions, comment)
	if err != nil {
		return nil, err
	}

	output := &model.CommentOnFeedEventPayload{
		Viewer: resolveViewer(ctx),
		Comment: &model.Comment{
			Dbid: id,
		},
		FeedEvent: &model.FeedEvent{
			Dbid: feedEventID, // remaining fields handled by dedicated resolver
		},
	}
	if replyToID != nil {
		output.ReplyToComment = &model.Comment{
			Dbid: *replyToID, // remaining fields handled by dedicated resolver
		}
	}
	return output, nil
}

// RemoveComment is the resolver for the removeComment field.
func (r *mutationResolver) RemoveComment(ctx context.Context, commentID persist.DBID) (model.RemoveCommentPayloadOrError, error) {
	feedEvent, postID, err := publicapi.For(ctx).Interaction.RemoveComment(ctx, commentID)
	if err != nil {
		return nil, err
	}
	output := &model.RemoveCommentPayload{
		Viewer: resolveViewer(ctx),
		FeedEvent: &model.FeedEvent{
			Dbid: feedEvent,
		},
		Post: &model.Post{
			Dbid: postID,
		},
	}
	return output, nil
}

// CommentOnPost is the resolver for the commentOnPost field.
func (r *mutationResolver) CommentOnPost(ctx context.Context, postID persist.DBID, replyToID *persist.DBID, comment string, mentions []*model.MentionInput) (model.CommentOnPostPayloadOrError, error) {
	id, err := publicapi.For(ctx).Interaction.CommentOnPost(ctx, postID, replyToID, mentions, comment)
	if err != nil {
		return nil, err
	}

	output := &model.CommentOnPostPayload{
		Viewer: resolveViewer(ctx),
		Comment: &model.Comment{
			Dbid: id,
		},
		Post: &model.Post{Dbid: postID},
	}
	if replyToID != nil {
		output.ReplyToComment = &model.Comment{
			Dbid: *replyToID, // remaining fields handled by dedicated resolver
		}
	}
	return output, nil
}

// PostTokens is the resolver for the postTokens field.
func (r *mutationResolver) PostTokens(ctx context.Context, input model.PostTokensInput) (model.PostTokensPayloadOrError, error) {
	id, err := publicapi.For(ctx).Feed.PostTokens(ctx, input.TokenIds, input.Mentions, input.Caption)
	if err != nil {
		return nil, err
	}

	post, err := resolvePostByPostID(ctx, id)
	if err != nil {
		return nil, err
	}

	output := &model.PostTokensPayload{
		Post: post,
	}

	return output, nil
}

// ReferralPostToken is the resolver for the referralPostToken field.
func (r *mutationResolver) ReferralPostToken(ctx context.Context, input model.ReferralPostTokenInput) (model.ReferralPostTokenPayloadOrError, error) {
	token := persist.TokenIdentifiers{
		Chain:           input.Token.ChainAddress.Chain(),
		ContractAddress: input.Token.ChainAddress.Address(),
		TokenID:         input.Token.TokenID,
	}
	id, err := publicapi.For(ctx).Feed.ReferralPostToken(ctx, token, input.Caption)
	if err != nil {
		return nil, err
	}
	post, err := resolvePostByPostID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.ReferralPostTokenPayload{Post: post}, nil
}

// ReferralPostPreflight is the resolver for the referralPostPreflight field.
func (r *mutationResolver) ReferralPostPreflight(ctx context.Context, input model.ReferralPostPreflightInput) (model.ReferralPostPreflightPayloadOrError, error) {
	err := publicapi.For(ctx).Feed.ReferralPostPreflight(ctx, persist.TokenIdentifiers{
		Chain:           input.Token.ChainAddress.Chain(),
		ContractAddress: input.Token.ChainAddress.Address(),
		TokenID:         input.Token.TokenID,
	})
	return &model.ReferralPostPreflightPayload{Accepted: err == nil}, err
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, postID persist.DBID) (model.DeletePostPayloadOrError, error) {
	err := publicapi.For(ctx).Feed.DeletePostById(ctx, postID)
	if err != nil {
		return nil, err
	}

	output := &model.DeletePostPayload{
		DeletedID: &model.DeletedNode{
			Dbid: postID,
		},
	}
	return output, nil
}

// ViewGallery is the resolver for the viewGallery field.
func (r *mutationResolver) ViewGallery(ctx context.Context, galleryID persist.DBID) (model.ViewGalleryPayloadOrError, error) {
	gallery, err := publicapi.For(ctx).Gallery.ViewGallery(ctx, galleryID)
	if err != nil {
		return nil, err
	}

	output := &model.ViewGalleryPayload{
		Gallery: galleryToModel(ctx, gallery),
	}

	return output, nil
}

// ViewToken is the resolver for the viewToken field.
func (r *mutationResolver) ViewToken(ctx context.Context, tokenID persist.DBID, collectionID persist.DBID) (model.ViewTokenPayloadOrError, error) {
	_, err := publicapi.For(ctx).Token.ViewToken(ctx, tokenID, collectionID)
	if err != nil {
		return nil, err
	}

	token, err := resolveTokenByTokenID(ctx, tokenID)
	if err != nil {
		return nil, err
	}

	output := &model.ViewTokenPayload{
		Token: token,
	}

	return output, nil
}

// UpdateGallery is the resolver for the updateGallery field.
func (r *mutationResolver) UpdateGallery(ctx context.Context, input model.UpdateGalleryInput) (model.UpdateGalleryPayloadOrError, error) {
	res, err := publicapi.For(ctx).Gallery.UpdateGallery(ctx, input)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateGalleryPayload{
		Gallery: galleryToModel(ctx, res),
	}
	return output, nil
}

// PublishGallery is the resolver for the publishGallery field.
func (r *mutationResolver) PublishGallery(ctx context.Context, input model.PublishGalleryInput) (model.PublishGalleryPayloadOrError, error) {
	err := publicapi.For(ctx).Gallery.PublishGallery(ctx, input)
	if err != nil {
		return nil, err
	}

	gal, err := resolveGalleryByGalleryID(ctx, input.GalleryID)
	if err != nil {
		return nil, err
	}

	return &model.PublishGalleryPayload{
		Gallery: gal,
	}, nil
}

// CreateGallery is the resolver for the createGallery field.
func (r *mutationResolver) CreateGallery(ctx context.Context, input model.CreateGalleryInput) (model.CreateGalleryPayloadOrError, error) {
	gallery, err := publicapi.For(ctx).Gallery.CreateGallery(ctx, input.Name, input.Description, input.Position)
	if err != nil {
		return nil, err
	}

	output := &model.CreateGalleryPayload{
		Gallery: galleryToModel(ctx, gallery),
	}

	return output, nil
}

// UpdateGalleryHidden is the resolver for the updateGalleryHidden field.
func (r *mutationResolver) UpdateGalleryHidden(ctx context.Context, input model.UpdateGalleryHiddenInput) (model.UpdateGalleryHiddenPayloadOrError, error) {
	gallery, err := publicapi.For(ctx).Gallery.UpdateGalleryHidden(ctx, input.ID, input.Hidden)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateGalleryHiddenPayload{
		Gallery: galleryToModel(ctx, gallery),
	}

	return output, nil
}

// DeleteGallery is the resolver for the deleteGallery field.
func (r *mutationResolver) DeleteGallery(ctx context.Context, galleryID persist.DBID) (model.DeleteGalleryPayloadOrError, error) {
	err := publicapi.For(ctx).Gallery.DeleteGallery(ctx, galleryID)
	if err != nil {
		return nil, err
	}

	output := &model.DeleteGalleryPayload{
		DeletedID: &model.DeletedNode{
			Dbid: galleryID,
		},
	}

	return output, nil
}

// UpdateGalleryOrder is the resolver for the updateGalleryOrder field.
func (r *mutationResolver) UpdateGalleryOrder(ctx context.Context, input model.UpdateGalleryOrderInput) (model.UpdateGalleryOrderPayloadOrError, error) {
	err := publicapi.For(ctx).Gallery.UpdateGalleryPositions(ctx, input.Positions)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateGalleryOrderPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// UpdateGalleryInfo is the resolver for the updateGalleryInfo field.
func (r *mutationResolver) UpdateGalleryInfo(ctx context.Context, input model.UpdateGalleryInfoInput) (model.UpdateGalleryInfoPayloadOrError, error) {
	err := publicapi.For(ctx).Gallery.UpdateGalleryInfo(ctx, input.ID, input.Name, input.Description)
	if err != nil {
		return nil, err
	}

	gallery, err := resolveGalleryByGalleryID(ctx, input.ID)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateGalleryInfoPayload{
		Gallery: gallery,
	}

	return output, nil
}

// UpdateFeaturedGallery is the resolver for the updateFeaturedGallery field.
func (r *mutationResolver) UpdateFeaturedGallery(ctx context.Context, galleryID persist.DBID) (model.UpdateFeaturedGalleryPayloadOrError, error) {
	err := publicapi.For(ctx).User.UpdateFeaturedGallery(ctx, galleryID)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateFeaturedGalleryPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// ClearAllNotifications is the resolver for the clearAllNotifications field.
func (r *mutationResolver) ClearAllNotifications(ctx context.Context) (*model.ClearAllNotificationsPayload, error) {
	notifications, err := publicapi.For(ctx).Notifications.ClearUserNotifications(ctx)
	if err != nil {
		return nil, err
	}

	models := make([]model.Notification, len(notifications))
	for i, n := range notifications {
		model, err := notificationToModel(n)
		if err != nil {
			return nil, err
		}
		models[i] = model
	}

	output := &model.ClearAllNotificationsPayload{
		Notifications: models,
	}
	return output, nil
}

// UpdateNotificationSettings is the resolver for the updateNotificationSettings field.
func (r *mutationResolver) UpdateNotificationSettings(ctx context.Context, settings *model.NotificationSettingsInput) (*model.NotificationSettings, error) {
	err := publicapi.For(ctx).User.UpdateUserNotificationSettings(ctx, persist.UserNotificationSettings{
		SomeoneFollowedYou:           settings.SomeoneFollowedYou,
		SomeoneAdmiredYourUpdate:     settings.SomeoneAdmiredYourUpdate,
		SomeoneCommentedOnYourUpdate: settings.SomeoneCommentedOnYourUpdate,
		SomeoneViewedYourGallery:     settings.SomeoneViewedYourGallery,
	})
	if err != nil {
		return nil, err
	}
	return resolveViewerNotificationSettings(ctx)
}

// PreverifyEmail is the resolver for the preverifyEmail field.
func (r *mutationResolver) PreverifyEmail(ctx context.Context, input model.PreverifyEmailInput) (model.PreverifyEmailPayloadOrError, error) {
	// todo we could have the frontend send the source? right now I don't see any other sources of verification other than signing up
	result, err := emails.PreverifyEmail(ctx, input.Email, "signup")
	if err != nil {
		return nil, err
	}

	var modelResult model.PreverifyEmailResult

	switch result.Result {
	case emailService.PreverifyEmailResultValid:
		modelResult = model.PreverifyEmailResultValid
	case emailService.PreverifyEmailResultInvalid:
		modelResult = model.PreverifyEmailResultInvalid
	case emailService.PreverifyEmailResultRisky:
		modelResult = model.PreverifyEmailResultRisky
	default:
		return nil, fmt.Errorf("unknown preverify result: %d", result.Result)
	}

	return model.PreverifyEmailPayload{
		Email:  input.Email,
		Result: modelResult,
	}, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, input model.VerifyEmailInput) (model.VerifyEmailPayloadOrError, error) {
	return verifyEmail(ctx, input.Token)
}

// VerifyEmailMagicLink is the resolver for the verifyEmailMagicLink field.
func (r *mutationResolver) VerifyEmailMagicLink(ctx context.Context, input model.VerifyEmailMagicLinkInput) (model.VerifyEmailMagicLinkPayloadOrError, error) {
	_, err := publicapi.For(ctx).User.GetUserByVerifiedEmailAddress(ctx, input.Email)

	return model.VerifyEmailMagicLinkPayload{
		CanSend: err == nil,
	}, nil
}

// RedeemMerch is the resolver for the redeemMerch field.
func (r *mutationResolver) RedeemMerch(ctx context.Context, input model.RedeemMerchInput) (model.RedeemMerchPayloadOrError, error) {
	tokenIDList := make([]persist.TokenID, len(input.TokenIds))
	for i, id := range input.TokenIds {
		tokenIDList[i] = persist.TokenID(id)
	}
	if input.Address == nil {
		return nil, fmt.Errorf("address is required")
	}
	tokens, err := publicapi.For(ctx).Merch.RedeemMerchItems(ctx, tokenIDList, *input.Address, input.Signature, input.WalletType)
	if err != nil {
		return nil, err
	}

	output := &model.RedeemMerchPayload{
		Tokens: tokens,
	}
	return output, nil
}

// OptInForRoles is the resolver for the optInForRoles field.
func (r *mutationResolver) OptInForRoles(ctx context.Context, roles []persist.Role) (model.OptInForRolesPayloadOrError, error) {
	user, err := publicapi.For(ctx).User.OptInForRoles(ctx, roles)
	if err != nil {
		return nil, err
	}

	payload := model.OptInForRolesPayload{
		User: userToModel(ctx, *user),
	}

	return payload, nil
}

// OptOutForRoles is the resolver for the optOutForRoles field.
func (r *mutationResolver) OptOutForRoles(ctx context.Context, roles []persist.Role) (model.OptOutForRolesPayloadOrError, error) {
	user, err := publicapi.For(ctx).User.OptOutForRoles(ctx, roles)
	if err != nil {
		return nil, err
	}

	payload := model.OptOutForRolesPayload{
		User: userToModel(ctx, *user),
	}

	return payload, nil
}

// AddRolesToUser is the resolver for the addRolesToUser field.
func (r *mutationResolver) AddRolesToUser(ctx context.Context, username string, roles []*persist.Role) (model.AddRolesToUserPayloadOrError, error) {
	user, err := publicapi.For(ctx).Admin.AddRolesToUser(ctx, username, roles)

	if err != nil {
		return nil, err
	}

	return userToModel(ctx, *user), nil
}

// AddWalletToUserUnchecked is the resolver for the addWalletToUserUnchecked field.
func (r *mutationResolver) AddWalletToUserUnchecked(ctx context.Context, input model.AdminAddWalletInput) (model.AdminAddWalletPayloadOrError, error) {
	err := publicapi.For(ctx).Admin.AddWalletToUserUnchecked(ctx, input.Username, *input.ChainAddress, input.WalletType)
	if err != nil {
		return nil, err
	}

	user, err := publicapi.For(ctx).User.GetUserByUsername(ctx, input.Username)
	if err != nil {
		return nil, err
	}

	return model.AdminAddWalletPayload{User: userToModel(ctx, *user)}, nil
}

// RevokeRolesFromUser is the resolver for the revokeRolesFromUser field.
func (r *mutationResolver) RevokeRolesFromUser(ctx context.Context, username string, roles []*persist.Role) (model.RevokeRolesFromUserPayloadOrError, error) {
	user, err := publicapi.For(ctx).Admin.RemoveRolesFromUser(ctx, username, roles)

	if err != nil {
		return nil, err
	}

	return userToModel(ctx, *user), nil
}

// SyncTokensForUsername is the resolver for the syncTokensForUsername field.
func (r *mutationResolver) SyncTokensForUsername(ctx context.Context, username string, chains []persist.Chain) (model.SyncTokensForUsernamePayloadOrError, error) {
	api := publicapi.For(ctx)

	user, err := api.User.GetUserByUsername(ctx, username)

	if err != nil {
		return nil, err
	}

	if len(chains) == 0 {
		chains = []persist.Chain{persist.ChainETH}
	}

	err = api.Token.SyncTokensAdmin(ctx, chains, user.ID)
	if err != nil {
		return nil, err
	}

	output := &model.SyncTokensForUsernamePayload{
		Message: "Successfully synced tokens",
	}

	return output, nil
}

// SyncCreatedTokensForUsername is the resolver for the syncCreatedTokensForUsername field.
func (r *mutationResolver) SyncCreatedTokensForUsername(ctx context.Context, username string, chains []persist.Chain) (model.SyncCreatedTokensForUsernamePayloadOrError, error) {
	api := publicapi.For(ctx)

	user, err := api.User.GetUserByUsername(ctx, username)

	if err != nil {
		return nil, err
	}

	if len(chains) == 0 {
		chains = persist.AllChains
	}

	err = api.Token.SyncCreatedTokensAdmin(ctx, chains, user.ID)
	if err != nil {
		return nil, err
	}

	output := &model.SyncCreatedTokensForUsernamePayload{
		Message: "Successfully synced tokens",
	}

	return output, nil
}

// SyncCreatedTokensForUsernameAndExistingContract is the resolver for the syncCreatedTokensForUsernameAndExistingContract field.
func (r *mutationResolver) SyncCreatedTokensForUsernameAndExistingContract(ctx context.Context, username string, chainAddress persist.ChainAddress) (model.SyncCreatedTokensForUsernameAndExistingContractPayloadOrError, error) {
	api := publicapi.For(ctx)

	user, err := api.User.GetUserByUsername(ctx, username)

	if err != nil {
		return nil, err
	}

	err = api.Token.SyncCreatedTokensForExistingContractAdmin(ctx, user.ID, chainAddress)
	if err != nil {
		return nil, err
	}

	output := &model.SyncCreatedTokensForUsernameAndExistingContractPayload{
		Message: "Successfully synced tokens",
	}

	return output, nil
}

// BanUserFromFeed is the resolver for the banUserFromFeed field.
func (r *mutationResolver) BanUserFromFeed(ctx context.Context, username string, reason persist.ReportReason) (model.BanUserFromFeedPayloadOrError, error) {
	user, err := publicapi.For(ctx).User.GetUserByUsername(ctx, username)
	if err != nil {
		return nil, err
	}

	err = publicapi.For(ctx).Feed.BanUser(ctx, user.ID, reason)
	if err != nil {
		return nil, err
	}

	return model.BanUserFromFeedPayload{User: userToModel(ctx, *user)}, nil
}

// UnbanUserFromFeed is the resolver for the unbanUserFromFeed field.
func (r *mutationResolver) UnbanUserFromFeed(ctx context.Context, username string) (model.UnbanUserFromFeedPayloadOrError, error) {
	user, err := publicapi.For(ctx).User.GetUserByUsername(ctx, username)
	if err != nil {
		return nil, err
	}

	err = publicapi.For(ctx).Feed.UnbanUser(ctx, user.ID)
	if err != nil {
		return nil, err
	}

	return model.UnbanUserFromFeedPayload{User: userToModel(ctx, *user)}, nil
}

// MintPremiumCardToWallet is the resolver for the mintPremiumCardToWallet field.
func (r *mutationResolver) MintPremiumCardToWallet(ctx context.Context, input model.MintPremiumCardToWalletInput) (model.MintPremiumCardToWalletPayloadOrError, error) {
	tx, err := publicapi.For(ctx).Card.MintPremiumCardToWallet(ctx, input)
	if err != nil {
		return nil, err
	}

	return model.MintPremiumCardToWalletPayload{Tx: tx}, nil
}

// SetCommunityOverrideCreator is the resolver for the setCommunityOverrideCreator field.
func (r *mutationResolver) SetCommunityOverrideCreator(ctx context.Context, communityID persist.DBID, creatorUserID *persist.DBID) (model.SetCommunityOverrideCreatorPayloadOrError, error) {
	if creatorUserID == nil {
		err := publicapi.For(ctx).Admin.RemoveContractOverrideCreator(ctx, communityID)
		if err != nil {
			return nil, err
		}
		return model.SetCommunityOverrideCreatorPayload{User: nil}, nil
	}

	user, err := publicapi.For(ctx).User.GetUserById(ctx, *creatorUserID)
	if err != nil {
		return nil, err
	}

	err = publicapi.For(ctx).Admin.SetContractOverrideCreator(ctx, communityID, *creatorUserID)
	if err != nil {
		return nil, err
	}

	return model.SetCommunityOverrideCreatorPayload{User: userToModel(ctx, *user)}, nil
}

// UploadPersistedQueries is the resolver for the uploadPersistedQueries field.
func (r *mutationResolver) UploadPersistedQueries(ctx context.Context, input *model.UploadPersistedQueriesInput) (model.UploadPersistedQueriesPayloadOrError, error) {
	err := publicapi.For(ctx).APQ.UploadPersistedQueries(ctx, *input.PersistedQueries)

	if err != nil {
		return nil, err
	}

	message := "Persisted queries uploaded successfully"

	return model.UploadPersistedQueriesPayload{Message: &message}, nil
}

// UpdatePrimaryWallet is the resolver for the updatePrimaryWallet field.
func (r *mutationResolver) UpdatePrimaryWallet(ctx context.Context, walletID persist.DBID) (model.UpdatePrimaryWalletPayloadOrError, error) {
	err := publicapi.For(ctx).User.UpdateUserPrimaryWallet(ctx, walletID)
	if err != nil {
		return nil, err
	}
	return model.UpdatePrimaryWalletPayload{
		Viewer: resolveViewer(ctx),
	}, nil
}

// UpdateUserExperience is the resolver for the updateUserExperience field.
func (r *mutationResolver) UpdateUserExperience(ctx context.Context, input model.UpdateUserExperienceInput) (model.UpdateUserExperiencePayloadOrError, error) {
	err := publicapi.For(ctx).User.UpdateUserExperience(ctx, input.ExperienceType, input.Experienced)
	if err != nil {
		return nil, err
	}
	return model.UpdateUserExperiencePayload{
		Viewer: resolveViewer(ctx),
	}, nil
}

// MoveCollectionToGallery is the resolver for the moveCollectionToGallery field.
func (r *mutationResolver) MoveCollectionToGallery(ctx context.Context, input *model.MoveCollectionToGalleryInput) (model.MoveCollectionToGalleryPayloadOrError, error) {
	oldGalID, err := publicapi.For(ctx).Collection.UpdateCollectionGallery(ctx, input.SourceCollectionID, input.TargetGalleryID)
	if err != nil {
		return nil, err
	}
	old, err := resolveGalleryByGalleryID(ctx, oldGalID)
	if err != nil {
		return nil, err
	}
	new, err := resolveGalleryByGalleryID(ctx, input.TargetGalleryID)
	if err != nil {
		return nil, err
	}
	return model.MoveCollectionToGalleryPayload{
		OldGallery: old,
		NewGallery: new,
	}, nil
}

// GenerateQRCodeLoginToken is the resolver for the generateQRCodeLoginToken field.
func (r *mutationResolver) GenerateQRCodeLoginToken(ctx context.Context) (model.GenerateQRCodeLoginTokenPayloadOrError, error) {
	token, err := publicapi.For(ctx).Auth.GenerateQRCodeLoginToken(ctx)
	if err != nil {
		return nil, err
	}
	return model.GenerateQRCodeLoginTokenPayload{
		Token: token,
	}, nil
}

// Token is the resolver for the token field.
func (r *newTokensNotificationResolver) Token(ctx context.Context, obj *model.NewTokensNotification) (*model.Token, error) {
	return resolveTokenByTokenID(ctx, obj.NotificationData.NewTokenID)
}

// Owner is the resolver for the owner field.
func (r *ownerAtBlockResolver) Owner(ctx context.Context, obj *model.OwnerAtBlock) (model.GalleryUserOrAddress, error) {
	panic(fmt.Errorf("not implemented"))
}

// Author is the resolver for the author field.
func (r *postResolver) Author(ctx context.Context, obj *model.Post) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.AuthorID)
}

// Tokens is the resolver for the tokens field.
func (r *postResolver) Tokens(ctx context.Context, obj *model.Post) ([]*model.Token, error) {
	result := make([]*model.Token, len(obj.TokenIDs))
	for i, token := range obj.TokenIDs {
		t, err := publicapi.For(ctx).Token.GetTokenByIdIgnoreDisplayable(ctx, token)
		if err != nil {
			return nil, err
		}
		result[i] = tokenToModel(ctx, *t, nil)
	}

	return result, nil
}

// Mentions is the resolver for the mentions field.
func (r *postResolver) Mentions(ctx context.Context, obj *model.Post) ([]*model.Mention, error) {
	return resolveMentionsByPostID(ctx, obj.Dbid)
}

// Admires is the resolver for the admires field.
func (r *postResolver) Admires(ctx context.Context, obj *model.Post, before *string, after *string, first *int, last *int) (*model.PostAdmiresConnection, error) {
	admires, pageInfo, err := publicapi.For(ctx).Interaction.PaginateAdmiresByPostID(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	var edges []*model.PostAdmireEdge
	for _, admire := range admires {
		edges = append(edges, &model.PostAdmireEdge{
			Node: admireToModel(ctx, admire),
		})
	}

	return &model.PostAdmiresConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *model.Post, before *string, after *string, first *int, last *int) (*model.PostCommentsConnection, error) {
	comments, pageInfo, err := publicapi.For(ctx).Interaction.PaginateCommentsByPostID(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	var edges []*model.PostCommentEdge
	for _, comment := range comments {
		edges = append(edges, &model.PostCommentEdge{
			Node: commentToModel(ctx, comment),
		})
	}

	return &model.PostCommentsConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// Interactions is the resolver for the interactions field.
func (r *postResolver) Interactions(ctx context.Context, obj *model.Post, before *string, after *string, first *int, last *int) (*model.InteractionsConnection, error) {
	interactions, pageInfo, err := publicapi.For(ctx).Interaction.PaginateInteractionsByPostID(ctx, obj.Dbid, before, after, first, last)
	if err != nil {
		return nil, err
	}

	var edges []*model.InteractionsEdge
	for _, interaction := range interactions {
		edge := &model.InteractionsEdge{}
		if admire, ok := interaction.(coredb.Admire); ok {
			edge.Node = admireToModel(ctx, admire)
		} else if comment, ok := interaction.(coredb.Comment); ok {
			edge.Node = commentToModel(ctx, comment)
		}
		edges = append(edges, edge)
	}

	return &model.InteractionsConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// ViewerAdmire is the resolver for the viewerAdmire field.
func (r *postResolver) ViewerAdmire(ctx context.Context, obj *model.Post) (*model.Admire, error) {
	api := publicapi.For(ctx)

	// If the user isn't logged in, there is no viewer
	if !api.User.IsUserLoggedIn(ctx) {
		return nil, nil
	}

	userID := api.User.GetLoggedInUserId(ctx)

	admire, err := api.Interaction.GetAdmireByActorIDAndPostID(ctx, userID, obj.Dbid)
	if err != nil {
		// If getting the admire fails for any reason, just return nil. This resolver doesn't
		// return error types -- it just returns an admire (if it can find one) or nil.
		return nil, nil
	}

	return admireToModel(ctx, *admire), nil
}

// Community is the resolver for the community field.
func (r *postComposerDraftDetailsPayloadResolver) Community(ctx context.Context, obj *model.PostComposerDraftDetailsPayload) (*model.Community, error) {
	if obj.HelperPostComposerDraftDetailsPayloadData.ContractID != "" {
		return resolveCommunityByID(ctx, obj.HelperPostComposerDraftDetailsPayloadData.ContractID)
	}

	if obj.HelperPostComposerDraftDetailsPayloadData.Token.ContractAddress != "" {
		chainAddress := persist.NewChainAddress(obj.HelperPostComposerDraftDetailsPayloadData.Token.ContractAddress, obj.HelperPostComposerDraftDetailsPayloadData.Token.Chain)
		return resolveCommunityByContractAddress(ctx, chainAddress, util.ToPointer(false))
	}

	return nil, nil
}

// Blurhash is the resolver for the blurhash field.
func (r *previewURLSetResolver) Blurhash(ctx context.Context, obj *model.PreviewURLSet) (*string, error) {
	mm := mediamapper.For(ctx)

	return mm.GetBlurhash(*obj.Raw), nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id model.GqlID) (model.Node, error) {
	return nodeFetcher.GetNodeByGqlID(ctx, id)
}

// Viewer is the resolver for the viewer field.
func (r *queryResolver) Viewer(ctx context.Context) (model.ViewerOrError, error) {
	return resolveViewer(ctx), nil
}

// UserByUsername is the resolver for the userByUsername field.
func (r *queryResolver) UserByUsername(ctx context.Context, username string) (model.UserByUsernameOrError, error) {
	return resolveGalleryUserByUsername(ctx, username)
}

// UserByID is the resolver for the userById field.
func (r *queryResolver) UserByID(ctx context.Context, id persist.DBID) (model.UserByIDOrError, error) {
	return resolveGalleryUserByUserID(ctx, id)
}

// UserByAddress is the resolver for the userByAddress field.
func (r *queryResolver) UserByAddress(ctx context.Context, chainAddress persist.ChainAddress) (model.UserByAddressOrError, error) {
	return resolveGalleryUserByAddress(ctx, chainAddress)
}

// UsersWithTrait is the resolver for the usersWithTrait field.
func (r *queryResolver) UsersWithTrait(ctx context.Context, trait string) ([]*model.GalleryUser, error) {
	return resolveGalleryUsersWithTrait(ctx, trait)
}

// MembershipTiers is the resolver for the membershipTiers field.
func (r *queryResolver) MembershipTiers(ctx context.Context, forceRefresh *bool) ([]*model.MembershipTier, error) {
	api := publicapi.For(ctx)

	refresh := false
	if forceRefresh != nil {
		refresh = *forceRefresh
	}

	tiers, err := api.User.GetMembershipTiers(ctx, refresh)
	if err != nil {
		return nil, err
	}

	output := make([]*model.MembershipTier, len(tiers))
	for i, tier := range tiers {
		output[i] = persistMembershipTierToModel(ctx, tier)
	}

	return output, nil
}

// CollectionByID is the resolver for the collectionById field.
func (r *queryResolver) CollectionByID(ctx context.Context, id persist.DBID) (model.CollectionByIDOrError, error) {
	return resolveCollectionByCollectionID(ctx, id)
}

// CollectionsByIds is the resolver for the collectionsByIds field.
func (r *queryResolver) CollectionsByIds(ctx context.Context, ids []persist.DBID) ([]model.CollectionByIDOrError, error) {
	collections, errs := resolveCollectionsByCollectionIDs(ctx, ids)

	models := make([]model.CollectionByIDOrError, len(ids))

	// TODO: Figure out how to handle errors for slice returns automatically, the same way we handle typical resolvers.
	//       Without that kind of handling, errors must be checked manually (as is happening below).
	for i, err := range errs {
		if err == nil {
			models[i] = collections[i]
		} else if notFoundErr, ok := err.(persist.ErrCollectionNotFoundByID); ok {
			models[i] = model.ErrCollectionNotFound{Message: notFoundErr.Error()}
		} else if validationErr, ok := err.(validate.ErrInvalidInput); ok {
			models[i] = model.ErrInvalidInput{Message: validationErr.Error(), Parameters: validationErr.Parameters, Reasons: validationErr.Reasons}
		} else {
			// Unhandled error -- add it to the unhandled error stack, but don't fail the whole operation
			// because one collection hit an unexpected error. Consider making "unhandled error" an expected type,
			// such that it can be returned as part of a model "OrError" union instead of returning null.
			graphql.AddError(ctx, err)
		}
	}

	return models, nil
}

// TokenByID is the resolver for the tokenById field.
func (r *queryResolver) TokenByID(ctx context.Context, id persist.DBID) (model.TokenByIDOrError, error) {
	return resolveTokenByTokenID(ctx, id)
}

// CollectionTokenByID is the resolver for the collectionTokenById field.
func (r *queryResolver) CollectionTokenByID(ctx context.Context, tokenID persist.DBID, collectionID persist.DBID) (model.CollectionTokenByIDOrError, error) {
	return resolveCollectionTokenByID(ctx, tokenID, collectionID)
}

// CommunityByAddress is the resolver for the communityByAddress field.
func (r *queryResolver) CommunityByAddress(ctx context.Context, communityAddress persist.ChainAddress, forceRefresh *bool) (model.CommunityByAddressOrError, error) {
	return resolveCommunityByContractAddress(ctx, communityAddress, forceRefresh)
}

// GeneralAllowlist is the resolver for the generalAllowlist field.
func (r *queryResolver) GeneralAllowlist(ctx context.Context) ([]*persist.ChainAddress, error) {
	return resolveGeneralAllowlist(ctx)
}

// GalleryOfTheWeekWinners is the resolver for the galleryOfTheWeekWinners field.
func (r *queryResolver) GalleryOfTheWeekWinners(ctx context.Context) ([]*model.GalleryUser, error) {
	winners, err := publicapi.For(ctx).Misc.GetGalleryOfTheWeekWinners(ctx)

	var output = make([]*model.GalleryUser, len(winners))
	for i, user := range winners {
		output[i] = userToModel(ctx, user)
	}

	return output, err
}

// GlobalFeed is the resolver for the globalFeed field.
func (r *queryResolver) GlobalFeed(ctx context.Context, before *string, after *string, first *int, last *int, includePosts bool) (*model.FeedConnection, error) {
	events, pageInfo, err := publicapi.For(ctx).Feed.GlobalFeed(ctx, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges, err := entitiesToFeedEdges(events)
	if err != nil {
		return nil, err
	}

	return &model.FeedConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// TrendingFeed is the resolver for the trendingFeed field.
func (r *queryResolver) TrendingFeed(ctx context.Context, before *string, after *string, first *int, last *int, includePosts bool) (*model.FeedConnection, error) {
	events, pageInfo, err := publicapi.For(ctx).Feed.TrendingFeed(ctx, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges, err := entitiesToFeedEdges(events)
	if err != nil {
		return nil, err
	}

	return &model.FeedConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// CuratedFeed is the resolver for the curatedFeed field.
func (r *queryResolver) CuratedFeed(ctx context.Context, before *string, after *string, first *int, last *int, includePosts bool) (*model.FeedConnection, error) {
	events, pageInfo, err := publicapi.For(ctx).Feed.ForYouFeed(ctx, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges, err := entitiesToFeedEdges(events)
	if err != nil {
		return nil, err
	}

	return &model.FeedConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// FeedEventByID is the resolver for the feedEventById field.
func (r *queryResolver) FeedEventByID(ctx context.Context, id persist.DBID) (model.FeedEventByIDOrError, error) {
	return resolveFeedEventByEventID(ctx, id)
}

// PostByID is the resolver for the postById field.
func (r *queryResolver) PostByID(ctx context.Context, id persist.DBID) (model.PostOrError, error) {
	return resolvePostByPostID(ctx, id)
}

// GetMerchTokens is the resolver for the getMerchTokens field.
func (r *queryResolver) GetMerchTokens(ctx context.Context, wallet persist.Address) (model.MerchTokensPayloadOrError, error) {
	tokens, err := publicapi.For(ctx).Merch.GetMerchTokens(ctx, wallet)
	if err != nil {
		return nil, err
	}

	output := &model.MerchTokensPayload{
		Tokens: tokens,
	}
	return output, nil
}

// GalleryByID is the resolver for the galleryById field.
func (r *queryResolver) GalleryByID(ctx context.Context, id persist.DBID) (model.GalleryByIDPayloadOrError, error) {
	gallery, err := resolveGalleryByGalleryID(ctx, id)

	if err != nil {
		return nil, err
	}

	return gallery, nil
}

// ViewerGalleryByID is the resolver for the viewerGalleryById field.
func (r *queryResolver) ViewerGalleryByID(ctx context.Context, id persist.DBID) (model.ViewerGalleryByIDPayloadOrError, error) {
	gallery, err := resolveViewerGalleryByGalleryID(ctx, id)

	if err != nil {
		return nil, err
	}

	return gallery, nil
}

// TrendingUsers is the resolver for the trendingUsers field.
func (r *queryResolver) TrendingUsers(ctx context.Context, input model.TrendingUsersInput) (model.TrendingUsersPayloadOrError, error) {
	users, err := publicapi.For(ctx).Feed.TrendingUsers(ctx, input.Report)
	if err != nil {
		return nil, err
	}

	result := make([]*model.GalleryUser, len(users))
	for i, u := range users {
		result[i] = userToModel(ctx, u)
	}

	return model.TrendingUsersPayload{Users: result}, nil
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, query string, limit *int, usernameWeight *float64, bioWeight *float64) (model.SearchUsersPayloadOrError, error) {
	limitParam := util.GetOptionalValue(limit, 100)
	usernameWeightParam := util.GetOptionalValue(usernameWeight, 0.4)
	bioWeightParam := util.GetOptionalValue(bioWeight, 0.2)

	users, err := publicapi.For(ctx).Search.SearchUsers(ctx, query, limitParam, float32(usernameWeightParam), float32(bioWeightParam))
	if err != nil {
		return nil, err
	}

	results := make([]*model.UserSearchResult, len(users))
	for i, user := range users {
		results[i] = &model.UserSearchResult{
			User: userToModel(ctx, user),
		}
	}

	return model.SearchUsersPayload{Results: results}, nil
}

// SearchGalleries is the resolver for the searchGalleries field.
func (r *queryResolver) SearchGalleries(ctx context.Context, query string, limit *int, nameWeight *float64, descriptionWeight *float64) (model.SearchGalleriesPayloadOrError, error) {
	limitParam := util.GetOptionalValue(limit, 100)
	nameWeightParam := util.GetOptionalValue(nameWeight, 0.4)
	descriptionWeightParam := util.GetOptionalValue(descriptionWeight, 0.2)

	galleries, err := publicapi.For(ctx).Search.SearchGalleries(ctx, query, limitParam, float32(nameWeightParam), float32(descriptionWeightParam))
	if err != nil {
		return nil, err
	}

	results := make([]*model.GallerySearchResult, len(galleries))
	for i, gallery := range galleries {
		results[i] = &model.GallerySearchResult{
			Gallery: galleryToModel(ctx, gallery),
		}
	}

	return model.SearchGalleriesPayload{Results: results}, nil
}

// SearchCommunities is the resolver for the searchCommunities field.
func (r *queryResolver) SearchCommunities(ctx context.Context, query string, limit *int, nameWeight *float64, descriptionWeight *float64, poapAddressWeight *float64) (model.SearchCommunitiesPayloadOrError, error) {
	limitParam := util.GetOptionalValue(limit, 100)
	nameWeightParam := util.GetOptionalValue(nameWeight, 0.4)
	descriptionWeightParam := util.GetOptionalValue(descriptionWeight, 0.2)
	poapAddressWeightParam := util.GetOptionalValue(poapAddressWeight, 0.1)

	contracts, err := publicapi.For(ctx).Search.SearchContracts(ctx, query, limitParam, float32(nameWeightParam), float32(descriptionWeightParam), float32(poapAddressWeightParam))
	if err != nil {
		return nil, err
	}

	forceRefresh := false

	results := make([]*model.CommunitySearchResult, len(contracts))
	for i, contract := range contracts {
		results[i] = &model.CommunitySearchResult{
			Community: communityToModel(ctx, contract, &forceRefresh),
		}
	}

	return model.SearchCommunitiesPayload{Results: results}, nil
}

// UsersByRole is the resolver for the usersByRole field.
func (r *queryResolver) UsersByRole(ctx context.Context, role persist.Role, before *string, after *string, first *int, last *int) (*model.UsersConnection, error) {
	users, pageInfo, err := publicapi.For(ctx).User.PaginateUsersWithRole(ctx, role, before, after, first, last)
	if err != nil {
		return nil, err
	}

	return &model.UsersConnection{
		Edges:    usersToEdges(ctx, users),
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// SocialConnections is the resolver for the socialConnections field.
func (r *queryResolver) SocialConnections(ctx context.Context, socialAccountType persist.SocialProvider, excludeAlreadyFollowing *bool, before *string, after *string, first *int, last *int) (*model.SocialConnectionsConnection, error) {
	connections, pageInfo, err := publicapi.For(ctx).Social.GetConnectionsPaginate(ctx, socialAccountType, before, after, first, last, excludeAlreadyFollowing)
	if err != nil {
		return nil, err
	}
	edges, _ := util.Map(connections, func(c model.SocialConnection) (*model.SocialConnectionsEdge, error) {
		return &model.SocialConnectionsEdge{
			Node:   c,
			Cursor: nil, // not used by relay, but relay will complain without this field existing
		}, nil
	})
	return &model.SocialConnectionsConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// SocialQueries is the resolver for the socialQueries field.
func (r *queryResolver) SocialQueries(ctx context.Context) (model.SocialQueriesOrError, error) {
	return &model.SocialQueries{}, nil
}

// TopCollectionsForCommunity is the resolver for the topCollectionsForCommunity field.
func (r *queryResolver) TopCollectionsForCommunity(ctx context.Context, input model.TopCollectionsForCommunityInput, before *string, after *string, first *int, last *int) (*model.CollectionsConnection, error) {
	collections, pageInfo, err := publicapi.For(ctx).Collection.GetTopCollectionsForCommunity(ctx, *input.ChainAddress, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges, _ := util.Map(collections, func(c coredb.Collection) (*model.CollectionEdge, error) {
		return &model.CollectionEdge{
			Node:   collectionToModel(ctx, c),
			Cursor: nil,
		}, nil
	})

	return &model.CollectionsConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// PostComposerDraftDetails is the resolver for the postComposerDraftDetails field.
func (r *queryResolver) PostComposerDraftDetails(ctx context.Context, input model.PostComposerDraftDetailsInput) (model.PostComposerDraftDetailsPayloadOrError, error) {
	tID := persist.TokenIdentifiers{
		Chain:           input.Token.ChainAddress.Chain(),
		ContractAddress: input.Token.ChainAddress.Address(),
		TokenID:         input.Token.TokenID,
	}

	td, media, err := publicapi.For(ctx).Token.GetMediaByTokenIdentifiers(ctx, tID)
	if err != nil {
		return nil, err
	}

	highDef := false

	return model.PostComposerDraftDetailsPayload{
		Media:            resolveTokenMedia(ctx, td, media, highDef),
		TokenName:        util.ToPointer(td.Name.String),
		TokenDescription: util.ToPointer(td.Description.String),
		Community:        nil, // handled by dedicated resolver
		HelperPostComposerDraftDetailsPayloadData: model.HelperPostComposerDraftDetailsPayloadData{
			Token:      tID,
			ContractID: td.ContractID,
		},
	}, err
}

// FeedEvent is the resolver for the feedEvent field.
func (r *removeAdmirePayloadResolver) FeedEvent(ctx context.Context, obj *model.RemoveAdmirePayload) (*model.FeedEvent, error) {
	if obj.FeedEvent == nil || obj.FeedEvent.Dbid == "" {
		return nil, nil
	}
	return resolveFeedEventByEventID(ctx, obj.FeedEvent.Dbid)
}

// Post is the resolver for the post field.
func (r *removeAdmirePayloadResolver) Post(ctx context.Context, obj *model.RemoveAdmirePayload) (*model.Post, error) {
	if obj.Post == nil || obj.Post.Dbid == "" {
		return nil, nil
	}
	return resolvePostByPostID(ctx, obj.Post.Dbid)
}

// FeedEvent is the resolver for the feedEvent field.
func (r *removeCommentPayloadResolver) FeedEvent(ctx context.Context, obj *model.RemoveCommentPayload) (*model.FeedEvent, error) {
	if obj.FeedEvent == nil || obj.FeedEvent.Dbid == "" {
		return nil, nil
	}
	return resolveFeedEventByEventID(ctx, obj.FeedEvent.Dbid)
}

// Post is the resolver for the post field.
func (r *removeCommentPayloadResolver) Post(ctx context.Context, obj *model.RemoveCommentPayload) (*model.Post, error) {
	if obj.Post == nil || obj.Post.Dbid == "" {
		return nil, nil
	}
	return resolvePostByPostID(ctx, obj.Post.Dbid)
}

// Tokens is the resolver for the tokens field.
func (r *setSpamPreferencePayloadResolver) Tokens(ctx context.Context, obj *model.SetSpamPreferencePayload) ([]*model.Token, error) {
	tokenIDs := make([]persist.DBID, len(obj.Tokens))
	for i, token := range obj.Tokens {
		tokenIDs[i] = token.Dbid
	}

	tokens, err := publicapi.For(ctx).Token.GetTokensByIDs(ctx, tokenIDs)
	if err != nil {
		return nil, err
	}

	return tokensToModel(ctx, tokens), nil
}

// GalleryUser is the resolver for the galleryUser field.
func (r *socialConnectionResolver) GalleryUser(ctx context.Context, obj *model.SocialConnection) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.UserID)
}

// SocialConnections is the resolver for the socialConnections field.
func (r *socialQueriesResolver) SocialConnections(ctx context.Context, obj *model.SocialQueries, socialAccountType persist.SocialProvider, excludeAlreadyFollowing *bool, before *string, after *string, first *int, last *int) (*model.SocialConnectionsConnection, error) {
	connections, pageInfo, err := publicapi.For(ctx).Social.GetConnectionsPaginate(ctx, socialAccountType, before, after, first, last, excludeAlreadyFollowing)
	if err != nil {
		return nil, err
	}
	edges, _ := util.Map(connections, func(c model.SocialConnection) (*model.SocialConnectionsEdge, error) {
		return &model.SocialConnectionsEdge{
			Node:   c,
			Cursor: nil, // not used by relay, but relay will complain without this field existing
		}, nil
	})
	return &model.SocialConnectionsConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// FeedEvent is the resolver for the feedEvent field.
func (r *someoneAdmiredYourFeedEventNotificationResolver) FeedEvent(ctx context.Context, obj *model.SomeoneAdmiredYourFeedEventNotification) (*model.FeedEvent, error) {
	return resolveFeedEventByEventID(ctx, obj.FeedEventID)
}

// Admirers is the resolver for the admirers field.
func (r *someoneAdmiredYourFeedEventNotificationResolver) Admirers(ctx context.Context, obj *model.SomeoneAdmiredYourFeedEventNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error) {
	return resolveGroupNotificationUsersConnectionByUserIDs(ctx, obj.NotificationData.AdmirerIDs, before, after, first, last)
}

// Post is the resolver for the post field.
func (r *someoneAdmiredYourPostNotificationResolver) Post(ctx context.Context, obj *model.SomeoneAdmiredYourPostNotification) (*model.Post, error) {
	return resolvePostByPostID(ctx, obj.PostID)
}

// Admirers is the resolver for the admirers field.
func (r *someoneAdmiredYourPostNotificationResolver) Admirers(ctx context.Context, obj *model.SomeoneAdmiredYourPostNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error) {
	return resolveGroupNotificationUsersConnectionByUserIDs(ctx, obj.NotificationData.AdmirerIDs, before, after, first, last)
}

// Token is the resolver for the token field.
func (r *someoneAdmiredYourTokenNotificationResolver) Token(ctx context.Context, obj *model.SomeoneAdmiredYourTokenNotification) (*model.Token, error) {
	return resolveTokenByTokenID(ctx, obj.TokenID)
}

// Admirers is the resolver for the admirers field.
func (r *someoneAdmiredYourTokenNotificationResolver) Admirers(ctx context.Context, obj *model.SomeoneAdmiredYourTokenNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error) {
	return resolveGroupNotificationUsersConnectionByUserIDs(ctx, obj.NotificationData.AdmirerIDs, before, after, first, last)
}

// Comment is the resolver for the comment field.
func (r *someoneCommentedOnYourFeedEventNotificationResolver) Comment(ctx context.Context, obj *model.SomeoneCommentedOnYourFeedEventNotification) (*model.Comment, error) {
	return resolveCommentByCommentID(ctx, obj.CommentID)
}

// FeedEvent is the resolver for the feedEvent field.
func (r *someoneCommentedOnYourFeedEventNotificationResolver) FeedEvent(ctx context.Context, obj *model.SomeoneCommentedOnYourFeedEventNotification) (*model.FeedEvent, error) {
	return resolveFeedEventByEventID(ctx, obj.HelperSomeoneCommentedOnYourFeedEventNotificationData.FeedEventID)
}

// Comment is the resolver for the comment field.
func (r *someoneCommentedOnYourPostNotificationResolver) Comment(ctx context.Context, obj *model.SomeoneCommentedOnYourPostNotification) (*model.Comment, error) {
	return resolveCommentByCommentID(ctx, obj.CommentID)
}

// Post is the resolver for the post field.
func (r *someoneCommentedOnYourPostNotificationResolver) Post(ctx context.Context, obj *model.SomeoneCommentedOnYourPostNotification) (*model.Post, error) {
	return resolvePostByPostID(ctx, obj.PostID)
}

// Followers is the resolver for the followers field.
func (r *someoneFollowedYouBackNotificationResolver) Followers(ctx context.Context, obj *model.SomeoneFollowedYouBackNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error) {
	return resolveGroupNotificationUsersConnectionByUserIDs(ctx, obj.NotificationData.FollowerIDs, before, after, first, last)
}

// Followers is the resolver for the followers field.
func (r *someoneFollowedYouNotificationResolver) Followers(ctx context.Context, obj *model.SomeoneFollowedYouNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error) {
	return resolveGroupNotificationUsersConnectionByUserIDs(ctx, obj.NotificationData.FollowerIDs, before, after, first, last)
}

// MentionSource is the resolver for the mentionSource field.
func (r *someoneMentionedYouNotificationResolver) MentionSource(ctx context.Context, obj *model.SomeoneMentionedYouNotification) (model.MentionSource, error) {
	if obj.CommentID != nil {
		return resolveCommentByCommentID(ctx, *obj.CommentID)
	}
	if obj.PostID != nil {
		return resolvePostByPostID(ctx, *obj.PostID)
	}
	return nil, fmt.Errorf("invalid mention source")
}

// MentionSource is the resolver for the mentionSource field.
func (r *someoneMentionedYourCommunityNotificationResolver) MentionSource(ctx context.Context, obj *model.SomeoneMentionedYourCommunityNotification) (model.MentionSource, error) {
	if obj.PostID != nil {
		return resolvePostByPostID(ctx, *obj.PostID)
	}
	if obj.CommentID != nil {
		return resolveCommentByCommentID(ctx, *obj.CommentID)
	}
	return nil, fmt.Errorf("invalid mention source")
}

// Community is the resolver for the community field.
func (r *someoneMentionedYourCommunityNotificationResolver) Community(ctx context.Context, obj *model.SomeoneMentionedYourCommunityNotification) (*model.Community, error) {
	return resolveCommunityByID(ctx, obj.ContractID)
}

// Post is the resolver for the post field.
func (r *someonePostedYourWorkNotificationResolver) Post(ctx context.Context, obj *model.SomeonePostedYourWorkNotification) (*model.Post, error) {
	return resolvePostByPostID(ctx, obj.PostID)
}

// Community is the resolver for the community field.
func (r *someonePostedYourWorkNotificationResolver) Community(ctx context.Context, obj *model.SomeonePostedYourWorkNotification) (*model.Community, error) {
	return resolveCommunityByID(ctx, obj.ContractID)
}

// Comment is the resolver for the comment field.
func (r *someoneRepliedToYourCommentNotificationResolver) Comment(ctx context.Context, obj *model.SomeoneRepliedToYourCommentNotification) (*model.Comment, error) {
	return resolveCommentByCommentID(ctx, obj.CommentID)
}

// OriginalComment is the resolver for the originalComment field.
func (r *someoneRepliedToYourCommentNotificationResolver) OriginalComment(ctx context.Context, obj *model.SomeoneRepliedToYourCommentNotification) (*model.Comment, error) {
	return resolveCommentByCommentID(ctx, obj.NotificationData.OriginalCommentID)
}

// UserViewers is the resolver for the userViewers field.
func (r *someoneViewedYourGalleryNotificationResolver) UserViewers(ctx context.Context, obj *model.SomeoneViewedYourGalleryNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error) {
	return resolveGroupNotificationUsersConnectionByUserIDs(ctx, obj.NotificationData.AuthedViewerIDs, before, after, first, last)
}

// Gallery is the resolver for the gallery field.
func (r *someoneViewedYourGalleryNotificationResolver) Gallery(ctx context.Context, obj *model.SomeoneViewedYourGalleryNotification) (*model.Gallery, error) {
	return resolveGalleryByGalleryID(ctx, obj.GalleryID)
}

// Post is the resolver for the post field.
func (r *someoneYouFollowPostedTheirFirstPostNotificationResolver) Post(ctx context.Context, obj *model.SomeoneYouFollowPostedTheirFirstPostNotification) (*model.Post, error) {
	return resolvePostByPostID(ctx, obj.PostID)
}

// NewNotification is the resolver for the newNotification field.
func (r *subscriptionResolver) NewNotification(ctx context.Context) (<-chan model.Notification, error) {
	return resolveNewNotificationSubscription(ctx), nil
}

// NotificationUpdated is the resolver for the notificationUpdated field.
func (r *subscriptionResolver) NotificationUpdated(ctx context.Context) (<-chan model.Notification, error) {
	return resolveUpdatedNotificationSubscription(ctx), nil
}

// Owner is the resolver for the owner field.
func (r *tokenResolver) Owner(ctx context.Context, obj *model.Token) (*model.GalleryUser, error) {
	return resolveTokenOwnerByTokenID(ctx, obj.Dbid)
}

// OwnedByWallets is the resolver for the ownedByWallets field.
func (r *tokenResolver) OwnedByWallets(ctx context.Context, obj *model.Token) ([]*model.Wallet, error) {
	wallets, err := publicapi.For(ctx).Wallet.GetWalletsByIDs(ctx, obj.HelperTokenData.Token.OwnedByWallets)
	if err != nil {
		return nil, err
	}

	ws := make([]*model.Wallet, len(wallets))
	for i, w := range wallets {
		ws[i] = walletToModelSqlc(ctx, w)
	}

	return ws, nil
}

// Definition is the resolver for the definition field.
func (r *tokenResolver) Definition(ctx context.Context, obj *model.Token) (*model.TokenDefinition, error) {
	return resolveTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
}

// Admires is the resolver for the admires field.
func (r *tokenResolver) Admires(ctx context.Context, obj *model.Token, before *string, after *string, first *int, last *int, userID *persist.DBID) (*model.TokenAdmiresConnection, error) {
	var edges []*model.TokenAdmireEdge
	admires, pageInfo, err := publicapi.For(ctx).Interaction.PaginateAdmiresByTokenID(ctx, obj.Dbid, before, after, first, last, userID)
	if err != nil {
		return nil, err
	}

	for _, admire := range admires {
		edges = append(edges, &model.TokenAdmireEdge{
			Node:  admireToModel(ctx, admire),
			Token: obj,
		})
	}

	return &model.TokenAdmiresConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// ViewerAdmire is the resolver for the viewerAdmire field.
func (r *tokenResolver) ViewerAdmire(ctx context.Context, obj *model.Token) (*model.Admire, error) {
	api := publicapi.For(ctx)

	// If the user isn't logged in, there is no viewer
	if !api.User.IsUserLoggedIn(ctx) {
		return nil, nil
	}

	userID := api.User.GetLoggedInUserId(ctx)

	admire, err := api.Interaction.GetAdmireByActorIDAndTokenID(ctx, userID, obj.Dbid)
	if err != nil {
		// If getting the admire fails for any reason, just return nil. This resolver doesn't
		// return error types -- it just returns an admire (if it can find one) or nil.
		return nil, nil
	}

	return admireToModel(ctx, *admire), nil
}

// Media is the resolver for the media field.
func (r *tokenResolver) Media(ctx context.Context, obj *model.Token) (model.MediaSubtype, error) {
	var highDef bool
	if obj.CollectionID != nil {
		settings, err := resolveTokenSettingsByIDs(ctx, obj.Dbid, *obj.CollectionID)
		if err != nil {
			return nil, err
		}
		highDef = *settings.HighDefinition
	}

	// The definition is likely already cached by the root dataloader that queries for the definition alongside the token instance
	td, err := publicapi.For(ctx).Token.GetTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
	if err != nil {
		return nil, err
	}

	var media coredb.TokenMedia

	if td.TokenMediaID != "" {
		media, err = publicapi.For(ctx).Token.GetMediaByMediaID(ctx, td.TokenMediaID)
		if util.ErrorAs[persist.ErrMediaNotFound](err) {
			err = nil
		}
	}

	return resolveTokenMedia(ctx, td, media, highDef), err
}

// TokenType is the resolver for the tokenType field.
func (r *tokenResolver) TokenType(ctx context.Context, obj *model.Token) (*model.TokenType, error) {
	td, err := resolveTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
	if err != nil {
		return nil, err
	}
	return td.TokenType, nil
}

// Chain is the resolver for the chain field.
func (r *tokenResolver) Chain(ctx context.Context, obj *model.Token) (*persist.Chain, error) {
	td, err := resolveTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
	if err != nil {
		return nil, err
	}
	return td.Chain, nil
}

// Name is the resolver for the name field.
func (r *tokenResolver) Name(ctx context.Context, obj *model.Token) (*string, error) {
	td, err := resolveTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
	if err != nil {
		return nil, err
	}
	return td.Name, nil
}

// Description is the resolver for the description field.
func (r *tokenResolver) Description(ctx context.Context, obj *model.Token) (*string, error) {
	td, err := resolveTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
	if err != nil {
		return nil, err
	}
	return td.Description, nil
}

// TokenID is the resolver for the tokenId field.
func (r *tokenResolver) TokenID(ctx context.Context, obj *model.Token) (*string, error) {
	td, err := resolveTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
	if err != nil {
		return nil, err
	}
	return td.TokenID, nil
}

// TokenMetadata is the resolver for the tokenMetadata field.
func (r *tokenResolver) TokenMetadata(ctx context.Context, obj *model.Token) (*string, error) {
	tokenMedia, err := publicapi.For(ctx).Token.GetTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
	if err != nil {
		return nil, err
	}
	mar, err := json.Marshal(tokenMedia.Metadata)
	if err != nil {
		return nil, err
	}

	return util.ToPointer(string(mar)), nil
}

// Contract is the resolver for the contract field.
func (r *tokenResolver) Contract(ctx context.Context, obj *model.Token) (*model.Contract, error) {
	return resolveContractByContractID(ctx, obj.HelperTokenData.Token.ContractID)
}

// Community is the resolver for the community field.
func (r *tokenResolver) Community(ctx context.Context, obj *model.Token) (*model.Community, error) {
	return resolveCommunityByID(ctx, obj.HelperTokenData.Token.ContractID)
}

// ExternalURL is the resolver for the externalUrl field.
func (r *tokenResolver) ExternalURL(ctx context.Context, obj *model.Token) (*string, error) {
	td, err := resolveTokenDefinitionByID(ctx, obj.HelperTokenData.Token.TokenDefinitionID)
	if err != nil {
		return nil, err
	}
	return td.ExternalURL, nil
}

// IsSpamByProvider is the resolver for the isSpamByProvider field.
func (r *tokenResolver) IsSpamByProvider(ctx context.Context, obj *model.Token) (*bool, error) {
	c, err := resolveContractByContractID(ctx, obj.HelperTokenData.Token.ContractID)
	if err != nil {
		return nil, err
	}
	isSpam := (c.IsSpam != nil && *c.IsSpam) || (obj.IsSpamByProvider != nil && *obj.IsSpamByProvider)
	return &isSpam, nil
}

// Media is the resolver for the media field.
func (r *tokenDefinitionResolver) Media(ctx context.Context, obj *model.TokenDefinition) (model.MediaSubtype, error) {
	media, err := publicapi.For(ctx).Token.GetMediaByMediaID(ctx, obj.HelperTokenDefinitionData.Definition.TokenMediaID)
	if err != nil {
		return nil, err
	}
	return resolveTokenMedia(ctx, obj.HelperTokenDefinitionData.Definition, media, false), nil
}

// TokenMetadata is the resolver for the tokenMetadata field.
func (r *tokenDefinitionResolver) TokenMetadata(ctx context.Context, obj *model.TokenDefinition) (*string, error) {
	b, err := obj.HelperTokenDefinitionData.Definition.Metadata.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return util.ToPointer(string(b)), nil
}

// Community is the resolver for the community field.
func (r *tokenDefinitionResolver) Community(ctx context.Context, obj *model.TokenDefinition) (*model.Community, error) {
	return resolveCommunityByID(ctx, obj.HelperTokenDefinitionData.Definition.ContractID)
}

// Wallets is the resolver for the wallets field.
func (r *tokenHolderResolver) Wallets(ctx context.Context, obj *model.TokenHolder) ([]*model.Wallet, error) {
	wallets := make([]*model.Wallet, 0, len(obj.WalletIds))
	for _, id := range obj.WalletIds {
		wallet, err := resolveWalletByWalletID(ctx, id)
		if err == nil {
			wallets = append(wallets, wallet)
		}
	}

	return wallets, nil
}

// User is the resolver for the user field.
func (r *tokenHolderResolver) User(ctx context.Context, obj *model.TokenHolder) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.UserId)
}

// PreviewTokens is the resolver for the previewTokens field.
func (r *tokenHolderResolver) PreviewTokens(ctx context.Context, obj *model.TokenHolder) ([]*string, error) {
	urls, err := publicapi.For(ctx).Contract.GetPreviewURLsByContractIDandUserID(ctx, obj.HelperTokenHolderData.UserId, obj.HelperTokenHolderData.ContractId)
	if err != nil {
		return nil, err
	}
	previewURLs := make([]*string, len(urls))
	for i, url := range urls {
		previewURLs[i] = &url
	}
	return previewURLs, nil
}

// Owner is the resolver for the owner field.
func (r *tokensAddedToCollectionFeedEventDataResolver) Owner(ctx context.Context, obj *model.TokensAddedToCollectionFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// Collection is the resolver for the collection field.
func (r *tokensAddedToCollectionFeedEventDataResolver) Collection(ctx context.Context, obj *model.TokensAddedToCollectionFeedEventData) (*model.Collection, error) {
	return resolveCollectionByCollectionID(ctx, obj.Collection.Dbid)
}

// NewTokens is the resolver for the newTokens field.
func (r *tokensAddedToCollectionFeedEventDataResolver) NewTokens(ctx context.Context, obj *model.TokensAddedToCollectionFeedEventData) ([]*model.CollectionToken, error) {
	return resolveCollectionTokensByTokenIDs(ctx, obj.CollectionID, obj.TokenIDs)
}

// User is the resolver for the user field.
func (r *unfollowUserPayloadResolver) User(ctx context.Context, obj *model.UnfollowUserPayload) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.User.Dbid)
}

// FeedEvent is the resolver for the feedEvent field.
func (r *updateCollectionTokensPayloadResolver) FeedEvent(ctx context.Context, obj *model.UpdateCollectionTokensPayload) (*model.FeedEvent, error) {
	if obj.FeedEvent.Dbid == "" {
		return nil, nil
	}
	return resolveFeedEventByEventID(ctx, obj.FeedEvent.Dbid)
}

// Owner is the resolver for the owner field.
func (r *userCreatedFeedEventDataResolver) Owner(ctx context.Context, obj *model.UserCreatedFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// Owner is the resolver for the owner field.
func (r *userFollowedUsersFeedEventDataResolver) Owner(ctx context.Context, obj *model.UserFollowedUsersFeedEventData) (*model.GalleryUser, error) {
	return resolveGalleryUserByUserID(ctx, obj.Owner.Dbid)
}

// User is the resolver for the user field.
func (r *viewerResolver) User(ctx context.Context, obj *model.Viewer) (*model.GalleryUser, error) {
	userID := publicapi.For(ctx).User.GetLoggedInUserId(ctx)
	return resolveGalleryUserByUserID(ctx, userID)
}

// SocialAccounts is the resolver for the socialAccounts field.
func (r *viewerResolver) SocialAccounts(ctx context.Context, obj *model.Viewer) (*model.SocialAccounts, error) {
	return resolveViewerSocialsByUserID(ctx, obj.UserId)
}

// ViewerGalleries is the resolver for the viewerGalleries field.
func (r *viewerResolver) ViewerGalleries(ctx context.Context, obj *model.Viewer) ([]*model.ViewerGallery, error) {
	userID := publicapi.For(ctx).User.GetLoggedInUserId(ctx)
	galleries, err := resolveGalleriesByUserID(ctx, userID)

	if err != nil {
		return nil, err
	}

	output := make([]*model.ViewerGallery, len(galleries))
	for i, gallery := range galleries {
		output[i] = &model.ViewerGallery{
			Gallery: gallery,
		}
	}

	return output, nil
}

// Feed is the resolver for the feed field.
func (r *viewerResolver) Feed(ctx context.Context, obj *model.Viewer, before *string, after *string, first *int, last *int, includePosts bool) (*model.FeedConnection, error) {
	events, pageInfo, err := publicapi.For(ctx).Feed.PersonalFeed(ctx, before, after, first, last)
	if err != nil {
		return nil, err
	}

	edges, err := entitiesToFeedEdges(events)
	if err != nil {
		return nil, err
	}

	return &model.FeedConnection{
		Edges:    edges,
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// Email is the resolver for the email field.
func (r *viewerResolver) Email(ctx context.Context, obj *model.Viewer) (*model.UserEmail, error) {
	return resolveViewerEmail(ctx), nil
}

// Notifications is the resolver for the notifications field.
func (r *viewerResolver) Notifications(ctx context.Context, obj *model.Viewer, before *string, after *string, first *int, last *int) (*model.NotificationsConnection, error) {
	return resolveViewerNotifications(ctx, before, after, first, last)
}

// NotificationSettings is the resolver for the notificationSettings field.
func (r *viewerResolver) NotificationSettings(ctx context.Context, obj *model.Viewer) (*model.NotificationSettings, error) {
	return resolveViewerNotificationSettings(ctx)
}

// UserExperiences is the resolver for the userExperiences field.
func (r *viewerResolver) UserExperiences(ctx context.Context, obj *model.Viewer) ([]*model.UserExperience, error) {
	return resolveViewerExperiencesByUserID(ctx, obj.UserId)
}

// SuggestedUsers is the resolver for the suggestedUsers field.
func (r *viewerResolver) SuggestedUsers(ctx context.Context, obj *model.Viewer, before *string, after *string, first *int, last *int) (*model.UsersConnection, error) {
	users, pageInfo, err := publicapi.For(ctx).User.RecommendUsers(ctx, before, after, first, last)
	if err != nil {
		return nil, err
	}

	return &model.UsersConnection{
		Edges:    usersToEdges(ctx, users),
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// Tokens is the resolver for the tokens field.
func (r *walletResolver) Tokens(ctx context.Context, obj *model.Wallet) ([]*model.Token, error) {
	return resolveTokensByWalletID(ctx, obj.Dbid)
}

// Address is the resolver for the address field.
func (r *chainAddressInputResolver) Address(ctx context.Context, obj *persist.ChainAddress, data persist.Address) error {
	return obj.GQLSetAddressFromResolver(data)
}

// Chain is the resolver for the chain field.
func (r *chainAddressInputResolver) Chain(ctx context.Context, obj *persist.ChainAddress, data persist.Chain) error {
	return obj.GQLSetChainFromResolver(data)
}

// PubKey is the resolver for the pubKey field.
func (r *chainPubKeyInputResolver) PubKey(ctx context.Context, obj *persist.ChainPubKey, data persist.PubKey) error {
	return obj.GQLSetPubKeyFromResolver(data)
}

// Chain is the resolver for the chain field.
func (r *chainPubKeyInputResolver) Chain(ctx context.Context, obj *persist.ChainPubKey, data persist.Chain) error {
	return obj.GQLSetChainFromResolver(data)
}

// Admire returns generated.AdmireResolver implementation.
func (r *Resolver) Admire() generated.AdmireResolver { return &admireResolver{r} }

// AdmireFeedEventPayload returns generated.AdmireFeedEventPayloadResolver implementation.
func (r *Resolver) AdmireFeedEventPayload() generated.AdmireFeedEventPayloadResolver {
	return &admireFeedEventPayloadResolver{r}
}

// AdmirePostPayload returns generated.AdmirePostPayloadResolver implementation.
func (r *Resolver) AdmirePostPayload() generated.AdmirePostPayloadResolver {
	return &admirePostPayloadResolver{r}
}

// AdmireTokenPayload returns generated.AdmireTokenPayloadResolver implementation.
func (r *Resolver) AdmireTokenPayload() generated.AdmireTokenPayloadResolver {
	return &admireTokenPayloadResolver{r}
}

// Collection returns generated.CollectionResolver implementation.
func (r *Resolver) Collection() generated.CollectionResolver { return &collectionResolver{r} }

// CollectionCreatedFeedEventData returns generated.CollectionCreatedFeedEventDataResolver implementation.
func (r *Resolver) CollectionCreatedFeedEventData() generated.CollectionCreatedFeedEventDataResolver {
	return &collectionCreatedFeedEventDataResolver{r}
}

// CollectionToken returns generated.CollectionTokenResolver implementation.
func (r *Resolver) CollectionToken() generated.CollectionTokenResolver {
	return &collectionTokenResolver{r}
}

// CollectionUpdatedFeedEventData returns generated.CollectionUpdatedFeedEventDataResolver implementation.
func (r *Resolver) CollectionUpdatedFeedEventData() generated.CollectionUpdatedFeedEventDataResolver {
	return &collectionUpdatedFeedEventDataResolver{r}
}

// CollectorsNoteAddedToCollectionFeedEventData returns generated.CollectorsNoteAddedToCollectionFeedEventDataResolver implementation.
func (r *Resolver) CollectorsNoteAddedToCollectionFeedEventData() generated.CollectorsNoteAddedToCollectionFeedEventDataResolver {
	return &collectorsNoteAddedToCollectionFeedEventDataResolver{r}
}

// CollectorsNoteAddedToTokenFeedEventData returns generated.CollectorsNoteAddedToTokenFeedEventDataResolver implementation.
func (r *Resolver) CollectorsNoteAddedToTokenFeedEventData() generated.CollectorsNoteAddedToTokenFeedEventDataResolver {
	return &collectorsNoteAddedToTokenFeedEventDataResolver{r}
}

// Comment returns generated.CommentResolver implementation.
func (r *Resolver) Comment() generated.CommentResolver { return &commentResolver{r} }

// CommentOnFeedEventPayload returns generated.CommentOnFeedEventPayloadResolver implementation.
func (r *Resolver) CommentOnFeedEventPayload() generated.CommentOnFeedEventPayloadResolver {
	return &commentOnFeedEventPayloadResolver{r}
}

// CommentOnPostPayload returns generated.CommentOnPostPayloadResolver implementation.
func (r *Resolver) CommentOnPostPayload() generated.CommentOnPostPayloadResolver {
	return &commentOnPostPayloadResolver{r}
}

// Community returns generated.CommunityResolver implementation.
func (r *Resolver) Community() generated.CommunityResolver { return &communityResolver{r} }

// Contract returns generated.ContractResolver implementation.
func (r *Resolver) Contract() generated.ContractResolver { return &contractResolver{r} }

// CreateCollectionPayload returns generated.CreateCollectionPayloadResolver implementation.
func (r *Resolver) CreateCollectionPayload() generated.CreateCollectionPayloadResolver {
	return &createCollectionPayloadResolver{r}
}

// EnsProfileImage returns generated.EnsProfileImageResolver implementation.
func (r *Resolver) EnsProfileImage() generated.EnsProfileImageResolver {
	return &ensProfileImageResolver{r}
}

// FeedEvent returns generated.FeedEventResolver implementation.
func (r *Resolver) FeedEvent() generated.FeedEventResolver { return &feedEventResolver{r} }

// FollowInfo returns generated.FollowInfoResolver implementation.
func (r *Resolver) FollowInfo() generated.FollowInfoResolver { return &followInfoResolver{r} }

// FollowUserPayload returns generated.FollowUserPayloadResolver implementation.
func (r *Resolver) FollowUserPayload() generated.FollowUserPayloadResolver {
	return &followUserPayloadResolver{r}
}

// Gallery returns generated.GalleryResolver implementation.
func (r *Resolver) Gallery() generated.GalleryResolver { return &galleryResolver{r} }

// GalleryInfoUpdatedFeedEventData returns generated.GalleryInfoUpdatedFeedEventDataResolver implementation.
func (r *Resolver) GalleryInfoUpdatedFeedEventData() generated.GalleryInfoUpdatedFeedEventDataResolver {
	return &galleryInfoUpdatedFeedEventDataResolver{r}
}

// GalleryUpdatedFeedEventData returns generated.GalleryUpdatedFeedEventDataResolver implementation.
func (r *Resolver) GalleryUpdatedFeedEventData() generated.GalleryUpdatedFeedEventDataResolver {
	return &galleryUpdatedFeedEventDataResolver{r}
}

// GalleryUser returns generated.GalleryUserResolver implementation.
func (r *Resolver) GalleryUser() generated.GalleryUserResolver { return &galleryUserResolver{r} }

// Mention returns generated.MentionResolver implementation.
func (r *Resolver) Mention() generated.MentionResolver { return &mentionResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// NewTokensNotification returns generated.NewTokensNotificationResolver implementation.
func (r *Resolver) NewTokensNotification() generated.NewTokensNotificationResolver {
	return &newTokensNotificationResolver{r}
}

// OwnerAtBlock returns generated.OwnerAtBlockResolver implementation.
func (r *Resolver) OwnerAtBlock() generated.OwnerAtBlockResolver { return &ownerAtBlockResolver{r} }

// Post returns generated.PostResolver implementation.
func (r *Resolver) Post() generated.PostResolver { return &postResolver{r} }

// PostComposerDraftDetailsPayload returns generated.PostComposerDraftDetailsPayloadResolver implementation.
func (r *Resolver) PostComposerDraftDetailsPayload() generated.PostComposerDraftDetailsPayloadResolver {
	return &postComposerDraftDetailsPayloadResolver{r}
}

// PreviewURLSet returns generated.PreviewURLSetResolver implementation.
func (r *Resolver) PreviewURLSet() generated.PreviewURLSetResolver { return &previewURLSetResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// RemoveAdmirePayload returns generated.RemoveAdmirePayloadResolver implementation.
func (r *Resolver) RemoveAdmirePayload() generated.RemoveAdmirePayloadResolver {
	return &removeAdmirePayloadResolver{r}
}

// RemoveCommentPayload returns generated.RemoveCommentPayloadResolver implementation.
func (r *Resolver) RemoveCommentPayload() generated.RemoveCommentPayloadResolver {
	return &removeCommentPayloadResolver{r}
}

// SetSpamPreferencePayload returns generated.SetSpamPreferencePayloadResolver implementation.
func (r *Resolver) SetSpamPreferencePayload() generated.SetSpamPreferencePayloadResolver {
	return &setSpamPreferencePayloadResolver{r}
}

// SocialConnection returns generated.SocialConnectionResolver implementation.
func (r *Resolver) SocialConnection() generated.SocialConnectionResolver {
	return &socialConnectionResolver{r}
}

// SocialQueries returns generated.SocialQueriesResolver implementation.
func (r *Resolver) SocialQueries() generated.SocialQueriesResolver { return &socialQueriesResolver{r} }

// SomeoneAdmiredYourFeedEventNotification returns generated.SomeoneAdmiredYourFeedEventNotificationResolver implementation.
func (r *Resolver) SomeoneAdmiredYourFeedEventNotification() generated.SomeoneAdmiredYourFeedEventNotificationResolver {
	return &someoneAdmiredYourFeedEventNotificationResolver{r}
}

// SomeoneAdmiredYourPostNotification returns generated.SomeoneAdmiredYourPostNotificationResolver implementation.
func (r *Resolver) SomeoneAdmiredYourPostNotification() generated.SomeoneAdmiredYourPostNotificationResolver {
	return &someoneAdmiredYourPostNotificationResolver{r}
}

// SomeoneAdmiredYourTokenNotification returns generated.SomeoneAdmiredYourTokenNotificationResolver implementation.
func (r *Resolver) SomeoneAdmiredYourTokenNotification() generated.SomeoneAdmiredYourTokenNotificationResolver {
	return &someoneAdmiredYourTokenNotificationResolver{r}
}

// SomeoneCommentedOnYourFeedEventNotification returns generated.SomeoneCommentedOnYourFeedEventNotificationResolver implementation.
func (r *Resolver) SomeoneCommentedOnYourFeedEventNotification() generated.SomeoneCommentedOnYourFeedEventNotificationResolver {
	return &someoneCommentedOnYourFeedEventNotificationResolver{r}
}

// SomeoneCommentedOnYourPostNotification returns generated.SomeoneCommentedOnYourPostNotificationResolver implementation.
func (r *Resolver) SomeoneCommentedOnYourPostNotification() generated.SomeoneCommentedOnYourPostNotificationResolver {
	return &someoneCommentedOnYourPostNotificationResolver{r}
}

// SomeoneFollowedYouBackNotification returns generated.SomeoneFollowedYouBackNotificationResolver implementation.
func (r *Resolver) SomeoneFollowedYouBackNotification() generated.SomeoneFollowedYouBackNotificationResolver {
	return &someoneFollowedYouBackNotificationResolver{r}
}

// SomeoneFollowedYouNotification returns generated.SomeoneFollowedYouNotificationResolver implementation.
func (r *Resolver) SomeoneFollowedYouNotification() generated.SomeoneFollowedYouNotificationResolver {
	return &someoneFollowedYouNotificationResolver{r}
}

// SomeoneMentionedYouNotification returns generated.SomeoneMentionedYouNotificationResolver implementation.
func (r *Resolver) SomeoneMentionedYouNotification() generated.SomeoneMentionedYouNotificationResolver {
	return &someoneMentionedYouNotificationResolver{r}
}

// SomeoneMentionedYourCommunityNotification returns generated.SomeoneMentionedYourCommunityNotificationResolver implementation.
func (r *Resolver) SomeoneMentionedYourCommunityNotification() generated.SomeoneMentionedYourCommunityNotificationResolver {
	return &someoneMentionedYourCommunityNotificationResolver{r}
}

// SomeonePostedYourWorkNotification returns generated.SomeonePostedYourWorkNotificationResolver implementation.
func (r *Resolver) SomeonePostedYourWorkNotification() generated.SomeonePostedYourWorkNotificationResolver {
	return &someonePostedYourWorkNotificationResolver{r}
}

// SomeoneRepliedToYourCommentNotification returns generated.SomeoneRepliedToYourCommentNotificationResolver implementation.
func (r *Resolver) SomeoneRepliedToYourCommentNotification() generated.SomeoneRepliedToYourCommentNotificationResolver {
	return &someoneRepliedToYourCommentNotificationResolver{r}
}

// SomeoneViewedYourGalleryNotification returns generated.SomeoneViewedYourGalleryNotificationResolver implementation.
func (r *Resolver) SomeoneViewedYourGalleryNotification() generated.SomeoneViewedYourGalleryNotificationResolver {
	return &someoneViewedYourGalleryNotificationResolver{r}
}

// SomeoneYouFollowPostedTheirFirstPostNotification returns generated.SomeoneYouFollowPostedTheirFirstPostNotificationResolver implementation.
func (r *Resolver) SomeoneYouFollowPostedTheirFirstPostNotification() generated.SomeoneYouFollowPostedTheirFirstPostNotificationResolver {
	return &someoneYouFollowPostedTheirFirstPostNotificationResolver{r}
}

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// Token returns generated.TokenResolver implementation.
func (r *Resolver) Token() generated.TokenResolver { return &tokenResolver{r} }

// TokenDefinition returns generated.TokenDefinitionResolver implementation.
func (r *Resolver) TokenDefinition() generated.TokenDefinitionResolver {
	return &tokenDefinitionResolver{r}
}

// TokenHolder returns generated.TokenHolderResolver implementation.
func (r *Resolver) TokenHolder() generated.TokenHolderResolver { return &tokenHolderResolver{r} }

// TokensAddedToCollectionFeedEventData returns generated.TokensAddedToCollectionFeedEventDataResolver implementation.
func (r *Resolver) TokensAddedToCollectionFeedEventData() generated.TokensAddedToCollectionFeedEventDataResolver {
	return &tokensAddedToCollectionFeedEventDataResolver{r}
}

// UnfollowUserPayload returns generated.UnfollowUserPayloadResolver implementation.
func (r *Resolver) UnfollowUserPayload() generated.UnfollowUserPayloadResolver {
	return &unfollowUserPayloadResolver{r}
}

// UpdateCollectionTokensPayload returns generated.UpdateCollectionTokensPayloadResolver implementation.
func (r *Resolver) UpdateCollectionTokensPayload() generated.UpdateCollectionTokensPayloadResolver {
	return &updateCollectionTokensPayloadResolver{r}
}

// UserCreatedFeedEventData returns generated.UserCreatedFeedEventDataResolver implementation.
func (r *Resolver) UserCreatedFeedEventData() generated.UserCreatedFeedEventDataResolver {
	return &userCreatedFeedEventDataResolver{r}
}

// UserFollowedUsersFeedEventData returns generated.UserFollowedUsersFeedEventDataResolver implementation.
func (r *Resolver) UserFollowedUsersFeedEventData() generated.UserFollowedUsersFeedEventDataResolver {
	return &userFollowedUsersFeedEventDataResolver{r}
}

// Viewer returns generated.ViewerResolver implementation.
func (r *Resolver) Viewer() generated.ViewerResolver { return &viewerResolver{r} }

// Wallet returns generated.WalletResolver implementation.
func (r *Resolver) Wallet() generated.WalletResolver { return &walletResolver{r} }

// ChainAddressInput returns generated.ChainAddressInputResolver implementation.
func (r *Resolver) ChainAddressInput() generated.ChainAddressInputResolver {
	return &chainAddressInputResolver{r}
}

// ChainPubKeyInput returns generated.ChainPubKeyInputResolver implementation.
func (r *Resolver) ChainPubKeyInput() generated.ChainPubKeyInputResolver {
	return &chainPubKeyInputResolver{r}
}

type admireResolver struct{ *Resolver }
type admireFeedEventPayloadResolver struct{ *Resolver }
type admirePostPayloadResolver struct{ *Resolver }
type admireTokenPayloadResolver struct{ *Resolver }
type collectionResolver struct{ *Resolver }
type collectionCreatedFeedEventDataResolver struct{ *Resolver }
type collectionTokenResolver struct{ *Resolver }
type collectionUpdatedFeedEventDataResolver struct{ *Resolver }
type collectorsNoteAddedToCollectionFeedEventDataResolver struct{ *Resolver }
type collectorsNoteAddedToTokenFeedEventDataResolver struct{ *Resolver }
type commentResolver struct{ *Resolver }
type commentOnFeedEventPayloadResolver struct{ *Resolver }
type commentOnPostPayloadResolver struct{ *Resolver }
type communityResolver struct{ *Resolver }
type contractResolver struct{ *Resolver }
type createCollectionPayloadResolver struct{ *Resolver }
type ensProfileImageResolver struct{ *Resolver }
type feedEventResolver struct{ *Resolver }
type followInfoResolver struct{ *Resolver }
type followUserPayloadResolver struct{ *Resolver }
type galleryResolver struct{ *Resolver }
type galleryInfoUpdatedFeedEventDataResolver struct{ *Resolver }
type galleryUpdatedFeedEventDataResolver struct{ *Resolver }
type galleryUserResolver struct{ *Resolver }
type mentionResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type newTokensNotificationResolver struct{ *Resolver }
type ownerAtBlockResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type postComposerDraftDetailsPayloadResolver struct{ *Resolver }
type previewURLSetResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type removeAdmirePayloadResolver struct{ *Resolver }
type removeCommentPayloadResolver struct{ *Resolver }
type setSpamPreferencePayloadResolver struct{ *Resolver }
type socialConnectionResolver struct{ *Resolver }
type socialQueriesResolver struct{ *Resolver }
type someoneAdmiredYourFeedEventNotificationResolver struct{ *Resolver }
type someoneAdmiredYourPostNotificationResolver struct{ *Resolver }
type someoneAdmiredYourTokenNotificationResolver struct{ *Resolver }
type someoneCommentedOnYourFeedEventNotificationResolver struct{ *Resolver }
type someoneCommentedOnYourPostNotificationResolver struct{ *Resolver }
type someoneFollowedYouBackNotificationResolver struct{ *Resolver }
type someoneFollowedYouNotificationResolver struct{ *Resolver }
type someoneMentionedYouNotificationResolver struct{ *Resolver }
type someoneMentionedYourCommunityNotificationResolver struct{ *Resolver }
type someonePostedYourWorkNotificationResolver struct{ *Resolver }
type someoneRepliedToYourCommentNotificationResolver struct{ *Resolver }
type someoneViewedYourGalleryNotificationResolver struct{ *Resolver }
type someoneYouFollowPostedTheirFirstPostNotificationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type tokenResolver struct{ *Resolver }
type tokenDefinitionResolver struct{ *Resolver }
type tokenHolderResolver struct{ *Resolver }
type tokensAddedToCollectionFeedEventDataResolver struct{ *Resolver }
type unfollowUserPayloadResolver struct{ *Resolver }
type updateCollectionTokensPayloadResolver struct{ *Resolver }
type userCreatedFeedEventDataResolver struct{ *Resolver }
type userFollowedUsersFeedEventDataResolver struct{ *Resolver }
type viewerResolver struct{ *Resolver }
type walletResolver struct{ *Resolver }
type chainAddressInputResolver struct{ *Resolver }
type chainPubKeyInputResolver struct{ *Resolver }
