"""
Any field decorated with the @experimental directive should not be used in production.
It will not conform to our rules around breaking changes.
"""
directive @experimental on FIELD_DEFINITION

# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
  forceResolver: Boolean
  name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Add @authRequired to any field that requires a user to be logged in. NOTE: Any field tagged with
# @authRequired MUST return a union type that includes ErrNotAuthorized.
#
# If we need more control over auth in the future, this directive can be updated to take
# arguments that specify the level of access required.
directive @authRequired on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Add @basicAuth to any field that should be secured by a basic auth token. For example, some fields
# should only be usable by Retool, so they'd use @basicAuth(allowed: [Retool]). Other fields might be
# accessible by both Retool and Monitoring, so they'd use @basicAuth(allowed: [Retool, Monitoring]).
directive @basicAuth(allowed: [BasicAuthType!]!) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @frontendBuildAuth on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Use @scrub on any input field that should be omitted from request logging (e.g. passwords or
# other sensitive data)
directive @scrub on INPUT_FIELD_DEFINITION

# Use @restrictEnvironment to choose which values of the ENV environment variable the annotated field/object
# should be usable in (case-insensitive). Example: @restrictEnvironment(allowed:["local", "development"]) would
# allow a field in "local" and "development" environments but not in "production"
directive @restrictEnvironment(
  allowed: [String!]!
) on INPUT_FIELD_DEFINITION | INPUT_OBJECT | FIELD_DEFINITION | OBJECT

# All types that implement Node must have a unique GqlID set in their "id" field. For types with
# a "dbid" field, it's assumed that we can synthesize a unique ID from the type name and the dbid,
# so those types will automatically have an ID function generated for them (which gqlgen will find
# and bind to). Types without a dbid field, or types that need multiple inputs to create a unique ID
# that can be used to refetch the node in the future, must use the @goGqlId directive to explicitly
# state the fields that will be used to generate the ID. If a named field exists on the object and is
# a string-based type, that field will be used as part of the ID automatically. Otherwise, a manual
# getter method will need to be implemented to retrieve that component of the GqlID.
directive @goGqlId(fields: [String!]!) on OBJECT

# Injects a "Helper<TypeName>Data" struct embed into a generated type. Useful for adding backend-only
# helper data necessary to resolve queries, while keeping that data out of the schema and invisible
# to clients.
directive @goEmbedHelper on OBJECT

scalar Time
scalar Address
scalar PubKey
scalar DBID
scalar Email
scalar TokenId

enum BasicAuthType {
  Retool
  Monitoring
}

interface Node {
  id: ID!
}

type DeletedNode implements Node {
  id: ID!
  dbid: DBID!
}

interface Error {
  message: String!
}

type TokenProfileImage {
  token: Token!
}

type HTTPSProfileImage {
  previewURLs: PreviewURLSet
}

type EnsProfileImage @goEmbedHelper {
  wallet: Wallet @goField(forceResolver: true)
  profileImage: HTTPSProfileImage
  token: Token @goField(forceResolver: true)
}

union ProfileImage = TokenProfileImage | EnsProfileImage

type GalleryUser implements Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  username: String
  profileImage: ProfileImage @goField(forceResolver: true)
  potentialEnsProfileImage: EnsProfileImage @goField(forceResolver: true)
  bio: String
  universal: Boolean
  roles: [Role] @goField(forceResolver: true)
  socialAccounts: SocialAccounts @goField(forceResolver: true)

  # Returns all tokens owned by this user. Useful for retrieving all tokens without any duplicates,
  # as opposed to retrieving user -> wallets -> tokens, which would contain duplicates for any token
  # that appears in more than one of the user's wallets.
  tokens(ownershipFilter: [TokenOwnershipType!]): [Token] @goField(forceResolver: true)
  tokensBookmarked(before: String, after: String, first: Int, last: Int): TokensConnection
    @goField(forceResolver: true)

  wallets: [Wallet] @goField(forceResolver: true)
  primaryWallet: Wallet @goField(forceResolver: true)
  featuredGallery: Gallery @goField(forceResolver: true)
  galleries: [Gallery] @goField(forceResolver: true)
  badges: [Badge] @goField(forceResolver: true)
  isAuthenticatedUser: Boolean
  followers: [GalleryUser] @goField(forceResolver: true)
  following: [GalleryUser] @goField(forceResolver: true)
  feed(
    before: String
    after: String
    first: Int
    last: Int
    includePosts: Boolean! = false @deprecated(reason: "Posts are always included now.")
  ): FeedConnection @goField(forceResolver: true)
  sharedFollowers(before: String, after: String, first: Int, last: Int): UsersConnection
    @goField(forceResolver: true)
  sharedCommunities(before: String, after: String, first: Int, last: Int): CommunitiesConnection
    @goField(forceResolver: true)
  createdCommunities(
    input: CreatedCommunitiesInput!
    before: String
    after: String
    first: Int
    last: Int
  ): CommunitiesConnection @goField(forceResolver: true)
  isMemberOfCommunity(communityID: DBID!): Boolean! @goField(forceResolver: true)
}

enum Persona {
  None
  Collector
  Creator
  Both
}

type Wallet implements Node {
  id: ID!
  dbid: DBID!
  chainAddress: ChainAddress
  chain: Chain
  walletType: WalletType
  tokens: [Token] @goField(forceResolver: true)
}

type ChainAddress {
  address: Address
  chain: Chain
}

type ChainPubKey {
  pubKey: PubKey
  chain: Chain
}

type ChainTokens {
  chain: Chain
  tokens: [Token]
}

input ChainAddressInput {
  address: Address! @goField(forceResolver: true)
  chain: Chain! @goField(forceResolver: true)
}

input ChainPubKeyInput {
  pubKey: PubKey! @goField(forceResolver: true)
  chain: Chain! @goField(forceResolver: true)
}

type ContractCommunityKey {
  contract: ChainAddress
}

input ContractCommunityKeyInput {
  contract: ChainAddressInput!
}

type ArtBlocksCommunityKey {
  contract: ChainAddress
  projectID: String
}

input ArtBlocksCommunityKeyInput {
  contract: ChainAddressInput!
  projectID: String!
}

input CreatedCommunitiesInput {
  # When includeChains is empty, returns all communities from all chains.
  includeChains: [Chain!]
}

input SyncCreatedTokensForNewContractsInput {
  # When includeChains is empty, syncs tokens on all chains.
  includeChains: [Chain!]
  incrementally: Boolean
}

input SyncCreatedTokensForExistingContractInput {
  contractId: DBID!
}

type Badge {
  name: String
  imageURL: String!
  contract: Contract
}

union GalleryUserOrWallet = GalleryUser | Wallet

union GalleryUserOrAddress = GalleryUser | ChainAddress

union MediaSubtype =
    ImageMedia
  | GIFMedia
  | VideoMedia
  | AudioMedia
  | TextMedia
  | PdfMedia
  | HtmlMedia
  | JsonMedia
  | GltfMedia
  | UnknownMedia
  | SyncingMedia
  | InvalidMedia

type PreviewURLSet {
  raw: String
  thumbnail: String
  small: String
  medium: String
  large: String
  srcSet: String
  liveRender: String
  blurhash: String @experimental @goField(forceResolver: true)
}

type VideoURLSet {
  raw: String
  small: String
  medium: String
  large: String
}

type MediaDimensions {
  width: Int
  height: Int
  aspectRatio: Float
}

type FallbackMedia {
  mediaURL: String
  mediaType: String
}

interface Media {
  # Various sizes of preview images for the media
  previewURLs: PreviewURLSet

  # The original source URL for the media (may be IPFS, etc)
  mediaURL: String

  # The type of media, as determined by the backend. May be redundant given the approach we're using here
  # (media subtypes implementing the Media interface)
  mediaType: String

  # All Media types will also have something like contentRenderURL or contentRenderURLs,
  # which are the URL(s) that should actually be used for rendering the media's content

  # The dimensions of the media, if known
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type ImageMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type GIFMedia implements Media {
  previewURLs: PreviewURLSet
  staticPreviewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type VideoMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURLs: VideoURLSet
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type AudioMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type TextMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type PdfMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type HtmlMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type JsonMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type GltfMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type UnknownMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type SyncingMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

type InvalidMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions

  fallbackMedia: FallbackMedia
}

enum TokenType {
  ERC721
  ERC1155
  ERC20
}

enum Chain {
  Ethereum
  Arbitrum
  Polygon
  Optimism
  Tezos
  POAP
  Zora
  Base
}

enum TokenOwnershipType {
  Holder
  Creator
}

enum WalletType {
  EOA
  GnosisSafe
}

enum InteractionType {
  Admire
  Comment
}

type TokenDefinition implements Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  creationTime: Time
  lastUpdated: Time
  media(darkMode: DarkMode): MediaSubtype @goField(forceResolver: true)
  tokenType: TokenType
  contract: Contract @goField(forceResolver: true)
  chain: Chain
  name: String
  description: String
  tokenId: String
  tokenMetadata: String @goField(forceResolver: true)
  community: Community @goField(forceResolver: true)
  communities: [Community] @goField(forceResolver: true)
  externalUrl: String
  mintUrl: String @goField(forceResolver: true)
}

type Token implements Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  creationTime: Time
  lastUpdated: Time
  collectorsNote: String
  quantity: String # source is a hex string
  owner: GalleryUser @goField(forceResolver: true)
  ownedByWallets: [Wallet] @goField(forceResolver: true)
  ownershipHistory: [OwnerAtBlock] @deprecated
  ownerIsHolder: Boolean
  ownerIsCreator: Boolean
  definition: TokenDefinition! @goField(forceResolver: true)
  isSpamByUser: Boolean
  # Returns an admires connection
  admires(
    before: String
    after: String
    first: Int
    last: Int
    userID: DBID
  ): TokenAdmiresConnection @goField(forceResolver: true)
  viewerAdmire: Admire @goField(forceResolver: true)

  # The following fields will be deprecated and removed in the future.
  media(darkMode: DarkMode): MediaSubtype
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.media instead")
  tokenType: TokenType
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.tokenType instead")
  chain: Chain @goField(forceResolver: true) @deprecated(reason: "Use definition.chain instead")
  name: String @goField(forceResolver: true) @deprecated(reason: "Use definition.name instead")
  description: String
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.description instead")
  tokenId: String
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.tokenId instead")
  tokenMetadata: String
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.tokenMetadata instead")
  contract: Contract
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.contract instead")
  community: Community
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.community instead")
  externalUrl: String
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.externalUrl instead")
  isSpamByProvider: Boolean
    @goField(forceResolver: true)
    @deprecated(reason: "Use definition.community.contract.isSpam instead")
  creatorAddress: ChainAddress
    @deprecated(reason: "Use definition.community.creatorAddress instead")
  openseaCollectionName: String @deprecated
  blockNumber: String @deprecated # source is uint64
  openseaId: Int @deprecated
}

type OwnerAtBlock {
  # TODO: will need to store addresses to make this resolver work
  owner: GalleryUserOrAddress @goField(forceResolver: true)
  blockNumber: String # source is uint64
}

type CollectionToken implements Node @goEmbedHelper @goGqlId(fields: ["tokenId", "collectionId"]) {
  id: ID!
  token: Token @goField(forceResolver: true)
  collection: Collection @goField(forceResolver: true)
  tokenSettings: CollectionTokenSettings @goField(forceResolver: true)
}

type CollectionLayout {
  sections: [Int]
  sectionLayout: [CollectionSectionLayout]
}

type CollectionSectionLayout {
  columns: Int
  whitespace: [Int]
}

type CollectionTokenSettings {
  renderLive: Boolean
  highDefinition: Boolean
}

type CollectionEdge {
  node: Collection
  cursor: String
}

type CollectionsConnection {
  edges: [CollectionEdge]
  pageInfo: PageInfo!
}

type Collection implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  name: String
  collectorsNote: String
  gallery: Gallery @goField(forceResolver: true)
  layout: CollectionLayout
  hidden: Boolean
  tokens(limit: Int): [CollectionToken] @goField(forceResolver: true)
}

type Gallery implements Node {
  id: ID!
  dbid: DBID!
  name: String
  description: String
  position: String
  hidden: Boolean
  tokenPreviews: [PreviewURLSet] @goField(forceResolver: true)
  owner: GalleryUser @goField(forceResolver: true)
  collections: [Collection] @goField(forceResolver: true)
}

type TokenHolder @goEmbedHelper {
  displayName: String
  wallets: [Wallet] @goField(forceResolver: true)
  user: GalleryUser @goField(forceResolver: true)
  previewTokens: [String] @goField(forceResolver: true)
}

type MembershipTier implements Node {
  id: ID!
  dbid: DBID!
  name: String
  assetUrl: String
  tokenId: String
  owners: [TokenHolder]
}

type TokenEdge {
  node: Token
  cursor: String
}

type TokensConnection {
  edges: [TokenEdge]
  pageInfo: PageInfo!
}

type TokenHolderEdge {
  node: TokenHolder
  cursor: String
}

type TokenHoldersConnection {
  edges: [TokenHolderEdge]
  pageInfo: PageInfo!
}

type CommunityGallery {
  gallery: Gallery
  tokenPreviews: [PreviewURLSet]
}

type CommunityGalleryEdge {
  node: CommunityGallery
  cursor: String
}

type CommunityGalleriesConnection {
  edges: [CommunityGalleryEdge]
  pageInfo: PageInfo!
}

type ContractCommunity @goEmbedHelper {
  communityKey: ContractCommunityKey
  contract: Contract @goField(forceResolver: true)
}

type ArtBlocksCommunity @goEmbedHelper {
  communityKey: ArtBlocksCommunityKey
  contract: Contract @goField(forceResolver: true)
  projectID: String
}

union CommunitySubtype = ContractCommunity | ArtBlocksCommunity

type Community implements Node @goEmbedHelper {
  dbid: DBID!
  id: ID!

  lastUpdated: Time

  name: String
  description: String
  profileImageURL: String
  badgeURL: String
  mintURL: String @goField(forceResolver: true)

  subtype: CommunitySubtype
  creators: [GalleryUserOrAddress] @goField(forceResolver: true)

  holders(before: String, after: String, first: Int, last: Int): TokenHoldersConnection
    @goField(forceResolver: true)

  tokens(before: String, after: String, first: Int, last: Int): TokensConnection
    @goField(forceResolver: true)

  posts(before: String, after: String, first: Int, last: Int): PostsConnection
    @goField(forceResolver: true)

  # Temporary fields
  tokensForFrame(limit: Int!): [Token] @goField(forceResolver: true)

  # Deprecated fields
  contract: Contract
    @goField(forceResolver: true)
    @deprecated(reason: "Use Community.subtype. Not all communities have contracts.")
  contractAddress: ChainAddress
    @goField(forceResolver: true)
    @deprecated(reason: "Use Community.subtype. Not all communities have contracts.")
  chain: Chain
    @goField(forceResolver: true)
    @deprecated(reason: "Use Community.subtype. Not all communities have contracts.")
  creatorAddress: ChainAddress
    @goField(forceResolver: true)
    @deprecated(reason: "Use Community.creators to get an address")
  creator: GalleryUserOrAddress @goField(forceResolver: true)

  tokensInCommunity(
    before: String
    after: String
    first: Int
    last: Int
    onlyGalleryUsers: Boolean
  ): TokensConnection @goField(forceResolver: true) @deprecated(reason: "Use Community.tokens")

  owners(
    before: String
    after: String
    first: Int
    last: Int
    onlyGalleryUsers: Boolean
  ): TokenHoldersConnection
    @goField(forceResolver: true)
    @deprecated(reason: "Use Community.holders")

  galleries(
    maxPreviews: Int!
    before: String
    after: String
    first: Int
    last: Int
  ): CommunityGalleriesConnection @goField(forceResolver: true)

  viewerIsMember: Boolean @goField(forceResolver: true)
}

type Contract implements Node {
  id: ID!
  dbid: DBID!

  lastUpdated: Time

  contractAddress: ChainAddress
  creatorAddress: ChainAddress
  chain: Chain
  name: String
  profileImageURL: String
  profileBannerURL: String
  badgeURL: String
  mintURL: String
  isSpam: Boolean
}

# We have this extra type in case we need to stick authed data
# in here one day.
type ViewerGallery {
  gallery: Gallery
}

type NotificationEdge {
  node: Notification
  cursor: String
}

type NotificationsConnection @goEmbedHelper {
  edges: [NotificationEdge]
  unseenCount: Int
  pageInfo: PageInfo
}

enum SocialAccountType {
  Twitter
  Farcaster
  Lens
}

interface SocialAccount {
  type: SocialAccountType!
  social_id: String!
  display: Boolean!
}

type SocialAccounts {
  twitter: TwitterSocialAccount
  farcaster: FarcasterSocialAccount
  lens: LensSocialAccount
}

type TwitterSocialAccount implements SocialAccount {
  type: SocialAccountType!
  social_id: String!
  name: String!
  username: String!
  profileImageURL: String!
  display: Boolean!
  scope: String!
}

type FarcasterSocialAccount implements SocialAccount {
  type: SocialAccountType!
  social_id: String!
  name: String!
  username: String!
  profileImageURL: String!
  bio: String!
  display: Boolean!
  approvalURL: String
  signerStatus: String
}

type LensSocialAccount implements SocialAccount {
  type: SocialAccountType!
  social_id: String!
  name: String!
  username: String!
  profileImageURL: String!
  bio: String!
  display: Boolean!
  signatureApproved: Boolean!
}

type Viewer implements Node @goGqlId(fields: ["userId"]) @goEmbedHelper {
  id: ID!
  user: GalleryUser @goField(forceResolver: true)
  socialAccounts: SocialAccounts @goField(forceResolver: true)
  viewerGalleries: [ViewerGallery] @goField(forceResolver: true)
  feed(
    before: String
    after: String
    first: Int
    last: Int
    includePosts: Boolean! = false @deprecated(reason: "Posts are always included now.")
  ): FeedConnection @goField(forceResolver: true)

  email: UserEmail @goField(forceResolver: true)
  """
  Returns a list of notifications in reverse chronological order.
  Seen notifications come after unseen notifications
  """
  notifications(before: String, after: String, first: Int, last: Int): NotificationsConnection
    @goField(forceResolver: true)

  notificationSettings: NotificationSettings @goField(forceResolver: true)

  userExperiences: [UserExperience!] @goField(forceResolver: true)
  persona: Persona @goField(forceResolver: true)
  suggestedUsers(before: String, after: String, first: Int, last: Int): UsersConnection
    @goField(forceResolver: true)
  suggestedUsersFarcaster(before: String, after: String, first: Int, last: Int): UsersConnection
    @goField(forceResolver: true)
}

type NotificationSettings {
  someoneFollowedYou: Boolean
  someoneAdmiredYourUpdate: Boolean
  someoneCommentedOnYourUpdate: Boolean
  someoneViewedYourGallery: Boolean
}

input NotificationSettingsInput {
  someoneFollowedYou: Boolean
  someoneAdmiredYourUpdate: Boolean
  someoneCommentedOnYourUpdate: Boolean
  someoneViewedYourGallery: Boolean
}

enum EmailVerificationStatus {
  Unverified
  Verified
  Failed
  Admin
}

enum EmailUnsubscriptionType {
  All
  Notifications
  Digest
  Marketing
  MembersClub
}

type UserEmail {
  email: Email
  verificationStatus: EmailVerificationStatus
  emailNotificationSettings: EmailNotificationSettings @goField(forceResolver: true)
}

type EmailNotificationSettings {
  unsubscribedFromAll: Boolean!
  unsubscribedFromNotifications: Boolean!
  unsubscribedFromDigest: Boolean!
  unsubscribedFromMarketing: Boolean
  unsubscribedFromMembersClub: Boolean # TODO make this required once frontend is updated
}

input UpdateEmailNotificationSettingsInput {
  unsubscribedFromAll: Boolean!
  unsubscribedFromNotifications: Boolean!
  unsubscribedFromDigest: Boolean!
  unsubscribedFromMarketing: Boolean
  unsubscribedFromMembersClub: Boolean
}

input UnsubscribeFromEmailTypeInput {
  type: EmailUnsubscriptionType!
  token: String! @scrub
}

enum UserExperienceType {
  MultiGalleryAnnouncement
  EmailUpsell
  MerchStoreUpsell
  MaintenanceFeb2023
  MaintenanceAug2023
  TwitterConnectionOnboardingUpsell
  UpsellMintMemento4
  UpsellGallerySelects1
  MobileUpsell1
  MobileBetaUpsell
  UpsellMintMemento5
  UpsellBanner
  PostsBetaAnnouncement
  CreatorBetaFullscreenAnnouncementModal
  CreatorBetaMicroAnnouncementModal
  RadianceMintApr2024
}

type UserExperience {
  type: UserExperienceType!
  experienced: Boolean!
}

union UserByUsernameOrError = GalleryUser | ErrUserNotFound | ErrInvalidInput

union UserByIdOrError = GalleryUser | ErrUserNotFound | ErrInvalidInput

union UserByAddressOrError = GalleryUser | ErrUserNotFound | ErrInvalidInput

type UsersByAddressesPayload {
  users: [GalleryUser!]
}

union UsersByAddressesPayloadOrError = UsersByAddressesPayload | ErrInvalidInput

union ViewerOrError = Viewer | ErrNotAuthorized

type ErrCollectionNotFound implements Error {
  message: String!
}

union TokenByIdOrError = Token | ErrTokenNotFound

type ErrTokenNotFound implements Error {
  message: String!
}

union CollectionByIdOrError = Collection | ErrCollectionNotFound | ErrInvalidInput

union CollectionTokenByIdOrError = CollectionToken | ErrCollectionNotFound | ErrTokenNotFound

union CommunityByIdOrError = Community | ErrCommunityNotFound | ErrInvalidInput
union CommunityByAddressOrError = Community | ErrCommunityNotFound | ErrInvalidInput
union CommunityByKeyOrError = Community | ErrCommunityNotFound | ErrInvalidInput

union AdmireSource = Post | FeedEvent | Comment

type Admire implements Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  creationTime: Time
  lastUpdated: Time
  admirer: GalleryUser @goField(forceResolver: true)
  source: AdmireSource @goField(forceResolver: true)
}

union CommentSource = Post | FeedEvent

type Comment implements Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  creationTime: Time
  lastUpdated: Time
  replyTo: Comment @goField(forceResolver: true)
  commenter: GalleryUser @goField(forceResolver: true)
  comment: String
  mentions: [Mention] @goField(forceResolver: true)
  replies(before: String, after: String, first: Int, last: Int): CommentsConnection
    @goField(forceResolver: true)
  source: CommentSource @goField(forceResolver: true)

  # deleted is included because we want to still return deleted comments to show on the frontend but render them differently
  deleted: Boolean
  viewerAdmire: Admire @goField(forceResolver: true)
  admires(before: String, after: String, first: Int, last: Int): CommentAdmiresConnection
    @goField(forceResolver: true)
}

type CommentAdmiresConnection {
  edges: [CommentAdmireEdge]
  pageInfo: PageInfo
}

type CommentAdmireEdge {
  node: Admire
  cursor: String
}

union MentionEntity = GalleryUser | Community

type Mention @goEmbedHelper {
  entity: MentionEntity @goField(forceResolver: true)
  interval: Interval
}

type Interval {
  start: Int!
  length: Int!
}

# Actions a user can take on a resource
enum Action {
  UserCreated
  UserFollowedUsers
  CollectorsNoteAddedtoToken
  CollectionCreated
  CollectorsNoteAddedToCollection
  TokensAddedToCollection
}

type FollowInfo {
  user: GalleryUser @goField(forceResolver: true)
  followedBack: Boolean
}

type PostAdmireEdge {
  node: Admire
  cursor: String
}

type FeedEventAdmireEdge {
  node: Admire
  cursor: String
}

type PostAdmiresConnection {
  edges: [PostAdmireEdge]
  pageInfo: PageInfo!
}

type FeedEventAdmiresConnection {
  edges: [FeedEventAdmireEdge]
  pageInfo: PageInfo!
}

type PostCommentEdge {
  node: Comment
  cursor: String
}

type CommentEdge {
  node: Comment
  cursor: String
}

type CommentsConnection {
  edges: [CommentEdge]
  pageInfo: PageInfo!
}

type PostCommentsConnection {
  edges: [PostCommentEdge]
  pageInfo: PageInfo!
}

type FeedEventCommentEdge {
  node: Comment
  cursor: String
}

type FeedEventCommentsConnection {
  edges: [FeedEventCommentEdge]
  pageInfo: PageInfo!
}

type TokenAdmireEdge {
  node: Admire
  cursor: String
  token: Token
}

type TokenAdmiresConnection {
  edges: [TokenAdmireEdge]
  pageInfo: PageInfo
}

union Interaction = Admire | Comment

type InteractionsEdge {
  node: Interaction
  cursor: String
}

type InteractionsConnection {
  edges: [InteractionsEdge]
  pageInfo: PageInfo!
}

union PostOrError = Post | ErrPostNotFound | ErrInvalidInput

type PostEdge {
  node: PostOrError
  cursor: String
}

type PostsConnection {
  edges: [PostEdge]
  pageInfo: PageInfo!
}

interface FeedEventData {
  eventTime: Time
  owner: GalleryUser
  action: Action
}

type FeedEvent implements Node @key(fields: "dbid") {
  id: ID!
  dbid: DBID!

  eventData: FeedEventData @goField(forceResolver: true)
  admires(before: String, after: String, first: Int, last: Int): FeedEventAdmiresConnection
    @goField(forceResolver: true)
  comments(before: String, after: String, first: Int, last: Int): FeedEventCommentsConnection
    @goField(forceResolver: true)

  totalComments: Int @goField(forceResolver: true)

  caption: String

  interactions(before: String, after: String, first: Int, last: Int): InteractionsConnection
    @goField(forceResolver: true)

  viewerAdmire: Admire @goField(forceResolver: true)

  # TODO: This is just here while we migrate the frontend over to viewerAdmire.
  # Remove this in the near future.
  hasViewerAdmiredEvent: Boolean @goField(forceResolver: true)
}

type Post implements Node @key(fields: "dbid") @goEmbedHelper {
  id: ID!
  dbid: DBID!

  author: GalleryUser @goField(forceResolver: true)
  creationTime: Time

  tokens: [Token] @goField(forceResolver: true)

  caption: String
  mentions: [Mention] @goField(forceResolver: true)

  admires(before: String, after: String, first: Int, last: Int): PostAdmiresConnection
    @goField(forceResolver: true)
  comments(before: String, after: String, first: Int, last: Int): PostCommentsConnection
    @goField(forceResolver: true)

  totalComments: Int @goField(forceResolver: true)

  interactions(before: String, after: String, first: Int, last: Int): InteractionsConnection
    @goField(forceResolver: true)

  viewerAdmire: Admire @goField(forceResolver: true)
  isFirstPost: Boolean!
  userAddedMintURL: String
}

type UserCreatedFeedEventData implements FeedEventData {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  action: Action
}

type UserFollowedUsersFeedEventData implements FeedEventData {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  action: Action
  followed: [FollowInfo]
}

type CollectorsNoteAddedToTokenFeedEventData implements FeedEventData {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  action: Action
  token: CollectionToken @goField(forceResolver: true)
  newCollectorsNote: String
}

type CollectionCreatedFeedEventData implements FeedEventData @goEmbedHelper {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  action: Action
  collection: Collection @goField(forceResolver: true)
  newTokens: [CollectionToken] @goField(forceResolver: true)
  newCollectorsNote: String
}

type CollectorsNoteAddedToCollectionFeedEventData implements FeedEventData {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  action: Action
  collection: Collection @goField(forceResolver: true)
  newCollectorsNote: String
}

type TokensAddedToCollectionFeedEventData implements FeedEventData @goEmbedHelper {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  collection: Collection @goField(forceResolver: true)
  action: Action
  newTokens: [CollectionToken] @goField(forceResolver: true)
  isPreFeed: Boolean
}

type CollectionUpdatedFeedEventData implements FeedEventData @goEmbedHelper {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  action: Action
  collection: Collection @goField(forceResolver: true)
  newCollectorsNote: String
  newTokens: [CollectionToken] @goField(forceResolver: true)
}

type GalleryInfoUpdatedFeedEventData implements FeedEventData {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  newName: String
  newDescription: String
  action: Action
}

type GalleryUpdatedFeedEventData implements FeedEventData @goEmbedHelper {
  eventTime: Time
  owner: GalleryUser @goField(forceResolver: true)
  action: Action
  gallery: Gallery @goField(forceResolver: true)
  subEventDatas: [FeedEventData!] @goField(forceResolver: true)
  newName: String
  newDescription: String
}

type ErrUnknownAction implements Error {
  message: String!
}

type ErrFeedEventNotFound implements Error {
  message: String!
}

type ErrPostNotFound implements Error {
  message: String!
}

"""
Can return posts as well
"""
union FeedEventOrError =
    FeedEvent
  | Post
  | ErrPostNotFound
  | ErrFeedEventNotFound
  | ErrUnknownAction

union FeedEventByIdOrError = FeedEvent | ErrFeedEventNotFound | ErrUnknownAction

type PageInfo {
  total: Int
  size: Int!
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type FeedEdge {
  node: FeedEventOrError
  cursor: String
}

type FeedConnection {
  edges: [FeedEdge]
  pageInfo: PageInfo!
}

type SocialConnection implements Node @goGqlId(fields: ["socialId", "socialType"]) @goEmbedHelper {
  id: ID!

  galleryUser: GalleryUser @goField(forceResolver: true)

  currentlyFollowing: Boolean!
  socialId: String!
  socialType: SocialAccountType!
  displayName: String!
  socialUsername: String!
  profileImage: String!
}

union SocialConnectionsOrError = SocialConnection | ErrInvalidInput

type SocialConnectionsEdge {
  node: SocialConnectionsOrError
  cursor: String
}

type SocialConnectionsConnection {
  edges: [SocialConnectionsEdge]
  pageInfo: PageInfo!
}

type UserEdge {
  node: GalleryUser
  cursor: String
}

type UsersConnection {
  edges: [UserEdge]
  pageInfo: PageInfo!
}

type CommunityEdge {
  node: Community
  cursor: String
}

type CommunitiesConnection {
  edges: [CommunityEdge]
  pageInfo: PageInfo!
}

enum Role {
  ADMIN
  BETA_TESTER
  EARLY_ACCESS
  EMAIL_TESTER
}

enum MerchType {
  TShirt
  Hat
  Card
}

type MerchToken implements Node @goGqlId(fields: ["tokenId"]) {
  id: ID!
  tokenId: String!
  objectType: MerchType!
  discountCode: String
  redeemed: Boolean!
}

type MerchTokensPayload {
  tokens: [MerchToken!]
}

union MerchTokensPayloadOrError = MerchTokensPayload | ErrInvalidInput

type ErrGalleryNotFound implements Error {
  message: String!
}

union GalleryByIdPayloadOrError = Gallery | ErrGalleryNotFound
union ViewerGalleryByIdPayloadOrError = ViewerGallery | ErrGalleryNotFound

enum ReportWindow {
  LAST_5_DAYS
  LAST_7_DAYS
  ALL_TIME
}

input TrendingUsersInput {
  report: ReportWindow!
}

type TrendingUsersPayload {
  # User are in descending order i.e. the most trending user is first.
  users: [GalleryUser!]
}

union TrendingUsersPayloadOrError = TrendingUsersPayload

type UserSearchResult {
  user: GalleryUser
}

type SearchUsersPayload {
  results: [UserSearchResult!]
}

union SearchUsersPayloadOrError = SearchUsersPayload | ErrInvalidInput

type GallerySearchResult {
  gallery: Gallery
}

type SearchGalleriesPayload {
  results: [GallerySearchResult!]
}

union SearchGalleriesPayloadOrError = SearchGalleriesPayload | ErrInvalidInput

type CommunitySearchResult {
  community: Community
}

type SearchCommunitiesPayload {
  results: [CommunitySearchResult!]
}

union SearchCommunitiesPayloadOrError = SearchCommunitiesPayload | ErrInvalidInput

union SocialQueriesOrError = SocialQueries | ErrNotAuthorized | ErrNeedsToReconnectSocial

input ChainAddressTokenInput {
  chainAddress: ChainAddressInput!
  """
  Refers to the id of the token in the contract either in decimal, or interpreted as hexadecimal when prefixed with '0x'
  """
  tokenId: TokenId!
}

input PostComposerDraftDetailsInput {
  token: ChainAddressTokenInput!
}

type PostComposerDraftDetailsPayload @goEmbedHelper {
  media(darkMode: DarkMode): MediaSubtype @goField(forceResolver: true)
  community: Community @goField(forceResolver: true)
  tokenName: String
  tokenDescription: String
}

union PostComposerDraftDetailsPayloadOrError =
    PostComposerDraftDetailsPayload
  | ErrInvalidInput
  | ErrCommunityNotFound

type Query {
  node(id: ID!): Node
  viewer: ViewerOrError @authRequired
  userByUsername(username: String!): UserByUsernameOrError
  userById(id: DBID!): UserByIdOrError
  userByAddress(chainAddress: ChainAddressInput!): UserByAddressOrError
  usersByAddresses(chainAddresses: [ChainAddressInput!]!): UsersByAddressesPayloadOrError
  usersWithTrait(trait: String!): [GalleryUser]
  membershipTiers(forceRefresh: Boolean): [MembershipTier]
  collectionById(id: DBID!): CollectionByIdOrError
  collectionsByIds(ids: [DBID!]!): [CollectionByIdOrError]
  tokenById(id: DBID!): TokenByIdOrError
  collectionTokenById(tokenId: DBID!, collectionId: DBID!): CollectionTokenByIdOrError
  communityByAddress(
    communityAddress: ChainAddressInput!
    forceRefresh: Boolean
  ): CommunityByAddressOrError
  communityById(id: DBID!): CommunityByIdOrError
  generalAllowlist: [ChainAddress!]
  galleryOfTheWeekWinners: [GalleryUser!]
  globalFeed(
    before: String
    after: String
    first: Int
    last: Int
    includePosts: Boolean! = false @deprecated(reason: "Posts are always included now.")
  ): FeedConnection
  # Paging forward i.e. providing the `first` argument will return events in order of descending popularity.
  trendingFeed(
    before: String
    after: String
    first: Int
    last: Int
    includePosts: Boolean! = false @deprecated(reason: "Posts are always included now.")
  ): FeedConnection
  curatedFeed(
    before: String
    after: String
    first: Int
    last: Int
    includePosts: Boolean! = false @deprecated(reason: "Posts are always included now.")
  ): FeedConnection
  feedEventById(id: DBID!): FeedEventByIdOrError
  postById(id: DBID!): PostOrError
  getMerchTokens(wallet: Address!): MerchTokensPayloadOrError
  galleryById(id: DBID!): GalleryByIdPayloadOrError
  viewerGalleryById(id: DBID!): ViewerGalleryByIdPayloadOrError
  trendingUsers(input: TrendingUsersInput!): TrendingUsersPayloadOrError
  """
  Search for users with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. usernameWeight defaults to 0.4 and
  bioWeight defaults to 0.2, meaning that a search result matching a username is considered
  twice as relevant as a search result matching a bio.
  """
  searchUsers(
    query: String!
    limit: Int
    usernameWeight: Float
    bioWeight: Float
  ): SearchUsersPayloadOrError
  """
  Search for galleries with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. nameWeight defaults to 0.4 and
  descriptionWeight defaults to 0.2, meaning that a search result matching a gallery name is
  considered twice as relevant as a search result matching a gallery description.
  """
  searchGalleries(
    query: String!
    limit: Int
    nameWeight: Float
    descriptionWeight: Float
  ): SearchGalleriesPayloadOrError
  """
  Search for communities with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. nameWeight defaults to 0.4, providerNameWeight
  defaults to 0.3, descriptionWeight defaults to 0.2, and poapAddressWeight defaults to 0.1,
  meaning that a search result matching a community name is considered twice as relevant as a
  search result matching a community description, and four times as relevant as a search result
  matching a POAP address string. providerNameWeight is used to return communities provided by
  a provider (e.g. Art Blocks) when searching for that provider's name (e.g. "art blocks").
  """
  searchCommunities(
    query: String!
    limit: Int
    nameWeight: Float
    descriptionWeight: Float
    poapAddressWeight: Float
    providerNameWeight: Float
  ): SearchCommunitiesPayloadOrError

  isEmailAddressAvailable(emailAddress: Email!): Boolean

  # Retool Specific
  usersByRole(role: Role!, before: String, after: String, first: Int, last: Int): UsersConnection
    @basicAuth(allowed: [Retool])

  socialConnections(
    socialAccountType: SocialAccountType!
    excludeAlreadyFollowing: Boolean
    before: String
    after: String
    first: Int
    last: Int
  ): SocialConnectionsConnection @goField(forceResolver: true) @authRequired

  socialQueries: SocialQueriesOrError @authRequired
  topCollectionsForCommunity(
    input: topCollectionsForCommunityInput!
    before: String
    after: String
    first: Int
    last: Int
  ): CollectionsConnection
  postComposerDraftDetails(
    input: PostComposerDraftDetailsInput!
  ): PostComposerDraftDetailsPayloadOrError
  # Community lookups
  contractCommunityByKey(key: ContractCommunityKeyInput!): CommunityByKeyOrError
  artBlocksCommunityByKey(key: ArtBlocksCommunityKeyInput!): CommunityByKeyOrError
  highlightMintClaimStatus(claimId: DBID!): HighlightMintClaimStatusPayloadOrError
    @authRequired
    @goField(forceResolver: true)
}

type SocialQueries {
  socialConnections(
    socialAccountType: SocialAccountType!
    excludeAlreadyFollowing: Boolean
    before: String
    after: String
    first: Int
    last: Int
  ): SocialConnectionsConnection @goField(forceResolver: true) @authRequired
}

input topCollectionsForCommunityInput {
  chainAddress: ChainAddressInput!
}

input CollectionLayoutInput {
  sections: [Int!]!
  sectionLayout: [CollectionSectionLayoutInput!]!
}

input CollectionSectionLayoutInput {
  columns: Int!
  whitespace: [Int!]!
}

input CollectionTokenSettingsInput {
  tokenId: DBID!
  renderLive: Boolean!
  highDefinition: Boolean!
}

input CreateCollectionInput {
  galleryId: DBID!
  name: String!
  collectorsNote: String!
  tokens: [DBID!]!
  layout: CollectionLayoutInput!
  tokenSettings: [CollectionTokenSettingsInput!]!
  caption: String
}

union CreateCollectionPayloadOrError = CreateCollectionPayload | ErrNotAuthorized | ErrInvalidInput

type CreateCollectionPayload {
  collection: Collection
  feedEvent: FeedEvent @goField(forceResolver: true)
}

union DeleteCollectionPayloadOrError =
    DeleteCollectionPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrCollectionNotFound

type DeleteCollectionPayload {
  gallery: Gallery
}

input UpdateCollectionInfoInput {
  collectionId: DBID!
  name: String!
  collectorsNote: String!
}

union UpdateCollectionInfoPayloadOrError =
    UpdateCollectionInfoPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateCollectionInfoPayload {
  collection: Collection
}

input UpdateCollectionTokensInput {
  collectionId: DBID!
  tokens: [DBID!]!
  layout: CollectionLayoutInput!
  tokenSettings: [CollectionTokenSettingsInput!]!
  caption: String
}

union UpdateCollectionTokensPayloadOrError =
    UpdateCollectionTokensPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateCollectionTokensPayload {
  collection: Collection
  feedEvent: FeedEvent @goField(forceResolver: true)
}

input UpdateCollectionHiddenInput {
  collectionId: DBID!
  hidden: Boolean!
}

union UpdateCollectionHiddenPayloadOrError =
    UpdateCollectionHiddenPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateCollectionHiddenPayload {
  collection: Collection
}

input UpdateGalleryCollectionsInput {
  galleryId: DBID!
  collections: [DBID!]!
}

union UpdateGalleryCollectionsPayloadOrError =
    UpdateGalleryCollectionsPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateGalleryCollectionsPayload {
  gallery: Gallery
}

input UpdateTokenInfoInput {
  tokenId: DBID!
  collectorsNote: String!

  # Optional (for now). Lets the backend know what collection the token was being edited in.
  # Currently used to generate feedbot URLs.
  collectionId: DBID
}

union UpdateTokenInfoPayloadOrError = UpdateTokenInfoPayload | ErrNotAuthorized | ErrInvalidInput

type UpdateTokenInfoPayload {
  token: Token
}

input SetSpamPreferenceInput {
  tokens: [DBID!]!
  isSpam: Boolean!
}

type SetSpamPreferencePayload {
  tokens: [Token] @goField(forceResolver: true)
}

union SetSpamPreferencePayloadOrError = SetSpamPreferencePayload | ErrNotAuthorized

union AddUserWalletPayloadOrError =
    AddUserWalletPayload
  | ErrAuthenticationFailed
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrAddressOwnedByUser

type AddUserWalletPayload {
  viewer: Viewer
}

union RemoveUserWalletsPayloadOrError =
    RemoveUserWalletsPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type RemoveUserWalletsPayload {
  viewer: Viewer
}

input UpdateUserInfoInput {
  username: String!
  bio: String!
}

union UpdateUserInfoPayloadOrError =
    UpdateUserInfoPayload
  | ErrNotAuthorized
  | ErrUsernameNotAvailable
  | ErrInvalidInput

type UpdateUserInfoPayload {
  viewer: Viewer
}

union RegisterUserPushTokenPayloadOrError =
    RegisterUserPushTokenPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrPushTokenBelongsToAnotherUser

type RegisterUserPushTokenPayload {
  viewer: Viewer
}

union UnregisterUserPushTokenPayloadOrError =
    UnregisterUserPushTokenPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrPushTokenBelongsToAnotherUser

type UnregisterUserPushTokenPayload {
  viewer: Viewer
}

union SyncTokensPayloadOrError = SyncTokensPayload | ErrNotAuthorized | ErrSyncFailed

type SyncTokensPayload {
  viewer: Viewer
}

union SyncCreatedTokensForNewContractsPayloadOrError =
    SyncCreatedTokensForNewContractsPayload
  | ErrNotAuthorized
  | ErrSyncFailed

type SyncCreatedTokensForNewContractsPayload {
  viewer: Viewer
}

union SyncCreatedTokensForExistingContractPayloadOrError =
    SyncCreatedTokensForExistingContractPayload
  | ErrNotAuthorized
  | ErrSyncFailed

type SyncCreatedTokensForExistingContractPayload {
  viewer: Viewer
}

union RefreshTokenPayloadOrError =
    RefreshTokenPayload
  | ErrInvalidInput
  | ErrSyncFailed
  | ErrTokenNotFound

type RefreshTokenPayload {
  token: Token
}

union RefreshCollectionPayloadOrError = RefreshCollectionPayload | ErrInvalidInput | ErrSyncFailed

type RefreshCollectionPayload {
  collection: Collection
}

union RefreshContractPayloadOrError = RefreshContractPayload | ErrInvalidInput | ErrSyncFailed

type RefreshContractPayload {
  contract: Contract
}

type AuthNonce {
  nonce: String
  message: String
}

union GetAuthNoncePayloadOrError = AuthNonce

type ErrAuthenticationFailed implements Error {
  message: String!
}

type ErrEmailUnverified implements Error {
  message: String!
}

type ErrEmailAlreadyUsed implements Error {
  message: String!
}

type ErrUserAlreadyExists implements Error {
  message: String!
}

type ErrUsernameNotAvailable implements Error {
  message: String!
}

type ErrAddressOwnedByUser implements Error {
  message: String!
}

type ErrAddressNotOwnedByUser implements Error {
  message: String!
}

type ErrUserNotFound implements Error {
  message: String!
}

type ErrCommunityNotFound implements Error {
  message: String!
}

union AuthorizationError =
    ErrNoCookie
  | ErrInvalidToken
  | ErrSessionInvalidated
  | ErrDoesNotOwnRequiredToken

type ErrNotAuthorized implements Error {
  message: String!
  cause: AuthorizationError!
}

type ErrInvalidInput implements Error {
  message: String!
  parameters: [String!]!
  reasons: [String!]!
}

type ErrNoCookie implements Error {
  message: String!
}

type ErrInvalidToken implements Error {
  message: String!
}

type ErrSessionInvalidated implements Error {
  message: String!
}

type ErrNeedsToReconnectSocial implements Error {
  socialAccountType: SocialAccountType!
  message: String!
}

type ErrDoesNotOwnRequiredToken implements Error {
  message: String!
}

type ErrSyncFailed implements Error {
  message: String!
}

type ErrAdmireNotFound implements Error {
  message: String!
}

type ErrAdmireAlreadyExists implements Error {
  message: String!
}

type ErrCommentNotFound implements Error {
  message: String!
}

type ErrPushTokenBelongsToAnotherUser implements Error {
  message: String!
}

input AuthMechanism {
  eoa: EoaAuth
  gnosisSafe: GnosisSafeAuth
  debug: DebugAuth
  magicLink: MagicLinkAuth
  oneTimeLoginToken: OneTimeLoginTokenAuth
  privy: PrivyAuth
  neynar: NeynarAuth
}

input EoaAuth {
  chainPubKey: ChainPubKeyInput!
  nonce: String!
  message: String!
  signature: String! @scrub
}

# DebugAuth is a debug-only authentication mechanism for testing and debugging.
# It creates an authenticator that will return the supplied userId and chainAddresses as if they had been
# successfully authenticated. For existing users, the asUsername parameter may be supplied as a convenience
# method to look up and return their userId and chainAddresses.
input DebugAuth @restrictEnvironment(allowed: ["local", "development", "sandbox"]) {
  # Convenience method to authenticate as an existing user.
  # Cannot be used in conjunction with the userId and chainAddresses parameters.
  asUsername: String

  # The userId that will be returned from the resulting authenticator.
  # May be omitted or blank to indicate that there is no user associated with the supplied chainAddresses.
  # Cannot be used in conjunction with the asUsername parameter.
  userId: DBID

  # The chainAddresses that will be returned from the resulting authenticator.
  # Cannot be used in conjunction with the asUsername parameter.
  chainAddresses: [ChainAddressInput!]

  # A password required to use debug tools. Typically empty in local environments.
  debugToolsPassword: String
}

input GnosisSafeAuth {
  address: Address!
  nonce: String!
  message: String!
}

input MagicLinkAuth {
  token: String!
}

input OneTimeLoginTokenAuth {
  token: String!
}

input PrivyAuth {
  token: String!
}

input NeynarAuth {
  custodyPubKey: ChainPubKeyInput!
  nonce: String!
  message: String!
  signature: String! @scrub

  """
  primaryPubKey is an optional parameter that lets callers specify a different wallet to use with Gallery, provided
  that both primaryPubKey and the required custodyPubKey are owned by the same Neynar user
  """
  primaryPubKey: ChainPubKeyInput
}

input SocialAuthMechanism {
  twitter: TwitterAuth
  debug: DebugSocialAuth
  farcaster: FarcasterAuth
  lens: LensAuth
}

input TwitterAuth {
  code: String!
}

input FarcasterAuth {
  address: Address!
  """
  withSigner will make a request to authenticate the user with an on chain transaction that can be approved on their warpcast app.
  the `FarcasterSocialAccount` type will return an `approvalURL` that will link the user to make the on chain transaction.
  """
  withSigner: Boolean
  # farcaster only supports ETH addresses currently so no need to specify a chain
}

input LensAuth {
  address: Address!
  """
  signature is the signed challenge provided by a GQL request to the lens endpoint
  """
  signature: String @scrub
  # lens only supports ETH addresses currently so no need to specify a chain
}

input DebugSocialAuth @restrictEnvironment(allowed: ["local", "development", "sandbox"]) {
  provider: SocialAccountType!
  id: String!
  username: String!

  # A password required to use debug tools. Typically empty in local environments.
  debugToolsPassword: String
}

union LoginPayloadOrError =
    LoginPayload
  | ErrUserNotFound
  | ErrAuthenticationFailed
  | ErrEmailUnverified
  | ErrDoesNotOwnRequiredToken

type LoginPayload {
  # TODO: Remove userId in favor of viewer
  userId: DBID
  viewer: Viewer
}

type LogoutPayload {
  viewer: Viewer
}

enum ImportWalletSource {
  Farcaster
}

input CreateUserInput {
  username: String!
  bio: String
  email: Email @scrub
  galleryName: String
  galleryDescription: String
  galleryPosition: String
  importWallets: [ImportWalletSource!]
}

union CreateUserPayloadOrError =
    CreateUserPayload
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredToken
  | ErrUserAlreadyExists
  | ErrUsernameNotAvailable
  | ErrInvalidInput
  | ErrEmailAlreadyUsed

type CreateUserPayload {
  userId: DBID
  galleryId: DBID
  # TODO: Remove userId and galleryId in favor of viewer
  viewer: Viewer
}

union FollowUserPayloadOrError =
    FollowUserPayload
  | ErrAuthenticationFailed
  | ErrUserNotFound
  | ErrInvalidInput

union UnfollowUserPayloadOrError =
    UnfollowUserPayload
  | ErrAuthenticationFailed
  | ErrUserNotFound
  | ErrInvalidInput

type FollowUserPayload {
  viewer: Viewer
  user: GalleryUser @goField(forceResolver: true)
}

type UnfollowUserPayload {
  viewer: Viewer
  user: GalleryUser @goField(forceResolver: true)
}

union AdmireFeedEventPayloadOrError =
    AdmireFeedEventPayload
  | ErrAuthenticationFailed
  | ErrFeedEventNotFound
  | ErrInvalidInput
  | ErrAdmireAlreadyExists

union RemoveAdmirePayloadOrError =
    RemoveAdmirePayload
  | ErrAuthenticationFailed
  | ErrFeedEventNotFound
  | ErrInvalidInput
  | ErrAdmireNotFound

union CommentOnFeedEventPayloadOrError =
    CommentOnFeedEventPayload
  | ErrAuthenticationFailed
  | ErrFeedEventNotFound
  | ErrInvalidInput

union RemoveCommentPayloadOrError =
    RemoveCommentPayload
  | ErrAuthenticationFailed
  | ErrFeedEventNotFound
  | ErrInvalidInput
  | ErrCommentNotFound

type AdmireFeedEventPayload {
  viewer: Viewer
  admire: Admire @goField(forceResolver: true)
  feedEvent: FeedEvent @goField(forceResolver: true)
}

type RemoveAdmirePayload {
  viewer: Viewer
  admireID: DBID
  feedEvent: FeedEvent @goField(forceResolver: true)
  post: Post @goField(forceResolver: true)
}

type CommentOnFeedEventPayload {
  viewer: Viewer
  comment: Comment @goField(forceResolver: true)
  replyToComment: Comment @goField(forceResolver: true)
  feedEvent: FeedEvent @goField(forceResolver: true)
}

type RemoveCommentPayload {
  viewer: Viewer
  feedEvent: FeedEvent @goField(forceResolver: true)
  post: Post @goField(forceResolver: true)
}

interface Notification implements Node {
  id: ID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
}

interface GroupedNotification implements Notification & Node {
  id: ID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  count: Int
}

type GroupNotificationUserEdge {
  node: GalleryUser
  cursor: String
}

type GroupNotificationUsersConnection {
  edges: [GroupNotificationUserEdge]
  pageInfo: PageInfo
}

type SomeoneFollowedYouNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  followers(before: String, after: String, first: Int, last: Int): GroupNotificationUsersConnection
    @goField(forceResolver: true)
}

type SomeoneFollowedYouBackNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  followers(before: String, after: String, first: Int, last: Int): GroupNotificationUsersConnection
    @goField(forceResolver: true)
}

type SomeoneAdmiredYourFeedEventNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  feedEvent: FeedEvent @goField(forceResolver: true)
  admirers(before: String, after: String, first: Int, last: Int): GroupNotificationUsersConnection
    @goField(forceResolver: true)
}

type SomeoneCommentedOnYourFeedEventNotification implements Notification & Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  # Don't need a `who` here since the `comment` can provide that
  # Do we want this comment to be the latest comment
  comment: Comment @goField(forceResolver: true)
  feedEvent: FeedEvent @goField(forceResolver: true)
}

type SomeoneAdmiredYourPostNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  post: Post @goField(forceResolver: true)
  admirers(before: String, after: String, first: Int, last: Int): GroupNotificationUsersConnection
    @goField(forceResolver: true)
}

type SomeoneAdmiredYourTokenNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  token: Token @goField(forceResolver: true)
  admirers(before: String, after: String, first: Int, last: Int): GroupNotificationUsersConnection
    @goField(forceResolver: true)
}

type SomeoneAdmiredYourCommentNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  comment: Comment @goField(forceResolver: true)
  admirers(before: String, after: String, first: Int, last: Int): GroupNotificationUsersConnection
    @goField(forceResolver: true)
}

type SomeoneCommentedOnYourPostNotification implements Notification & Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  # Don't need a `who` here since the `comment` can provide that
  # Do we want this comment to be the latest comment
  comment: Comment @goField(forceResolver: true)
  post: Post @goField(forceResolver: true)
}

type SomeoneViewedYourGalleryNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  # the total count of notifications grouped, despite uniqueness of the viewers and whether they are logged in or not
  count: Int

  # unique user viewers, use PageInfo.Total to get the total unique user viewers
  userViewers(
    before: String
    after: String
    first: Int
    last: Int
  ): GroupNotificationUsersConnection @goField(forceResolver: true)

  # count of unique non-user viewers
  nonUserViewerCount: Int
  gallery: Gallery @goField(forceResolver: true)
}

type NewTokensNotification implements Notification & GroupedNotification & Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  token: Token @goField(forceResolver: true)
}

type SomeoneRepliedToYourCommentNotification implements Notification & Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  # Don't need a `who` here since the `comment` can provide that
  comment: Comment @goField(forceResolver: true)
  originalComment: Comment @goField(forceResolver: true)
}

union MentionSource = Comment | Post

type SomeoneMentionedYouNotification implements Notification & Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  # Don't need a `who` here since the `comment` or `post` can provide that
  mentionSource: MentionSource @goField(forceResolver: true)
}

type SomeoneMentionedYourCommunityNotification implements Notification & Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  # Don't need a `who` here since the `comment` or `post` can provide that
  mentionSource: MentionSource @goField(forceResolver: true)
  community: Community @goField(forceResolver: true)
}

type SomeonePostedYourWorkNotification implements Notification & Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  post: Post @goField(forceResolver: true)
  community: Community @goField(forceResolver: true)
}

type SomeoneYouFollowPostedTheirFirstPostNotification implements Notification & Node
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  post: Post @goField(forceResolver: true)
}

type SomeoneYouFollowOnFarcasterJoinedNotification implements Notification & Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  user: GalleryUser @goField(forceResolver: true)
}

type YouReceivedTopActivityBadgeNotification implements Notification & Node {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  threshold: Int!
}

enum Platform {
  Web
  Mobile
  All
}

enum DarkMode {
  Disabled
  Enabled
}

type GalleryAnnouncementNotification implements Notification & Node {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  platform: Platform!
  internalId: String!
  imageUrl: String
  title: String
  description: String
  ctaText: String
  ctaLink: String
  pushNotificationText: String
}

type ClearAllNotificationsPayload {
  notifications: [Notification]
}

type ViewGalleryPayload {
  gallery: Gallery
}

union ViewGalleryPayloadOrError = ViewGalleryPayload | ErrAuthenticationFailed

type ViewTokenPayload {
  token: Token
}

union ViewTokenPayloadOrError =
    ViewTokenPayload
  | ErrAuthenticationFailed
  | ErrTokenNotFound
  | ErrCollectionNotFound

input VerifyEmailInput {
  token: String! @scrub
}

type VerifyEmailPayload {
  email: Email!
}

union VerifyEmailPayloadOrError = VerifyEmailPayload | ErrInvalidInput

input PreverifyEmailInput {
  email: Email! @scrub
}

enum PreverifyEmailResult {
  Invalid
  Risky
  Valid
}

type PreverifyEmailPayload {
  email: Email!
  result: PreverifyEmailResult!
}

union PreverifyEmailPayloadOrError = PreverifyEmailPayload | ErrInvalidInput

input VerifyEmailMagicLinkInput {
  email: Email! @scrub
}

type VerifyEmailMagicLinkPayload {
  canSend: Boolean!
}

union VerifyEmailMagicLinkPayloadOrError = VerifyEmailMagicLinkPayload | ErrInvalidInput

input UpdateEmailInput {
  email: Email! @scrub
  """
  authMechanism is an optional parameter that can verify a user's email address in lieu of sending
  a verification email to the user. If not provided, a verification email will be sent.
  """
  authMechanism: AuthMechanism
}

type UpdateEmailPayload {
  viewer: Viewer
}

union UpdateEmailPayloadOrError = UpdateEmailPayload | ErrInvalidInput

type ResendVerificationEmailPayload {
  viewer: Viewer
}

union ResendVerificationEmailPayloadOrError = ResendVerificationEmailPayload | ErrInvalidInput

type UpdateEmailNotificationSettingsPayload {
  viewer: Viewer
}

union UpdateEmailNotificationSettingsPayloadOrError =
    UpdateEmailNotificationSettingsPayload
  | ErrInvalidInput

type UnsubscribeFromEmailTypePayload {
  viewer: Viewer
}

union UnsubscribeFromEmailTypePayloadOrError = UnsubscribeFromEmailTypePayload | ErrInvalidInput

union AddRolesToUserPayloadOrError = GalleryUser | ErrNotAuthorized
union RevokeRolesFromUserPayloadOrError = GalleryUser | ErrNotAuthorized

type OptInForRolesPayload {
  user: GalleryUser
}

type OptOutForRolesPayload {
  user: GalleryUser
}

union OptInForRolesPayloadOrError = OptInForRolesPayload | ErrNotAuthorized | ErrInvalidInput
union OptOutForRolesPayloadOrError = OptOutForRolesPayload | ErrNotAuthorized | ErrInvalidInput

type SetPersonaPayload {
  viewer: Viewer
}

union SetPersonaPayloadOrError = SetPersonaPayload | ErrNotAuthorized | ErrInvalidInput

input UploadPersistedQueriesInput {
  persistedQueries: String
}

union UploadPersistedQueriesPayloadOrError = UploadPersistedQueriesPayload | ErrNotAuthorized

type UploadPersistedQueriesPayload {
  message: String
}

input RedeemMerchInput {
  tokenIds: [String!]!
  address: ChainAddressInput!
  walletType: WalletType!
  signature: String!
}

type MerchDiscountCode {
  code: String!
  tokenId: String
}

type RedeemMerchPayload {
  tokens: [MerchToken]
}

union RedeemMerchPayloadOrError = RedeemMerchPayload | ErrInvalidInput

type SyncTokensForUsernamePayload {
  message: String!
}

union SyncTokensForUsernamePayloadOrError =
    SyncTokensForUsernamePayload
  | ErrNotAuthorized
  | ErrSyncFailed

type SyncCreatedTokensForUsernamePayload {
  message: String!
}

union SyncCreatedTokensForUsernamePayloadOrError =
    SyncCreatedTokensForUsernamePayload
  | ErrNotAuthorized
  | ErrSyncFailed

type SyncCreatedTokensForUsernameAndExistingContractPayload {
  message: String!
}

union SyncCreatedTokensForUsernameAndExistingContractPayloadOrError =
    SyncCreatedTokensForUsernameAndExistingContractPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrSyncFailed
  | ErrCommunityNotFound

type BanUserFromFeedPayload {
  user: GalleryUser
}

union BanUserFromFeedPayloadOrError = BanUserFromFeedPayload | ErrNotAuthorized

type UnbanUserFromFeedPayload {
  user: GalleryUser
}

union UnbanUserFromFeedPayloadOrError = UnbanUserFromFeedPayload | ErrNotAuthorized

type SetCommunityOverrideCreatorPayload {
  user: GalleryUser
}

union SetCommunityOverrideCreatorPayloadOrError =
    SetCommunityOverrideCreatorPayload
  | ErrNotAuthorized

input GalleryPositionInput {
  galleryId: DBID!
  position: String!
}

input UpdateGalleryOrderInput {
  positions: [GalleryPositionInput!]!
}

input UpdateGalleryHiddenInput {
  id: DBID!
  hidden: Boolean!
}

input UpdateGalleryInfoInput {
  id: DBID!
  name: String
  description: String
}

input CreateGalleryInput {
  name: String
  description: String
  position: String!
}

type CreateGalleryPayload {
  gallery: Gallery
}

union CreateGalleryPayloadOrError = CreateGalleryPayload | ErrInvalidInput | ErrNotAuthorized

type UpdateGalleryInfoPayload {
  gallery: Gallery
}

union UpdateGalleryInfoPayloadOrError =
    UpdateGalleryInfoPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type UpdateGalleryHiddenPayload {
  gallery: Gallery
}

union UpdateGalleryHiddenPayloadOrError =
    UpdateGalleryHiddenPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type DeleteGalleryPayload {
  deletedId: DeletedNode
}

union DeleteGalleryPayloadOrError = DeleteGalleryPayload | ErrInvalidInput | ErrNotAuthorized

type UpdateGalleryOrderPayload {
  viewer: Viewer
}

union UpdateGalleryOrderPayloadOrError =
    UpdateGalleryOrderPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type UpdateFeaturedGalleryPayload {
  viewer: Viewer
}

union UpdateFeaturedGalleryPayloadOrError =
    UpdateFeaturedGalleryPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input UpdateCollectionInput {
  dbid: DBID!
  name: String!
  collectorsNote: String!
  tokens: [DBID!]!
  layout: CollectionLayoutInput!
  tokenSettings: [CollectionTokenSettingsInput!]!
  hidden: Boolean!
}

input CreateCollectionInGalleryInput {
  name: String!
  collectorsNote: String!
  tokens: [DBID!]!
  layout: CollectionLayoutInput!
  tokenSettings: [CollectionTokenSettingsInput!]!
  hidden: Boolean!
  givenID: DBID!
}

input UpdateGalleryInput {
  galleryId: DBID!

  name: String
  description: String

  # leaving caption around for a bit for backwards compatibility
  caption: String

  deletedCollections: [DBID!]

  updatedCollections: [UpdateCollectionInput]
  createdCollections: [CreateCollectionInGalleryInput]

  order: [DBID!]

  # generated on the frontend
  # will be String! in the future, not required for temp backwards compatibility
  editId: String
}

type UpdateGalleryPayload {
  gallery: Gallery
}

union UpdateGalleryPayloadOrError = UpdateGalleryPayload | ErrInvalidInput | ErrNotAuthorized

input PublishGalleryInput {
  galleryId: DBID!
  editId: String!
  caption: String
}

type PublishGalleryPayload {
  gallery: Gallery
}

union PublishGalleryPayloadOrError = PublishGalleryPayload | ErrInvalidInput | ErrNotAuthorized

type UpdatePrimaryWalletPayload {
  viewer: Viewer
}

union UpdatePrimaryWalletPayloadOrError =
    UpdatePrimaryWalletPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input AdminAddWalletInput {
  username: String!
  chainAddress: ChainAddressInput!
  walletType: WalletType!
}

type AdminAddWalletPayload {
  user: GalleryUser
}

union AdminAddWalletPayloadOrError =
    AdminAddWalletPayload
  | ErrUserNotFound
  | ErrAddressOwnedByUser
  | ErrNotAuthorized

input UpdateUserExperienceInput {
  experienceType: UserExperienceType!
  experienced: Boolean!
}

type UpdateUserExperiencePayload {
  viewer: Viewer
}

union UpdateUserExperiencePayloadOrError =
    UpdateUserExperiencePayload
  | ErrInvalidInput
  | ErrNotAuthorized

input MoveCollectionToGalleryInput {
  sourceCollectionId: DBID!
  targetGalleryId: DBID!
}

type MoveCollectionToGalleryPayload {
  oldGallery: Gallery
  newGallery: Gallery
}

union MoveCollectionToGalleryPayloadOrError =
    MoveCollectionToGalleryPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type ConnectSocialAccountPayload {
  viewer: Viewer
}

union ConnectSocialAccountPayloadOrError =
    ConnectSocialAccountPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input UpdateSocialAccountDisplayedInput {
  type: SocialAccountType!
  displayed: Boolean!
}

type UpdateSocialAccountDisplayedPayload {
  viewer: Viewer
}

union UpdateSocialAccountDisplayedPayloadOrError =
    UpdateSocialAccountDisplayedPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrNeedsToReconnectSocial

input MintPremiumCardToWalletInput {
  tokenId: String!
  walletAddresses: [Address!]
}

type MintPremiumCardToWalletPayload {
  tx: String!
}

union MintPremiumCardToWalletPayloadOrError =
    MintPremiumCardToWalletPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrNeedsToReconnectSocial

type DisconnectSocialAccountPayload {
  viewer: Viewer
}

union DisconnectSocialAccountPayloadOrError =
    DisconnectSocialAccountPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrNeedsToReconnectSocial

type FollowAllSocialConnectionsPayload {
  viewer: Viewer
}

union FollowAllSocialConnectionsPayloadOrError =
    FollowAllSocialConnectionsPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrNeedsToReconnectSocial

type FollowAllOnboardingRecommendationsPayload {
  viewer: Viewer
}

union FollowAllOnboardingRecommendationsPayloadOrError =
    FollowAllOnboardingRecommendationsPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type GenerateQRCodeLoginTokenPayload {
  token: String!
}

union GenerateQRCodeLoginTokenPayloadOrError = GenerateQRCodeLoginTokenPayload | ErrNotAuthorized

input SetProfileImageInput {
  # Only one of the following fields should be provided
  tokenId: DBID
  walletAddress: ChainAddressInput
}

type SetProfileImagePayload {
  viewer: Viewer
}

type RemoveProfileImagePayload {
  viewer: Viewer
}

type ErrNoAvatarRecordSet implements Error {
  message: String!
}

union SetProfileImagePayloadOrError =
    SetProfileImagePayload
  | ErrAuthenticationFailed
  | ErrUserNotFound
  | ErrInvalidInput
  | ErrTokenNotFound
  | ErrNotAuthorized
  | ErrNoAvatarRecordSet

union RemoveProfileImagePayloadOrError =
    RemoveProfileImagePayload
  | ErrAuthenticationFailed
  | ErrUserNotFound

input PostTokensInput {
  tokenIds: [DBID!]
  caption: String
  mentions: [MentionInput!]
  mintURL: String
}

type PostTokensPayload {
  post: Post!
}

union PostTokensPayloadOrError = PostTokensPayload | ErrInvalidInput | ErrNotAuthorized

input ReferralPostTokenInput {
  token: ChainAddressTokenInput!
  caption: String
  mintURL: String
}

type ReferralPostTokenPayload {
  post: Post!
}

union ReferralPostTokenPayloadOrError =
    ReferralPostTokenPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrTokenNotFound

type AdmirePostPayload {
  viewer: Viewer
  post: Post @goField(forceResolver: true)
  admire: Admire @goField(forceResolver: true)
}

union AdmirePostPayloadOrError =
    AdmirePostPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrPostNotFound

type AdmireTokenPayload {
  viewer: Viewer
  token: Token @goField(forceResolver: true)
  admire: Admire @goField(forceResolver: true)
}

union AdmireTokenPayloadOrError =
    AdmireTokenPayload
  | ErrTokenNotFound
  | ErrInvalidInput
  | ErrNotAuthorized

union AdmireCommentPayloadOrError =
    AdmireCommentPayload
  | ErrCommentNotFound
  | ErrInvalidInput
  | ErrNotAuthorized

type AdmireCommentPayload {
  viewer: Viewer
  comment: Comment @goField(forceResolver: true)
  admire: Admire @goField(forceResolver: true)
}

type CommentOnPostPayload {
  viewer: Viewer
  post: Post @goField(forceResolver: true)
  comment: Comment @goField(forceResolver: true)
  replyToComment: Comment @goField(forceResolver: true)
}

union CommentOnPostPayloadOrError = CommentOnPostPayload | ErrInvalidInput | ErrNotAuthorized

type DeletePostPayload {
  deletedId: DeletedNode
}

union DeletePostPayloadOrError = DeletePostPayload | ErrInvalidInput | ErrNotAuthorized

input MentionInput {
  interval: IntervalInput
  userId: DBID
  communityId: DBID
}

input IntervalInput {
  start: Int!
  length: Int!
}

input ReferralPostPreflightInput {
  token: ChainAddressTokenInput!
}

type ReferralPostPreflightPayload {
  accepted: Boolean!
}

union ReferralPostPreflightPayloadOrError = ReferralPostPreflightPayload | ErrInvalidInput

type ReportPostPayload {
  postId: DBID!
}

union ReportPostPayloadOrError = ReportPostPayload | ErrInvalidInput | ErrPostNotFound

enum ReportReason {
  INAPPROPRIATE_CONTENT
  SPAM_AND_OR_BOT
  SOMETHING_ELSE
}

type BlockUserPayload {
  userId: DBID!
}

union BlockUserPayloadOrError =
    BlockUserPayload
  | ErrUserNotFound
  | ErrNotAuthorized
  | ErrInvalidInput

type UnblockUserPayload {
  userId: DBID!
}

union UnblockUserPayloadOrError =
    UnblockUserPayload
  | ErrUserNotFound
  | ErrNotAuthorized
  | ErrInvalidInput

input HighlightClaimMintInput {
  collectionId: String!
  recipientWalletId: DBID!
}

type HighlightClaimMintPayload {
  claimId: DBID!
}

type ErrHighlightTxnFailed implements Error {
  message: String!
}

type ErrHighlightMintUnavailable implements Error {
  message: String!
}

type ErrHighlightChainNotSupported implements Error {
  message: String!
}

type ErrHighlightClaimInProgress implements Error {
  message: String!
}

type ErrHighlightClaimAlreadyMinted implements Error {
  message: String!
}

union HighlightClaimMintPayloadOrError =
    HighlightClaimMintPayload
  | ErrHighlightTxnFailed
  | ErrHighlightMintUnavailable
  | ErrHighlightChainNotSupported
  | ErrAddressNotOwnedByUser
  | ErrHighlightClaimInProgress
  | ErrHighlightClaimAlreadyMinted
  | ErrNotAuthorized

enum HighlightTxStatus {
  TX_PENDING
  TX_COMPLETE
  TOKEN_SYNCED
}

type HighlightMintClaimStatusPayload @goEmbedHelper {
  status: HighlightTxStatus!
  token: Token @goField(forceResolver: true)
}

union HighlightMintClaimStatusPayloadOrError =
    HighlightMintClaimStatusPayload
  | ErrHighlightTxnFailed
  | ErrHighlightMintUnavailable
  | ErrNotAuthorized

type Mutation {
  # User Mutations
  addUserWallet(
    chainAddress: ChainAddressInput!
    authMechanism: AuthMechanism!
  ): AddUserWalletPayloadOrError @authRequired
  removeUserWallets(walletIds: [DBID!]!): RemoveUserWalletsPayloadOrError @authRequired
  updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayloadOrError @authRequired
  registerUserPushToken(pushToken: String!): RegisterUserPushTokenPayloadOrError @authRequired
  unregisterUserPushToken(pushToken: String!): UnregisterUserPushTokenPayloadOrError @authRequired
  setProfileImage(input: SetProfileImageInput!): SetProfileImagePayloadOrError @authRequired
  removeProfileImage: RemoveProfileImagePayloadOrError @authRequired
  reportPost(postId: DBID!, reason: ReportReason!): ReportPostPayloadOrError
  blockUser(userId: DBID!): BlockUserPayloadOrError @authRequired
  unblockUser(userId: DBID!): UnblockUserPayloadOrError @authRequired

  # Gallery Mutations
  updateGalleryCollections(
    input: UpdateGalleryCollectionsInput!
  ): UpdateGalleryCollectionsPayloadOrError @authRequired

  # Collection Mutations

  createCollection(input: CreateCollectionInput!): CreateCollectionPayloadOrError @authRequired
  deleteCollection(collectionId: DBID!): DeleteCollectionPayloadOrError @authRequired
  updateCollectionInfo(input: UpdateCollectionInfoInput!): UpdateCollectionInfoPayloadOrError
    @authRequired
  updateCollectionTokens(input: UpdateCollectionTokensInput!): UpdateCollectionTokensPayloadOrError
    @authRequired
  updateCollectionHidden(input: UpdateCollectionHiddenInput!): UpdateCollectionHiddenPayloadOrError
    @authRequired

  # Token Mutations
  updateTokenInfo(input: UpdateTokenInfoInput!): UpdateTokenInfoPayloadOrError @authRequired
  setSpamPreference(input: SetSpamPreferenceInput!): SetSpamPreferencePayloadOrError @authRequired

  syncTokens(chains: [Chain!], incrementally: Boolean): SyncTokensPayloadOrError @authRequired
  syncCreatedTokensForNewContracts(
    input: SyncCreatedTokensForNewContractsInput!
  ): SyncCreatedTokensForNewContractsPayloadOrError @authRequired
  syncCreatedTokensForExistingContract(
    input: SyncCreatedTokensForExistingContractInput!
  ): SyncCreatedTokensForExistingContractPayloadOrError @authRequired
  refreshToken(tokenId: DBID!): RefreshTokenPayloadOrError
  refreshCollection(collectionId: DBID!): RefreshCollectionPayloadOrError
  refreshContract(contractId: DBID!): RefreshContractPayloadOrError

  getAuthNonce: GetAuthNoncePayloadOrError

  createUser(authMechanism: AuthMechanism!, input: CreateUserInput!): CreateUserPayloadOrError
  updateEmail(input: UpdateEmailInput!): UpdateEmailPayloadOrError @authRequired
  resendVerificationEmail: ResendVerificationEmailPayloadOrError @authRequired
  updateEmailNotificationSettings(
    input: UpdateEmailNotificationSettingsInput!
  ): UpdateEmailNotificationSettingsPayloadOrError @authRequired
  unsubscribeFromEmailType(
    input: UnsubscribeFromEmailTypeInput!
  ): UnsubscribeFromEmailTypePayloadOrError
  login(authMechanism: AuthMechanism!): LoginPayloadOrError
  logout(pushTokenToUnregister: String): LogoutPayload

  connectSocialAccount(
    input: SocialAuthMechanism!
    display: Boolean! = true
  ): ConnectSocialAccountPayloadOrError @authRequired
  disconnectSocialAccount(accountType: SocialAccountType!): DisconnectSocialAccountPayloadOrError
    @authRequired
  updateSocialAccountDisplayed(
    input: UpdateSocialAccountDisplayedInput!
  ): UpdateSocialAccountDisplayedPayloadOrError @authRequired

  followUser(userId: DBID!): FollowUserPayloadOrError @authRequired
  followAllSocialConnections(
    accountType: SocialAccountType!
  ): FollowAllSocialConnectionsPayloadOrError @authRequired
  followAllOnboardingRecommendations(
    """
    A cursor returned from `Viewer.suggestedUsers` can be provided to follow all users from when the
    cursor was generated. Otherwise, all users from the current recommendation set will be followed instead.
    """
    cursor: String
  ): FollowAllOnboardingRecommendationsPayloadOrError @authRequired
  unfollowUser(userId: DBID!): UnfollowUserPayloadOrError @authRequired

  admireFeedEvent(feedEventId: DBID!): AdmireFeedEventPayloadOrError @authRequired
  admirePost(postId: DBID!): AdmirePostPayloadOrError @authRequired
  admireToken(tokenId: DBID!): AdmireTokenPayloadOrError @authRequired
  admireComment(commentId: DBID!): AdmireCommentPayloadOrError @authRequired
  removeAdmire(admireId: DBID!): RemoveAdmirePayloadOrError @authRequired
  commentOnFeedEvent(
    feedEventId: DBID!
    replyToID: DBID
    comment: String!
    mentions: [MentionInput!]
  ): CommentOnFeedEventPayloadOrError @authRequired
  removeComment(commentId: DBID!): RemoveCommentPayloadOrError @authRequired
  commentOnPost(
    postId: DBID!
    replyToID: DBID
    comment: String!
    mentions: [MentionInput!]
  ): CommentOnPostPayloadOrError @authRequired

  postTokens(input: PostTokensInput!): PostTokensPayloadOrError @authRequired
  referralPostToken(input: ReferralPostTokenInput!): ReferralPostTokenPayloadOrError @authRequired
  referralPostPreflight(input: ReferralPostPreflightInput!): ReferralPostPreflightPayloadOrError
  deletePost(postId: DBID!): DeletePostPayloadOrError @authRequired

  highlightClaimMint(input: HighlightClaimMintInput!): HighlightClaimMintPayloadOrError
    @authRequired

  viewGallery(galleryId: DBID!): ViewGalleryPayloadOrError
  viewToken(tokenID: DBID!, collectionID: DBID!): ViewTokenPayloadOrError

  updateGallery(input: UpdateGalleryInput!): UpdateGalleryPayloadOrError @authRequired
  publishGallery(input: PublishGalleryInput!): PublishGalleryPayloadOrError @authRequired

  createGallery(input: CreateGalleryInput!): CreateGalleryPayloadOrError @authRequired
  updateGalleryHidden(input: UpdateGalleryHiddenInput!): UpdateGalleryHiddenPayloadOrError
    @authRequired
  deleteGallery(galleryId: DBID!): DeleteGalleryPayloadOrError @authRequired
  updateGalleryOrder(input: UpdateGalleryOrderInput!): UpdateGalleryOrderPayloadOrError
    @authRequired
  updateGalleryInfo(input: UpdateGalleryInfoInput!): UpdateGalleryInfoPayloadOrError @authRequired
  updateFeaturedGallery(galleryId: DBID!): UpdateFeaturedGalleryPayloadOrError @authRequired

  clearAllNotifications: ClearAllNotificationsPayload @authRequired

  updateNotificationSettings(settings: NotificationSettingsInput): NotificationSettings

  preverifyEmail(input: PreverifyEmailInput!): PreverifyEmailPayloadOrError
  verifyEmail(input: VerifyEmailInput!): VerifyEmailPayloadOrError
  verifyEmailMagicLink(input: VerifyEmailMagicLinkInput!): VerifyEmailMagicLinkPayloadOrError

  redeemMerch(input: RedeemMerchInput!): RedeemMerchPayloadOrError @authRequired

  optInForRoles(roles: [Role!]!): OptInForRolesPayloadOrError @authRequired
  optOutForRoles(roles: [Role!]!): OptOutForRolesPayloadOrError @authRequired

  setPersona(persona: Persona!): SetPersonaPayloadOrError @authRequired

  # Retool Specific Mutations
  addRolesToUser(username: String!, roles: [Role]): AddRolesToUserPayloadOrError
    @basicAuth(allowed: [Retool])
  addWalletToUserUnchecked(input: AdminAddWalletInput!): AdminAddWalletPayloadOrError
    @basicAuth(allowed: [Retool])
  revokeRolesFromUser(username: String!, roles: [Role]): RevokeRolesFromUserPayloadOrError
    @basicAuth(allowed: [Retool])
  syncTokensForUsername(username: String!, chains: [Chain!]!): SyncTokensForUsernamePayloadOrError
    @basicAuth(allowed: [Retool, Monitoring])
  syncCreatedTokensForUsername(
    username: String!
    chains: [Chain!]!
  ): SyncCreatedTokensForUsernamePayloadOrError @basicAuth(allowed: [Retool])
  syncCreatedTokensForUsernameAndExistingContract(
    username: String!
    chainAddress: ChainAddressInput!
  ): SyncCreatedTokensForUsernameAndExistingContractPayloadOrError @basicAuth(allowed: [Retool])
  banUserFromFeed(username: String!, reason: ReportReason!): BanUserFromFeedPayloadOrError
    @basicAuth(allowed: [Retool])
  unbanUserFromFeed(username: String!): UnbanUserFromFeedPayloadOrError
    @basicAuth(allowed: [Retool])
  mintPremiumCardToWallet(
    input: MintPremiumCardToWalletInput!
  ): MintPremiumCardToWalletPayloadOrError @basicAuth(allowed: [Retool])
  setCommunityOverrideCreator(
    communityID: DBID!
    creatorUserID: DBID
  ): SetCommunityOverrideCreatorPayloadOrError @basicAuth(allowed: [Retool])

  # Gallery Frontend Deploy Persisted Queries
  uploadPersistedQueries(input: UploadPersistedQueriesInput): UploadPersistedQueriesPayloadOrError
    @frontendBuildAuth

  updatePrimaryWallet(walletID: DBID!): UpdatePrimaryWalletPayloadOrError @authRequired

  updateUserExperience(input: UpdateUserExperienceInput!): UpdateUserExperiencePayloadOrError
    @authRequired

  moveCollectionToGallery(
    input: MoveCollectionToGalleryInput
  ): MoveCollectionToGalleryPayloadOrError @authRequired

  generateQRCodeLoginToken: GenerateQRCodeLoginTokenPayloadOrError @authRequired
}

type Subscription {
  newNotification: Notification
  notificationUpdated: Notification
}
