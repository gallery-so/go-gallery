// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AddressOrGalleryUser interface {
	IsAddressOrGalleryUser()
}

type CreateUserPayloadOrError interface {
	IsCreateUserPayloadOrError()
}

type Error interface {
	IsError()
}

type GetAuthNoncePayloadOrError interface {
	IsGetAuthNoncePayloadOrError()
}

type LoginPayloadOrError interface {
	IsLoginPayloadOrError()
}

type Nft interface {
	IsNft()
}

type NftInterface interface {
	IsNftInterface()
}

type Node interface {
	IsNode()
}

type UserByUsernameOrError interface {
	IsUserByUsernameOrError()
}

type ViewerOrError interface {
	IsViewerOrError()
}

type AuthMechanism struct {
	EthereumEoa *EthereumEoaAuth `json:"ethereumEoa"`
	GnosisSafe  *GnosisSafeAuth  `json:"gnosisSafe"`
}

type AuthNonce struct {
	Nonce      *string `json:"nonce"`
	UserExists *bool   `json:"userExists"`
}

func (AuthNonce) IsGetAuthNoncePayloadOrError() {}

type CreateCollectionInput struct {
	GalleryID      string                        `json:"galleryId"`
	Name           *string                       `json:"name"`
	CollectorsNote *string                       `json:"collectorsNote"`
	Nfts           []string                      `json:"nfts"`
	Layout         *GalleryCollectionLayoutInput `json:"layout"`
}

type CreateCollectionPayload struct {
	Gallery *Gallery `json:"gallery"`
}

type CreateUserPayload struct {
	UserID    *string `json:"userId"`
	GalleryID *string `json:"galleryId"`
}

func (CreateUserPayload) IsCreateUserPayloadOrError() {}

type DeleteCollectionPayload struct {
	Gallery *Gallery `json:"gallery"`
}

type ErrAddressDoesNotOwnRequiredNft struct {
	Message string `json:"message"`
}

func (ErrAddressDoesNotOwnRequiredNft) IsGetAuthNoncePayloadOrError() {}
func (ErrAddressDoesNotOwnRequiredNft) IsError()                      {}
func (ErrAddressDoesNotOwnRequiredNft) IsLoginPayloadOrError()        {}
func (ErrAddressDoesNotOwnRequiredNft) IsCreateUserPayloadOrError()   {}

type ErrNotAuthorized struct {
	Message   string          `json:"message"`
	ErrorType AuthFailureType `json:"errorType"`
}

func (ErrNotAuthorized) IsViewerOrError() {}
func (ErrNotAuthorized) IsError()         {}

type ErrSignatureVerificationFailed struct {
	Message string `json:"message"`
}

func (ErrSignatureVerificationFailed) IsError()                    {}
func (ErrSignatureVerificationFailed) IsLoginPayloadOrError()      {}
func (ErrSignatureVerificationFailed) IsCreateUserPayloadOrError() {}

type ErrUserAlreadyExists struct {
	Message string `json:"message"`
}

func (ErrUserAlreadyExists) IsError()                    {}
func (ErrUserAlreadyExists) IsCreateUserPayloadOrError() {}

type ErrUserNotFound struct {
	Message string `json:"message"`
}

func (ErrUserNotFound) IsUserByUsernameOrError() {}
func (ErrUserNotFound) IsError()                 {}
func (ErrUserNotFound) IsLoginPayloadOrError()   {}

type EthereumEoaAuth struct {
	Address   string `json:"address"`
	Nonce     string `json:"nonce"`
	Signature string `json:"signature"`
}

type Gallery struct {
	ID          string               `json:"id"`
	Owner       *GalleryUser         `json:"owner"`
	Collections []*GalleryCollection `json:"collections"`
}

func (Gallery) IsNode() {}

type GalleryCollection struct {
	ID             string                   `json:"id"`
	Version        *int                     `json:"version"`
	Name           *string                  `json:"name"`
	CollectorsNote *string                  `json:"collectorsNote"`
	Gallery        *Gallery                 `json:"gallery"`
	Layout         *GalleryCollectionLayout `json:"layout"`
	Hidden         *bool                    `json:"hidden"`
	Nfts           []*GalleryNft            `json:"nfts"`
}

func (GalleryCollection) IsNode() {}

type GalleryCollectionLayout struct {
	Columns *int `json:"columns"`
}

type GalleryCollectionLayoutInput struct {
	Columns *int `json:"columns"`
}

type GalleryNft struct {
	ID         string             `json:"id"`
	Nft        Nft                `json:"nft"`
	Collection *GalleryCollection `json:"collection"`
}

type GalleryUser struct {
	ID                  string     `json:"id"`
	Username            *string    `json:"username"`
	Bio                 *string    `json:"bio"`
	Wallets             []*Wallet  `json:"wallets"`
	Galleries           []*Gallery `json:"galleries"`
	IsAuthenticatedUser *bool      `json:"isAuthenticatedUser"`
}

func (GalleryUser) IsNode()                  {}
func (GalleryUser) IsAddressOrGalleryUser()  {}
func (GalleryUser) IsUserByUsernameOrError() {}

type GnosisSafeAuth struct {
	Address   string `json:"address"`
	Nonce     string `json:"nonce"`
	Signature string `json:"signature"`
}

type ImageNft struct {
	ID                  string               `json:"id"`
	Name                *string              `json:"name"`
	TokenCollectionName *string              `json:"tokenCollectionName"`
	Owner               AddressOrGalleryUser `json:"owner"`
	ImageURL            *string              `json:"imageUrl"`
}

func (ImageNft) IsNftInterface() {}
func (ImageNft) IsNode()         {}
func (ImageNft) IsNft()          {}

type LoginPayload struct {
	UserID *string `json:"userId"`
}

func (LoginPayload) IsLoginPayloadOrError() {}

type MembershipTier struct {
	ID       string                 `json:"id"`
	Name     *string                `json:"name"`
	AssetURL *string                `json:"assetUrl"`
	TokenID  *string                `json:"tokenId"`
	Owners   []*MembershipTierOwner `json:"owners"`
}

func (MembershipTier) IsNode() {}

type MembershipTierOwner struct {
	ID          string       `json:"id"`
	User        *GalleryUser `json:"user"`
	PreviewNfts []*string    `json:"previewNfts"`
}

func (MembershipTierOwner) IsNode() {}

type RefreshOpenSeaNftsPayload struct {
	Wallet *Wallet `json:"wallet"`
}

type RemoveUserAddressPayload struct {
	Viewer *Viewer `json:"viewer"`
}

type UpdateCollectionInfoInput struct {
	CollectionID   string  `json:"collectionId"`
	Name           *string `json:"name"`
	CollectorsNote *string `json:"collectorsNote"`
}

type UpdateCollectionInfoPayload struct {
	Collection *GalleryCollection `json:"collection"`
}

type UpdateCollectionNftsInput struct {
	CollectionID string   `json:"collectionId"`
	Nfts         []string `json:"nfts"`
}

type UpdateCollectionNftsPayload struct {
	Collection *GalleryCollection `json:"collection"`
}

type UpdateGalleryCollectionsInput struct {
	GalleryID   string   `json:"galleryId"`
	Collections []string `json:"collections"`
}

type UpdateGalleryCollectionsPayload struct {
	Gallery *Gallery `json:"gallery"`
}

type UpdateUserInfoInput struct {
	Username *string `json:"username"`
	Bio      *string `json:"bio"`
}

type UpdateUserInfoPayload struct {
	Viewer *Viewer `json:"viewer"`
}

type VideoNft struct {
	ID                  string               `json:"id"`
	Name                *string              `json:"name"`
	TokenCollectionName *string              `json:"tokenCollectionName"`
	Owner               AddressOrGalleryUser `json:"owner"`
}

func (VideoNft) IsNftInterface() {}
func (VideoNft) IsNode()         {}
func (VideoNft) IsNft()          {}

type Viewer struct {
	User          *GalleryUser   `json:"user"`
	Wallets       []*Wallet      `json:"wallets"`
	ViewerGallery *ViewerGallery `json:"viewerGallery"`
}

func (Viewer) IsViewerOrError() {}

type ViewerGallery struct {
	Gallery *Gallery `json:"gallery"`
}

type Wallet struct {
	ID      string  `json:"id"`
	Address *string `json:"address"`
	Nfts    []Nft   `json:"nfts"`
}

func (Wallet) IsNode()                 {}
func (Wallet) IsAddressOrGalleryUser() {}

type AuthFailureType string

const (
	AuthFailureTypeNoCookie              AuthFailureType = "NoCookie"
	AuthFailureTypeInvalidToken          AuthFailureType = "InvalidToken"
	AuthFailureTypeDoesNotOwnRequiredNft AuthFailureType = "DoesNotOwnRequiredNFT"
	AuthFailureTypeInternalError         AuthFailureType = "InternalError"
)

var AllAuthFailureType = []AuthFailureType{
	AuthFailureTypeNoCookie,
	AuthFailureTypeInvalidToken,
	AuthFailureTypeDoesNotOwnRequiredNft,
	AuthFailureTypeInternalError,
}

func (e AuthFailureType) IsValid() bool {
	switch e {
	case AuthFailureTypeNoCookie, AuthFailureTypeInvalidToken, AuthFailureTypeDoesNotOwnRequiredNft, AuthFailureTypeInternalError:
		return true
	}
	return false
}

func (e AuthFailureType) String() string {
	return string(e)
}

func (e *AuthFailureType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthFailureType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthFailureType", str)
	}
	return nil
}

func (e AuthFailureType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
