// Code generated by github.com/mikeydub/go-gallery/cmd/dataloaders, DO NOT EDIT.

package dataloader

import (
	"context"
	"time"

	"github.com/mikeydub/go-gallery/cmd/dataloaders/generator"

	"github.com/mikeydub/go-gallery/service/persist"

	"github.com/mikeydub/go-gallery/db/gen/coredb"
)

type autoCacheWithKey[TKey any, TResult any] interface {
	getKeyForResult(TResult) TKey
}

type autoCacheWithKeys[TKey any, TResult any] interface {
	getKeysForResult(TResult) []TKey
}

type notFoundErrorProvider[TKey any] interface {
	getNotFoundError(TKey) error
}

type PreFetchHook func(context.Context, string) context.Context
type PostFetchHook func(context.Context, string)

// CountAdmiresByFeedEventIDBatch batches and caches requests
type CountAdmiresByFeedEventIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountAdmiresByFeedEventIDBatch creates a new CountAdmiresByFeedEventIDBatch with the given settings, functions, and options
func newCountAdmiresByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountAdmiresByFeedEventIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountAdmiresByFeedEventIDBatch {
	d := &CountAdmiresByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountAdmiresByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountAdmiresByFeedEventIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// CountAdmiresByPostIDBatch batches and caches requests
type CountAdmiresByPostIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountAdmiresByPostIDBatch creates a new CountAdmiresByPostIDBatch with the given settings, functions, and options
func newCountAdmiresByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountAdmiresByPostIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountAdmiresByPostIDBatch {
	d := &CountAdmiresByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountAdmiresByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountAdmiresByPostIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// CountAdmiresByTokenIDBatch batches and caches requests
type CountAdmiresByTokenIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountAdmiresByTokenIDBatch creates a new CountAdmiresByTokenIDBatch with the given settings, functions, and options
func newCountAdmiresByTokenIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountAdmiresByTokenIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountAdmiresByTokenIDBatch {
	d := &CountAdmiresByTokenIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountAdmiresByTokenIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountAdmiresByTokenIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// CountCommentsByFeedEventIDBatch batches and caches requests
type CountCommentsByFeedEventIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountCommentsByFeedEventIDBatch creates a new CountCommentsByFeedEventIDBatch with the given settings, functions, and options
func newCountCommentsByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountCommentsByFeedEventIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountCommentsByFeedEventIDBatch {
	d := &CountCommentsByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountCommentsByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountCommentsByFeedEventIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// CountCommentsByPostIDBatch batches and caches requests
type CountCommentsByPostIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountCommentsByPostIDBatch creates a new CountCommentsByPostIDBatch with the given settings, functions, and options
func newCountCommentsByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountCommentsByPostIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountCommentsByPostIDBatch {
	d := &CountCommentsByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountCommentsByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountCommentsByPostIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// CountInteractionsByFeedEventIDBatch batches and caches requests
type CountInteractionsByFeedEventIDBatch struct {
	generator.Dataloader[coredb.CountInteractionsByFeedEventIDBatchParams, []coredb.CountInteractionsByFeedEventIDBatchRow]
}

// newCountInteractionsByFeedEventIDBatch creates a new CountInteractionsByFeedEventIDBatch with the given settings, functions, and options
func newCountInteractionsByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountInteractionsByFeedEventIDBatch, []coredb.CountInteractionsByFeedEventIDBatchParams) ([][]coredb.CountInteractionsByFeedEventIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountInteractionsByFeedEventIDBatch {
	d := &CountInteractionsByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.CountInteractionsByFeedEventIDBatchParams) ([][]coredb.CountInteractionsByFeedEventIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountInteractionsByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountInteractionsByFeedEventIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// CountInteractionsByPostIDBatch batches and caches requests
type CountInteractionsByPostIDBatch struct {
	generator.Dataloader[coredb.CountInteractionsByPostIDBatchParams, []coredb.CountInteractionsByPostIDBatchRow]
}

// newCountInteractionsByPostIDBatch creates a new CountInteractionsByPostIDBatch with the given settings, functions, and options
func newCountInteractionsByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountInteractionsByPostIDBatch, []coredb.CountInteractionsByPostIDBatchParams) ([][]coredb.CountInteractionsByPostIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountInteractionsByPostIDBatch {
	d := &CountInteractionsByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.CountInteractionsByPostIDBatchParams) ([][]coredb.CountInteractionsByPostIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountInteractionsByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountInteractionsByPostIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// CountRepliesByCommentIDBatch batches and caches requests
type CountRepliesByCommentIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountRepliesByCommentIDBatch creates a new CountRepliesByCommentIDBatch with the given settings, functions, and options
func newCountRepliesByCommentIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountRepliesByCommentIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountRepliesByCommentIDBatch {
	d := &CountRepliesByCommentIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountRepliesByCommentIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountRepliesByCommentIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetAdmireByActorIDAndFeedEventID batches and caches requests
type GetAdmireByActorIDAndFeedEventID struct {
	generator.Dataloader[coredb.GetAdmireByActorIDAndFeedEventIDParams, coredb.Admire]
}

// newGetAdmireByActorIDAndFeedEventID creates a new GetAdmireByActorIDAndFeedEventID with the given settings, functions, and options
func newGetAdmireByActorIDAndFeedEventID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByActorIDAndFeedEventID, []coredb.GetAdmireByActorIDAndFeedEventIDParams) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByActorIDAndFeedEventID {
	d := &GetAdmireByActorIDAndFeedEventID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetAdmireByActorIDAndFeedEventIDParams) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByActorIDAndFeedEventID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByActorIDAndFeedEventID")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetAdmireByActorIDAndPostID batches and caches requests
type GetAdmireByActorIDAndPostID struct {
	generator.Dataloader[coredb.GetAdmireByActorIDAndPostIDParams, coredb.Admire]
}

// newGetAdmireByActorIDAndPostID creates a new GetAdmireByActorIDAndPostID with the given settings, functions, and options
func newGetAdmireByActorIDAndPostID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByActorIDAndPostID, []coredb.GetAdmireByActorIDAndPostIDParams) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByActorIDAndPostID {
	d := &GetAdmireByActorIDAndPostID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetAdmireByActorIDAndPostIDParams) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByActorIDAndPostID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByActorIDAndPostID")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetAdmireByActorIDAndTokenID batches and caches requests
type GetAdmireByActorIDAndTokenID struct {
	generator.Dataloader[coredb.GetAdmireByActorIDAndTokenIDParams, coredb.Admire]
}

// newGetAdmireByActorIDAndTokenID creates a new GetAdmireByActorIDAndTokenID with the given settings, functions, and options
func newGetAdmireByActorIDAndTokenID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByActorIDAndTokenID, []coredb.GetAdmireByActorIDAndTokenIDParams) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByActorIDAndTokenID {
	d := &GetAdmireByActorIDAndTokenID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetAdmireByActorIDAndTokenIDParams) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByActorIDAndTokenID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByActorIDAndTokenID")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetAdmireByAdmireIDBatch batches and caches requests
type GetAdmireByAdmireIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Admire]
}

// newGetAdmireByAdmireIDBatch creates a new GetAdmireByAdmireIDBatch with the given settings, functions, and options
func newGetAdmireByAdmireIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByAdmireIDBatch, []persist.DBID) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByAdmireIDBatch {
	d := &GetAdmireByAdmireIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByAdmireIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByAdmireIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetAdmireByAdmireIDBatch) getKeyForResult(result coredb.Admire) persist.DBID {
	return result.ID
}

// GetAdmiresByActorIDBatch batches and caches requests
type GetAdmiresByActorIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Admire]
}

// newGetAdmiresByActorIDBatch creates a new GetAdmiresByActorIDBatch with the given settings, functions, and options
func newGetAdmiresByActorIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmiresByActorIDBatch, []persist.DBID) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmiresByActorIDBatch {
	d := &GetAdmiresByActorIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmiresByActorIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmiresByActorIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetChildContractsByParentIDBatchPaginate batches and caches requests
type GetChildContractsByParentIDBatchPaginate struct {
	generator.Dataloader[coredb.GetChildContractsByParentIDBatchPaginateParams, []coredb.Contract]
}

// newGetChildContractsByParentIDBatchPaginate creates a new GetChildContractsByParentIDBatchPaginate with the given settings, functions, and options
func newGetChildContractsByParentIDBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetChildContractsByParentIDBatchPaginate, []coredb.GetChildContractsByParentIDBatchPaginateParams) ([][]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetChildContractsByParentIDBatchPaginate {
	d := &GetChildContractsByParentIDBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetChildContractsByParentIDBatchPaginateParams) ([][]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetChildContractsByParentIDBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetChildContractsByParentIDBatchPaginate")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetCollectionByIdBatch batches and caches requests
type GetCollectionByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Collection]
}

// newGetCollectionByIdBatch creates a new GetCollectionByIdBatch with the given settings, functions, and options
func newGetCollectionByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCollectionByIdBatch, []persist.DBID) ([]coredb.Collection, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCollectionByIdBatch {
	d := &GetCollectionByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Collection, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCollectionByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCollectionByIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetCollectionByIdBatch) getKeyForResult(result coredb.Collection) persist.DBID {
	return result.ID
}

// GetCollectionsByGalleryIdBatch batches and caches requests
type GetCollectionsByGalleryIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Collection]
}

// newGetCollectionsByGalleryIdBatch creates a new GetCollectionsByGalleryIdBatch with the given settings, functions, and options
func newGetCollectionsByGalleryIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCollectionsByGalleryIdBatch, []persist.DBID) ([][]coredb.Collection, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCollectionsByGalleryIdBatch {
	d := &GetCollectionsByGalleryIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Collection, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCollectionsByGalleryIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCollectionsByGalleryIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetCommentByCommentIDBatch batches and caches requests
type GetCommentByCommentIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Comment]
}

// newGetCommentByCommentIDBatch creates a new GetCommentByCommentIDBatch with the given settings, functions, and options
func newGetCommentByCommentIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCommentByCommentIDBatch, []persist.DBID) ([]coredb.Comment, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCommentByCommentIDBatch {
	d := &GetCommentByCommentIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Comment, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCommentByCommentIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCommentByCommentIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetCommentByCommentIDBatch) getKeyForResult(result coredb.Comment) persist.DBID {
	return result.ID
}

// GetContractByChainAddressBatch batches and caches requests
type GetContractByChainAddressBatch struct {
	generator.Dataloader[coredb.GetContractByChainAddressBatchParams, coredb.Contract]
}

// newGetContractByChainAddressBatch creates a new GetContractByChainAddressBatch with the given settings, functions, and options
func newGetContractByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetContractByChainAddressBatch, []coredb.GetContractByChainAddressBatchParams) ([]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetContractByChainAddressBatch {
	d := &GetContractByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetContractByChainAddressBatchParams) ([]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetContractByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetContractByChainAddressBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetContractsDisplayedByUserIDBatch batches and caches requests
type GetContractsDisplayedByUserIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Contract]
}

// newGetContractsDisplayedByUserIDBatch creates a new GetContractsDisplayedByUserIDBatch with the given settings, functions, and options
func newGetContractsDisplayedByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetContractsDisplayedByUserIDBatch, []persist.DBID) ([][]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetContractsDisplayedByUserIDBatch {
	d := &GetContractsDisplayedByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetContractsDisplayedByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetContractsDisplayedByUserIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetCreatedContractsBatchPaginate batches and caches requests
type GetCreatedContractsBatchPaginate struct {
	generator.Dataloader[coredb.GetCreatedContractsBatchPaginateParams, []coredb.Contract]
}

// newGetCreatedContractsBatchPaginate creates a new GetCreatedContractsBatchPaginate with the given settings, functions, and options
func newGetCreatedContractsBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCreatedContractsBatchPaginate, []coredb.GetCreatedContractsBatchPaginateParams) ([][]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCreatedContractsBatchPaginate {
	d := &GetCreatedContractsBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetCreatedContractsBatchPaginateParams) ([][]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCreatedContractsBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCreatedContractsBatchPaginate")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetEventByIdBatch batches and caches requests
type GetEventByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.FeedEvent]
}

// newGetEventByIdBatch creates a new GetEventByIdBatch with the given settings, functions, and options
func newGetEventByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetEventByIdBatch, []persist.DBID) ([]coredb.FeedEvent, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetEventByIdBatch {
	d := &GetEventByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.FeedEvent, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetEventByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetEventByIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetEventByIdBatch) getKeyForResult(result coredb.FeedEvent) persist.DBID {
	return result.ID
}

// GetFollowersByUserIdBatch batches and caches requests
type GetFollowersByUserIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.User]
}

// newGetFollowersByUserIdBatch creates a new GetFollowersByUserIdBatch with the given settings, functions, and options
func newGetFollowersByUserIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetFollowersByUserIdBatch, []persist.DBID) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetFollowersByUserIdBatch {
	d := &GetFollowersByUserIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetFollowersByUserIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetFollowersByUserIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetFollowingByUserIdBatch batches and caches requests
type GetFollowingByUserIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.User]
}

// newGetFollowingByUserIdBatch creates a new GetFollowingByUserIdBatch with the given settings, functions, and options
func newGetFollowingByUserIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetFollowingByUserIdBatch, []persist.DBID) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetFollowingByUserIdBatch {
	d := &GetFollowingByUserIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetFollowingByUserIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetFollowingByUserIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetGalleriesByUserIdBatch batches and caches requests
type GetGalleriesByUserIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Gallery]
}

// newGetGalleriesByUserIdBatch creates a new GetGalleriesByUserIdBatch with the given settings, functions, and options
func newGetGalleriesByUserIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleriesByUserIdBatch, []persist.DBID) ([][]coredb.Gallery, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleriesByUserIdBatch {
	d := &GetGalleriesByUserIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Gallery, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleriesByUserIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleriesByUserIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetGalleryByCollectionIdBatch batches and caches requests
type GetGalleryByCollectionIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Gallery]
}

// newGetGalleryByCollectionIdBatch creates a new GetGalleryByCollectionIdBatch with the given settings, functions, and options
func newGetGalleryByCollectionIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleryByCollectionIdBatch, []persist.DBID) ([]coredb.Gallery, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleryByCollectionIdBatch {
	d := &GetGalleryByCollectionIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Gallery, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleryByCollectionIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleryByCollectionIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetGalleryByCollectionIdBatch) getKeyForResult(result coredb.Gallery) persist.DBID {
	return result.ID
}

// GetGalleryByIdBatch batches and caches requests
type GetGalleryByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Gallery]
}

// newGetGalleryByIdBatch creates a new GetGalleryByIdBatch with the given settings, functions, and options
func newGetGalleryByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleryByIdBatch, []persist.DBID) ([]coredb.Gallery, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleryByIdBatch {
	d := &GetGalleryByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Gallery, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleryByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleryByIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetGalleryByIdBatch) getKeyForResult(result coredb.Gallery) persist.DBID {
	return result.ID
}

// GetGalleryTokenMediasByGalleryIDBatch batches and caches requests
type GetGalleryTokenMediasByGalleryIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.TokenMedia]
}

// newGetGalleryTokenMediasByGalleryIDBatch creates a new GetGalleryTokenMediasByGalleryIDBatch with the given settings, functions, and options
func newGetGalleryTokenMediasByGalleryIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleryTokenMediasByGalleryIDBatch, []persist.DBID) ([][]coredb.TokenMedia, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleryTokenMediasByGalleryIDBatch {
	d := &GetGalleryTokenMediasByGalleryIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.TokenMedia, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleryTokenMediasByGalleryIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleryTokenMediasByGalleryIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetMediaByMediaIDIgnoringStatus batches and caches requests
type GetMediaByMediaIDIgnoringStatus struct {
	generator.Dataloader[persist.DBID, coredb.TokenMedia]
}

// newGetMediaByMediaIDIgnoringStatus creates a new GetMediaByMediaIDIgnoringStatus with the given settings, functions, and options
func newGetMediaByMediaIDIgnoringStatus(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetMediaByMediaIDIgnoringStatus, []persist.DBID) ([]coredb.TokenMedia, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetMediaByMediaIDIgnoringStatus {
	d := &GetMediaByMediaIDIgnoringStatus{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.TokenMedia, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetMediaByMediaIDIgnoringStatus")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetMediaByMediaIDIgnoringStatus")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetMediaByMediaIDIgnoringStatus) getKeyForResult(result coredb.TokenMedia) persist.DBID {
	return result.ID
}

// GetMembershipByMembershipIdBatch batches and caches requests
type GetMembershipByMembershipIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Membership]
}

// newGetMembershipByMembershipIdBatch creates a new GetMembershipByMembershipIdBatch with the given settings, functions, and options
func newGetMembershipByMembershipIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetMembershipByMembershipIdBatch, []persist.DBID) ([]coredb.Membership, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetMembershipByMembershipIdBatch {
	d := &GetMembershipByMembershipIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Membership, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetMembershipByMembershipIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetMembershipByMembershipIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetMembershipByMembershipIdBatch) getKeyForResult(result coredb.Membership) persist.DBID {
	return result.ID
}

// GetMentionsByCommentID batches and caches requests
type GetMentionsByCommentID struct {
	generator.Dataloader[persist.DBID, []coredb.Mention]
}

// newGetMentionsByCommentID creates a new GetMentionsByCommentID with the given settings, functions, and options
func newGetMentionsByCommentID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetMentionsByCommentID, []persist.DBID) ([][]coredb.Mention, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetMentionsByCommentID {
	d := &GetMentionsByCommentID{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Mention, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetMentionsByCommentID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetMentionsByCommentID")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetMentionsByPostID batches and caches requests
type GetMentionsByPostID struct {
	generator.Dataloader[persist.DBID, []coredb.Mention]
}

// newGetMentionsByPostID creates a new GetMentionsByPostID with the given settings, functions, and options
func newGetMentionsByPostID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetMentionsByPostID, []persist.DBID) ([][]coredb.Mention, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetMentionsByPostID {
	d := &GetMentionsByPostID{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Mention, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetMentionsByPostID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetMentionsByPostID")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetNewTokensByFeedEventIdBatch batches and caches requests
type GetNewTokensByFeedEventIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Token]
}

// newGetNewTokensByFeedEventIdBatch creates a new GetNewTokensByFeedEventIdBatch with the given settings, functions, and options
func newGetNewTokensByFeedEventIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetNewTokensByFeedEventIdBatch, []persist.DBID) ([][]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetNewTokensByFeedEventIdBatch {
	d := &GetNewTokensByFeedEventIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetNewTokensByFeedEventIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetNewTokensByFeedEventIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetNotificationByIDBatch batches and caches requests
type GetNotificationByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Notification]
}

// newGetNotificationByIDBatch creates a new GetNotificationByIDBatch with the given settings, functions, and options
func newGetNotificationByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetNotificationByIDBatch, []persist.DBID) ([]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetNotificationByIDBatch {
	d := &GetNotificationByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetNotificationByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetNotificationByIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetNotificationByIDBatch) getKeyForResult(result coredb.Notification) persist.DBID {
	return result.ID
}

// GetOwnersByContractIdBatchPaginate batches and caches requests
type GetOwnersByContractIdBatchPaginate struct {
	generator.Dataloader[coredb.GetOwnersByContractIdBatchPaginateParams, []coredb.User]
}

// newGetOwnersByContractIdBatchPaginate creates a new GetOwnersByContractIdBatchPaginate with the given settings, functions, and options
func newGetOwnersByContractIdBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetOwnersByContractIdBatchPaginate, []coredb.GetOwnersByContractIdBatchPaginateParams) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetOwnersByContractIdBatchPaginate {
	d := &GetOwnersByContractIdBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetOwnersByContractIdBatchPaginateParams) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetOwnersByContractIdBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetOwnersByContractIdBatchPaginate")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetPostByIdBatch batches and caches requests
type GetPostByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Post]
}

// newGetPostByIdBatch creates a new GetPostByIdBatch with the given settings, functions, and options
func newGetPostByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetPostByIdBatch, []persist.DBID) ([]coredb.Post, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetPostByIdBatch {
	d := &GetPostByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Post, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetPostByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetPostByIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetPostByIdBatch) getKeyForResult(result coredb.Post) persist.DBID {
	return result.ID
}

// GetProfileImageByID batches and caches requests
type GetProfileImageByID struct {
	generator.Dataloader[coredb.GetProfileImageByIDParams, coredb.ProfileImage]
}

// newGetProfileImageByID creates a new GetProfileImageByID with the given settings, functions, and options
func newGetProfileImageByID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetProfileImageByID, []coredb.GetProfileImageByIDParams) ([]coredb.ProfileImage, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetProfileImageByID {
	d := &GetProfileImageByID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetProfileImageByIDParams) ([]coredb.ProfileImage, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetProfileImageByID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetProfileImageByID")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetSharedContractsBatchPaginate batches and caches requests
type GetSharedContractsBatchPaginate struct {
	generator.Dataloader[coredb.GetSharedContractsBatchPaginateParams, []coredb.GetSharedContractsBatchPaginateRow]
}

// newGetSharedContractsBatchPaginate creates a new GetSharedContractsBatchPaginate with the given settings, functions, and options
func newGetSharedContractsBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSharedContractsBatchPaginate, []coredb.GetSharedContractsBatchPaginateParams) ([][]coredb.GetSharedContractsBatchPaginateRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSharedContractsBatchPaginate {
	d := &GetSharedContractsBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetSharedContractsBatchPaginateParams) ([][]coredb.GetSharedContractsBatchPaginateRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSharedContractsBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSharedContractsBatchPaginate")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetSharedFollowersBatchPaginate batches and caches requests
type GetSharedFollowersBatchPaginate struct {
	generator.Dataloader[coredb.GetSharedFollowersBatchPaginateParams, []coredb.GetSharedFollowersBatchPaginateRow]
}

// newGetSharedFollowersBatchPaginate creates a new GetSharedFollowersBatchPaginate with the given settings, functions, and options
func newGetSharedFollowersBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSharedFollowersBatchPaginate, []coredb.GetSharedFollowersBatchPaginateParams) ([][]coredb.GetSharedFollowersBatchPaginateRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSharedFollowersBatchPaginate {
	d := &GetSharedFollowersBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetSharedFollowersBatchPaginateParams) ([][]coredb.GetSharedFollowersBatchPaginateRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSharedFollowersBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSharedFollowersBatchPaginate")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetTokenByIdBatch batches and caches requests
type GetTokenByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Token]
}

// newGetTokenByIdBatch creates a new GetTokenByIdBatch with the given settings, functions, and options
func newGetTokenByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByIdBatch, []persist.DBID) ([]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByIdBatch {
	d := &GetTokenByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetTokenByIdBatch) getKeyForResult(result coredb.Token) persist.DBID {
	return result.ID
}

// GetTokenByIdIgnoreDisplayableBatch batches and caches requests
type GetTokenByIdIgnoreDisplayableBatch struct {
	generator.Dataloader[persist.DBID, coredb.Token]
}

// newGetTokenByIdIgnoreDisplayableBatch creates a new GetTokenByIdIgnoreDisplayableBatch with the given settings, functions, and options
func newGetTokenByIdIgnoreDisplayableBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByIdIgnoreDisplayableBatch, []persist.DBID) ([]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByIdIgnoreDisplayableBatch {
	d := &GetTokenByIdIgnoreDisplayableBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByIdIgnoreDisplayableBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByIdIgnoreDisplayableBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetTokenByIdIgnoreDisplayableBatch) getKeyForResult(result coredb.Token) persist.DBID {
	return result.ID
}

// GetTokenByUserTokenIdentifiersBatch batches and caches requests
type GetTokenByUserTokenIdentifiersBatch struct {
	generator.Dataloader[coredb.GetTokenByUserTokenIdentifiersBatchParams, coredb.Token]
}

// newGetTokenByUserTokenIdentifiersBatch creates a new GetTokenByUserTokenIdentifiersBatch with the given settings, functions, and options
func newGetTokenByUserTokenIdentifiersBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByUserTokenIdentifiersBatch, []coredb.GetTokenByUserTokenIdentifiersBatchParams) ([]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByUserTokenIdentifiersBatch {
	d := &GetTokenByUserTokenIdentifiersBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokenByUserTokenIdentifiersBatchParams) ([]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByUserTokenIdentifiersBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByUserTokenIdentifiersBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetTokenOwnerByIDBatch batches and caches requests
type GetTokenOwnerByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.User]
}

// newGetTokenOwnerByIDBatch creates a new GetTokenOwnerByIDBatch with the given settings, functions, and options
func newGetTokenOwnerByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenOwnerByIDBatch, []persist.DBID) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenOwnerByIDBatch {
	d := &GetTokenOwnerByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenOwnerByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenOwnerByIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetTokenOwnerByIDBatch) getKeyForResult(result coredb.User) persist.DBID {
	return result.ID
}

// GetTokensByCollectionIdBatch batches and caches requests
type GetTokensByCollectionIdBatch struct {
	generator.Dataloader[coredb.GetTokensByCollectionIdBatchParams, []coredb.Token]
}

// newGetTokensByCollectionIdBatch creates a new GetTokensByCollectionIdBatch with the given settings, functions, and options
func newGetTokensByCollectionIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByCollectionIdBatch, []coredb.GetTokensByCollectionIdBatchParams) ([][]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByCollectionIdBatch {
	d := &GetTokensByCollectionIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokensByCollectionIdBatchParams) ([][]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByCollectionIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByCollectionIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetTokensByUserIdAndChainBatch batches and caches requests
type GetTokensByUserIdAndChainBatch struct {
	generator.Dataloader[coredb.GetTokensByUserIdAndChainBatchParams, []coredb.Token]
}

// newGetTokensByUserIdAndChainBatch creates a new GetTokensByUserIdAndChainBatch with the given settings, functions, and options
func newGetTokensByUserIdAndChainBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByUserIdAndChainBatch, []coredb.GetTokensByUserIdAndChainBatchParams) ([][]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByUserIdAndChainBatch {
	d := &GetTokensByUserIdAndChainBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokensByUserIdAndChainBatchParams) ([][]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByUserIdAndChainBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByUserIdAndChainBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetTokensByUserIdBatch batches and caches requests
type GetTokensByUserIdBatch struct {
	generator.Dataloader[coredb.GetTokensByUserIdBatchParams, []coredb.GetTokensByUserIdBatchRow]
}

// newGetTokensByUserIdBatch creates a new GetTokensByUserIdBatch with the given settings, functions, and options
func newGetTokensByUserIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByUserIdBatch, []coredb.GetTokensByUserIdBatchParams) ([][]coredb.GetTokensByUserIdBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByUserIdBatch {
	d := &GetTokensByUserIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokensByUserIdBatchParams) ([][]coredb.GetTokensByUserIdBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByUserIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByUserIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetTokensByWalletIdsBatch batches and caches requests
type GetTokensByWalletIdsBatch struct {
	generator.Dataloader[persist.DBIDList, []coredb.Token]
}

// newGetTokensByWalletIdsBatch creates a new GetTokensByWalletIdsBatch with the given settings, functions, and options
func newGetTokensByWalletIdsBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByWalletIdsBatch, []persist.DBIDList) ([][]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByWalletIdsBatch {
	d := &GetTokensByWalletIdsBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBIDList) ([][]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByWalletIdsBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByWalletIdsBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetUserByAddressAndL1Batch batches and caches requests
type GetUserByAddressAndL1Batch struct {
	generator.Dataloader[coredb.GetUserByAddressAndL1BatchParams, coredb.User]
}

// newGetUserByAddressAndL1Batch creates a new GetUserByAddressAndL1Batch with the given settings, functions, and options
func newGetUserByAddressAndL1Batch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByAddressAndL1Batch, []coredb.GetUserByAddressAndL1BatchParams) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByAddressAndL1Batch {
	d := &GetUserByAddressAndL1Batch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserByAddressAndL1BatchParams) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByAddressAndL1Batch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByAddressAndL1Batch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetUserByIdBatch batches and caches requests
type GetUserByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.User]
}

// newGetUserByIdBatch creates a new GetUserByIdBatch with the given settings, functions, and options
func newGetUserByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByIdBatch, []persist.DBID) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByIdBatch {
	d := &GetUserByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByIdBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetUserByIdBatch) getKeyForResult(result coredb.User) persist.DBID {
	return result.ID
}

// GetUserByUsernameBatch batches and caches requests
type GetUserByUsernameBatch struct {
	generator.Dataloader[string, coredb.User]
}

// newGetUserByUsernameBatch creates a new GetUserByUsernameBatch with the given settings, functions, and options
func newGetUserByUsernameBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByUsernameBatch, []string) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByUsernameBatch {
	d := &GetUserByUsernameBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByUsernameBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByUsernameBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetUserNotificationsBatch batches and caches requests
type GetUserNotificationsBatch struct {
	generator.Dataloader[coredb.GetUserNotificationsBatchParams, []coredb.Notification]
}

// newGetUserNotificationsBatch creates a new GetUserNotificationsBatch with the given settings, functions, and options
func newGetUserNotificationsBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserNotificationsBatch, []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserNotificationsBatch {
	d := &GetUserNotificationsBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserNotificationsBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserNotificationsBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetUsersWithTraitBatch batches and caches requests
type GetUsersWithTraitBatch struct {
	generator.Dataloader[string, []coredb.User]
}

// newGetUsersWithTraitBatch creates a new GetUsersWithTraitBatch with the given settings, functions, and options
func newGetUsersWithTraitBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersWithTraitBatch, []string) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersWithTraitBatch {
	d := &GetUsersWithTraitBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetWalletByIDBatch batches and caches requests
type GetWalletByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Wallet]
}

// newGetWalletByIDBatch creates a new GetWalletByIDBatch with the given settings, functions, and options
func newGetWalletByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletByIDBatch, []persist.DBID) ([]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletByIDBatch {
	d := &GetWalletByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletByIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

func (*GetWalletByIDBatch) getKeyForResult(result coredb.Wallet) persist.DBID {
	return result.ID
}

// GetWalletsByUserIDBatch batches and caches requests
type GetWalletsByUserIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Wallet]
}

// newGetWalletsByUserIDBatch creates a new GetWalletsByUserIDBatch with the given settings, functions, and options
func newGetWalletsByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletsByUserIDBatch, []persist.DBID) ([][]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletsByUserIDBatch {
	d := &GetWalletsByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginateAdmiresByFeedEventIDBatch batches and caches requests
type PaginateAdmiresByFeedEventIDBatch struct {
	generator.Dataloader[coredb.PaginateAdmiresByFeedEventIDBatchParams, []coredb.Admire]
}

// newPaginateAdmiresByFeedEventIDBatch creates a new PaginateAdmiresByFeedEventIDBatch with the given settings, functions, and options
func newPaginateAdmiresByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateAdmiresByFeedEventIDBatch, []coredb.PaginateAdmiresByFeedEventIDBatchParams) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateAdmiresByFeedEventIDBatch {
	d := &PaginateAdmiresByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateAdmiresByFeedEventIDBatchParams) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateAdmiresByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateAdmiresByFeedEventIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginateAdmiresByPostIDBatch batches and caches requests
type PaginateAdmiresByPostIDBatch struct {
	generator.Dataloader[coredb.PaginateAdmiresByPostIDBatchParams, []coredb.Admire]
}

// newPaginateAdmiresByPostIDBatch creates a new PaginateAdmiresByPostIDBatch with the given settings, functions, and options
func newPaginateAdmiresByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateAdmiresByPostIDBatch, []coredb.PaginateAdmiresByPostIDBatchParams) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateAdmiresByPostIDBatch {
	d := &PaginateAdmiresByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateAdmiresByPostIDBatchParams) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateAdmiresByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateAdmiresByPostIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginateAdmiresByTokenIDBatch batches and caches requests
type PaginateAdmiresByTokenIDBatch struct {
	generator.Dataloader[coredb.PaginateAdmiresByTokenIDBatchParams, []coredb.Admire]
}

// newPaginateAdmiresByTokenIDBatch creates a new PaginateAdmiresByTokenIDBatch with the given settings, functions, and options
func newPaginateAdmiresByTokenIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateAdmiresByTokenIDBatch, []coredb.PaginateAdmiresByTokenIDBatchParams) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateAdmiresByTokenIDBatch {
	d := &PaginateAdmiresByTokenIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateAdmiresByTokenIDBatchParams) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateAdmiresByTokenIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateAdmiresByTokenIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginateCommentsByFeedEventIDBatch batches and caches requests
type PaginateCommentsByFeedEventIDBatch struct {
	generator.Dataloader[coredb.PaginateCommentsByFeedEventIDBatchParams, []coredb.Comment]
}

// newPaginateCommentsByFeedEventIDBatch creates a new PaginateCommentsByFeedEventIDBatch with the given settings, functions, and options
func newPaginateCommentsByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateCommentsByFeedEventIDBatch, []coredb.PaginateCommentsByFeedEventIDBatchParams) ([][]coredb.Comment, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateCommentsByFeedEventIDBatch {
	d := &PaginateCommentsByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateCommentsByFeedEventIDBatchParams) ([][]coredb.Comment, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateCommentsByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateCommentsByFeedEventIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginateCommentsByPostIDBatch batches and caches requests
type PaginateCommentsByPostIDBatch struct {
	generator.Dataloader[coredb.PaginateCommentsByPostIDBatchParams, []coredb.Comment]
}

// newPaginateCommentsByPostIDBatch creates a new PaginateCommentsByPostIDBatch with the given settings, functions, and options
func newPaginateCommentsByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateCommentsByPostIDBatch, []coredb.PaginateCommentsByPostIDBatchParams) ([][]coredb.Comment, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateCommentsByPostIDBatch {
	d := &PaginateCommentsByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateCommentsByPostIDBatchParams) ([][]coredb.Comment, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateCommentsByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateCommentsByPostIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginateInteractionsByFeedEventIDBatch batches and caches requests
type PaginateInteractionsByFeedEventIDBatch struct {
	generator.Dataloader[coredb.PaginateInteractionsByFeedEventIDBatchParams, []coredb.PaginateInteractionsByFeedEventIDBatchRow]
}

// newPaginateInteractionsByFeedEventIDBatch creates a new PaginateInteractionsByFeedEventIDBatch with the given settings, functions, and options
func newPaginateInteractionsByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateInteractionsByFeedEventIDBatch, []coredb.PaginateInteractionsByFeedEventIDBatchParams) ([][]coredb.PaginateInteractionsByFeedEventIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateInteractionsByFeedEventIDBatch {
	d := &PaginateInteractionsByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateInteractionsByFeedEventIDBatchParams) ([][]coredb.PaginateInteractionsByFeedEventIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateInteractionsByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateInteractionsByFeedEventIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginateInteractionsByPostIDBatch batches and caches requests
type PaginateInteractionsByPostIDBatch struct {
	generator.Dataloader[coredb.PaginateInteractionsByPostIDBatchParams, []coredb.PaginateInteractionsByPostIDBatchRow]
}

// newPaginateInteractionsByPostIDBatch creates a new PaginateInteractionsByPostIDBatch with the given settings, functions, and options
func newPaginateInteractionsByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateInteractionsByPostIDBatch, []coredb.PaginateInteractionsByPostIDBatchParams) ([][]coredb.PaginateInteractionsByPostIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateInteractionsByPostIDBatch {
	d := &PaginateInteractionsByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateInteractionsByPostIDBatchParams) ([][]coredb.PaginateInteractionsByPostIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateInteractionsByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateInteractionsByPostIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginatePostsByContractID batches and caches requests
type PaginatePostsByContractID struct {
	generator.Dataloader[coredb.PaginatePostsByContractIDParams, []coredb.Post]
}

// newPaginatePostsByContractID creates a new PaginatePostsByContractID with the given settings, functions, and options
func newPaginatePostsByContractID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginatePostsByContractID, []coredb.PaginatePostsByContractIDParams) ([][]coredb.Post, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginatePostsByContractID {
	d := &PaginatePostsByContractID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginatePostsByContractIDParams) ([][]coredb.Post, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginatePostsByContractID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginatePostsByContractID")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// PaginateRepliesByCommentIDBatch batches and caches requests
type PaginateRepliesByCommentIDBatch struct {
	generator.Dataloader[coredb.PaginateRepliesByCommentIDBatchParams, []coredb.Comment]
}

// newPaginateRepliesByCommentIDBatch creates a new PaginateRepliesByCommentIDBatch with the given settings, functions, and options
func newPaginateRepliesByCommentIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateRepliesByCommentIDBatch, []coredb.PaginateRepliesByCommentIDBatchParams) ([][]coredb.Comment, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateRepliesByCommentIDBatch {
	d := &PaginateRepliesByCommentIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateRepliesByCommentIDBatchParams) ([][]coredb.Comment, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateRepliesByCommentIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateRepliesByCommentIDBatch")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetContractCreatorsByIds batches and caches requests
type GetContractCreatorsByIds struct {
	generator.Dataloader[string, coredb.ContractCreator]
}

// newGetContractCreatorsByIds creates a new GetContractCreatorsByIds with the given settings, functions, and options
func newGetContractCreatorsByIds(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetContractCreatorsByIds, []string) ([]coredb.ContractCreator, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetContractCreatorsByIds {
	d := &GetContractCreatorsByIds{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.ContractCreator, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetContractCreatorsByIds")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetContractCreatorsByIds")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}

// GetContractsByIDs batches and caches requests
type GetContractsByIDs struct {
	generator.Dataloader[string, coredb.Contract]
}

// newGetContractsByIDs creates a new GetContractsByIDs with the given settings, functions, and options
func newGetContractsByIDs(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetContractsByIDs, []string) ([]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetContractsByIDs {
	d := &GetContractsByIDs{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetContractsByIDs")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetContractsByIDs")
		}

		return results, errors
	}

	dataloader := generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)

	d.Dataloader = *dataloader
	return d
}
