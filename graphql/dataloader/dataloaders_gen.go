// Code generated by github.com/mikeydub/go-gallery/cmd/dataloaders, DO NOT EDIT.

package dataloader

import (
	"context"
	"time"

	"github.com/mikeydub/go-gallery/cmd/dataloaders/generator"

	"github.com/mikeydub/go-gallery/service/persist"

	"github.com/mikeydub/go-gallery/db/gen/coredb"
)

type autoCacheWithKey[TKey any, TResult any] interface {
	getKeyForResult(TResult) TKey
}

type autoCacheWithKeys[TKey any, TResult any] interface {
	getKeysForResult(TResult) []TKey
}

type notFoundErrorProvider[TKey any] interface {
	getNotFoundError(TKey) error
}

type PreFetchHook func(context.Context, string) context.Context
type PostFetchHook func(context.Context, string)

// CountAdmiresByCommentIDBatch batches and caches requests
type CountAdmiresByCommentIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountAdmiresByCommentIDBatch creates a new CountAdmiresByCommentIDBatch with the given settings, functions, and options
func newCountAdmiresByCommentIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountAdmiresByCommentIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountAdmiresByCommentIDBatch {
	d := &CountAdmiresByCommentIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountAdmiresByCommentIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountAdmiresByCommentIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountAdmiresByFeedEventIDBatch batches and caches requests
type CountAdmiresByFeedEventIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountAdmiresByFeedEventIDBatch creates a new CountAdmiresByFeedEventIDBatch with the given settings, functions, and options
func newCountAdmiresByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountAdmiresByFeedEventIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountAdmiresByFeedEventIDBatch {
	d := &CountAdmiresByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountAdmiresByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountAdmiresByFeedEventIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountAdmiresByPostIDBatch batches and caches requests
type CountAdmiresByPostIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountAdmiresByPostIDBatch creates a new CountAdmiresByPostIDBatch with the given settings, functions, and options
func newCountAdmiresByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountAdmiresByPostIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountAdmiresByPostIDBatch {
	d := &CountAdmiresByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountAdmiresByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountAdmiresByPostIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountAdmiresByTokenIDBatch batches and caches requests
type CountAdmiresByTokenIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountAdmiresByTokenIDBatch creates a new CountAdmiresByTokenIDBatch with the given settings, functions, and options
func newCountAdmiresByTokenIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountAdmiresByTokenIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountAdmiresByTokenIDBatch {
	d := &CountAdmiresByTokenIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountAdmiresByTokenIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountAdmiresByTokenIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountCommentsByFeedEventIDBatch batches and caches requests
type CountCommentsByFeedEventIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountCommentsByFeedEventIDBatch creates a new CountCommentsByFeedEventIDBatch with the given settings, functions, and options
func newCountCommentsByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountCommentsByFeedEventIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountCommentsByFeedEventIDBatch {
	d := &CountCommentsByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountCommentsByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountCommentsByFeedEventIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountCommentsByPostIDBatch batches and caches requests
type CountCommentsByPostIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountCommentsByPostIDBatch creates a new CountCommentsByPostIDBatch with the given settings, functions, and options
func newCountCommentsByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountCommentsByPostIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountCommentsByPostIDBatch {
	d := &CountCommentsByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountCommentsByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountCommentsByPostIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountGalleriesDisplayingCommunityIDBatch batches and caches requests
type CountGalleriesDisplayingCommunityIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountGalleriesDisplayingCommunityIDBatch creates a new CountGalleriesDisplayingCommunityIDBatch with the given settings, functions, and options
func newCountGalleriesDisplayingCommunityIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountGalleriesDisplayingCommunityIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountGalleriesDisplayingCommunityIDBatch {
	d := &CountGalleriesDisplayingCommunityIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountGalleriesDisplayingCommunityIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountGalleriesDisplayingCommunityIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountInteractionsByFeedEventIDBatch batches and caches requests
type CountInteractionsByFeedEventIDBatch struct {
	generator.Dataloader[coredb.CountInteractionsByFeedEventIDBatchParams, []coredb.CountInteractionsByFeedEventIDBatchRow]
}

// newCountInteractionsByFeedEventIDBatch creates a new CountInteractionsByFeedEventIDBatch with the given settings, functions, and options
func newCountInteractionsByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountInteractionsByFeedEventIDBatch, []coredb.CountInteractionsByFeedEventIDBatchParams) ([][]coredb.CountInteractionsByFeedEventIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountInteractionsByFeedEventIDBatch {
	d := &CountInteractionsByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.CountInteractionsByFeedEventIDBatchParams) ([][]coredb.CountInteractionsByFeedEventIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountInteractionsByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountInteractionsByFeedEventIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountInteractionsByPostIDBatch batches and caches requests
type CountInteractionsByPostIDBatch struct {
	generator.Dataloader[coredb.CountInteractionsByPostIDBatchParams, []coredb.CountInteractionsByPostIDBatchRow]
}

// newCountInteractionsByPostIDBatch creates a new CountInteractionsByPostIDBatch with the given settings, functions, and options
func newCountInteractionsByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountInteractionsByPostIDBatch, []coredb.CountInteractionsByPostIDBatchParams) ([][]coredb.CountInteractionsByPostIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountInteractionsByPostIDBatch {
	d := &CountInteractionsByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.CountInteractionsByPostIDBatchParams) ([][]coredb.CountInteractionsByPostIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountInteractionsByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountInteractionsByPostIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// CountRepliesByCommentIDBatch batches and caches requests
type CountRepliesByCommentIDBatch struct {
	generator.Dataloader[persist.DBID, int64]
}

// newCountRepliesByCommentIDBatch creates a new CountRepliesByCommentIDBatch with the given settings, functions, and options
func newCountRepliesByCommentIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *CountRepliesByCommentIDBatch, []persist.DBID) ([]int64, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *CountRepliesByCommentIDBatch {
	d := &CountRepliesByCommentIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]int64, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "CountRepliesByCommentIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "CountRepliesByCommentIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetAdmireByActorIDAndCommentID batches and caches requests
type GetAdmireByActorIDAndCommentID struct {
	generator.Dataloader[coredb.GetAdmireByActorIDAndCommentIDParams, coredb.Admire]
}

// newGetAdmireByActorIDAndCommentID creates a new GetAdmireByActorIDAndCommentID with the given settings, functions, and options
func newGetAdmireByActorIDAndCommentID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByActorIDAndCommentID, []coredb.GetAdmireByActorIDAndCommentIDParams) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByActorIDAndCommentID {
	d := &GetAdmireByActorIDAndCommentID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetAdmireByActorIDAndCommentIDParams) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByActorIDAndCommentID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByActorIDAndCommentID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetAdmireByActorIDAndFeedEventID batches and caches requests
type GetAdmireByActorIDAndFeedEventID struct {
	generator.Dataloader[coredb.GetAdmireByActorIDAndFeedEventIDParams, coredb.Admire]
}

// newGetAdmireByActorIDAndFeedEventID creates a new GetAdmireByActorIDAndFeedEventID with the given settings, functions, and options
func newGetAdmireByActorIDAndFeedEventID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByActorIDAndFeedEventID, []coredb.GetAdmireByActorIDAndFeedEventIDParams) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByActorIDAndFeedEventID {
	d := &GetAdmireByActorIDAndFeedEventID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetAdmireByActorIDAndFeedEventIDParams) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByActorIDAndFeedEventID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByActorIDAndFeedEventID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetAdmireByActorIDAndPostID batches and caches requests
type GetAdmireByActorIDAndPostID struct {
	generator.Dataloader[coredb.GetAdmireByActorIDAndPostIDParams, coredb.Admire]
}

// newGetAdmireByActorIDAndPostID creates a new GetAdmireByActorIDAndPostID with the given settings, functions, and options
func newGetAdmireByActorIDAndPostID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByActorIDAndPostID, []coredb.GetAdmireByActorIDAndPostIDParams) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByActorIDAndPostID {
	d := &GetAdmireByActorIDAndPostID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetAdmireByActorIDAndPostIDParams) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByActorIDAndPostID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByActorIDAndPostID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetAdmireByActorIDAndTokenID batches and caches requests
type GetAdmireByActorIDAndTokenID struct {
	generator.Dataloader[coredb.GetAdmireByActorIDAndTokenIDParams, coredb.Admire]
}

// newGetAdmireByActorIDAndTokenID creates a new GetAdmireByActorIDAndTokenID with the given settings, functions, and options
func newGetAdmireByActorIDAndTokenID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByActorIDAndTokenID, []coredb.GetAdmireByActorIDAndTokenIDParams) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByActorIDAndTokenID {
	d := &GetAdmireByActorIDAndTokenID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetAdmireByActorIDAndTokenIDParams) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByActorIDAndTokenID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByActorIDAndTokenID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetAdmireByAdmireIDBatch batches and caches requests
type GetAdmireByAdmireIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Admire]
}

// newGetAdmireByAdmireIDBatch creates a new GetAdmireByAdmireIDBatch with the given settings, functions, and options
func newGetAdmireByAdmireIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmireByAdmireIDBatch, []persist.DBID) ([]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmireByAdmireIDBatch {
	d := &GetAdmireByAdmireIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmireByAdmireIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmireByAdmireIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetAdmireByAdmireIDBatch) getKeyForResult(result coredb.Admire) persist.DBID {
	return result.ID
}

// GetAdmiresByActorIDBatch batches and caches requests
type GetAdmiresByActorIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Admire]
}

// newGetAdmiresByActorIDBatch creates a new GetAdmiresByActorIDBatch with the given settings, functions, and options
func newGetAdmiresByActorIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAdmiresByActorIDBatch, []persist.DBID) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAdmiresByActorIDBatch {
	d := &GetAdmiresByActorIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAdmiresByActorIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAdmiresByActorIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetChildContractsByParentIDBatchPaginate batches and caches requests
type GetChildContractsByParentIDBatchPaginate struct {
	generator.Dataloader[coredb.GetChildContractsByParentIDBatchPaginateParams, []coredb.Contract]
}

// newGetChildContractsByParentIDBatchPaginate creates a new GetChildContractsByParentIDBatchPaginate with the given settings, functions, and options
func newGetChildContractsByParentIDBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetChildContractsByParentIDBatchPaginate, []coredb.GetChildContractsByParentIDBatchPaginateParams) ([][]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetChildContractsByParentIDBatchPaginate {
	d := &GetChildContractsByParentIDBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetChildContractsByParentIDBatchPaginateParams) ([][]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetChildContractsByParentIDBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetChildContractsByParentIDBatchPaginate")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetCollectionByIdBatch batches and caches requests
type GetCollectionByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Collection]
}

// newGetCollectionByIdBatch creates a new GetCollectionByIdBatch with the given settings, functions, and options
func newGetCollectionByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCollectionByIdBatch, []persist.DBID) ([]coredb.Collection, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCollectionByIdBatch {
	d := &GetCollectionByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Collection, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCollectionByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCollectionByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetCollectionByIdBatch) getKeyForResult(result coredb.Collection) persist.DBID {
	return result.ID
}

// GetCollectionsByGalleryIdBatch batches and caches requests
type GetCollectionsByGalleryIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Collection]
}

// newGetCollectionsByGalleryIdBatch creates a new GetCollectionsByGalleryIdBatch with the given settings, functions, and options
func newGetCollectionsByGalleryIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCollectionsByGalleryIdBatch, []persist.DBID) ([][]coredb.Collection, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCollectionsByGalleryIdBatch {
	d := &GetCollectionsByGalleryIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Collection, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCollectionsByGalleryIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCollectionsByGalleryIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetCommentByCommentIDBatch batches and caches requests
type GetCommentByCommentIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Comment]
}

// newGetCommentByCommentIDBatch creates a new GetCommentByCommentIDBatch with the given settings, functions, and options
func newGetCommentByCommentIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCommentByCommentIDBatch, []persist.DBID) ([]coredb.Comment, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCommentByCommentIDBatch {
	d := &GetCommentByCommentIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Comment, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCommentByCommentIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCommentByCommentIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetCommentByCommentIDBatch) getKeyForResult(result coredb.Comment) persist.DBID {
	return result.ID
}

// GetCommunitiesByTokenDefinitionID batches and caches requests
type GetCommunitiesByTokenDefinitionID struct {
	generator.Dataloader[persist.DBID, []coredb.Community]
}

// newGetCommunitiesByTokenDefinitionID creates a new GetCommunitiesByTokenDefinitionID with the given settings, functions, and options
func newGetCommunitiesByTokenDefinitionID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCommunitiesByTokenDefinitionID, []persist.DBID) ([][]coredb.Community, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCommunitiesByTokenDefinitionID {
	d := &GetCommunitiesByTokenDefinitionID{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Community, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCommunitiesByTokenDefinitionID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCommunitiesByTokenDefinitionID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetCommunityByIDBatch batches and caches requests
type GetCommunityByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Community]
}

// newGetCommunityByIDBatch creates a new GetCommunityByIDBatch with the given settings, functions, and options
func newGetCommunityByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCommunityByIDBatch, []persist.DBID) ([]coredb.Community, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCommunityByIDBatch {
	d := &GetCommunityByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Community, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCommunityByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCommunityByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetCommunityByIDBatch) getKeyForResult(result coredb.Community) persist.DBID {
	return result.ID
}

// GetCommunityByKey batches and caches requests
type GetCommunityByKey struct {
	generator.Dataloader[coredb.GetCommunityByKeyParams, coredb.Community]
}

// newGetCommunityByKey creates a new GetCommunityByKey with the given settings, functions, and options
func newGetCommunityByKey(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCommunityByKey, []coredb.GetCommunityByKeyParams) ([]coredb.Community, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCommunityByKey {
	d := &GetCommunityByKey{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetCommunityByKeyParams) ([]coredb.Community, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCommunityByKey")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCommunityByKey")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetContractByChainAddressBatch batches and caches requests
type GetContractByChainAddressBatch struct {
	generator.Dataloader[coredb.GetContractByChainAddressBatchParams, coredb.Contract]
}

// newGetContractByChainAddressBatch creates a new GetContractByChainAddressBatch with the given settings, functions, and options
func newGetContractByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetContractByChainAddressBatch, []coredb.GetContractByChainAddressBatchParams) ([]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetContractByChainAddressBatch {
	d := &GetContractByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetContractByChainAddressBatchParams) ([]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetContractByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetContractByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetContractsDisplayedByUserIDBatch batches and caches requests
type GetContractsDisplayedByUserIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Contract]
}

// newGetContractsDisplayedByUserIDBatch creates a new GetContractsDisplayedByUserIDBatch with the given settings, functions, and options
func newGetContractsDisplayedByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetContractsDisplayedByUserIDBatch, []persist.DBID) ([][]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetContractsDisplayedByUserIDBatch {
	d := &GetContractsDisplayedByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetContractsDisplayedByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetContractsDisplayedByUserIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetCreatedContractsBatchPaginate batches and caches requests
type GetCreatedContractsBatchPaginate struct {
	generator.Dataloader[coredb.GetCreatedContractsBatchPaginateParams, []coredb.Contract]
}

// newGetCreatedContractsBatchPaginate creates a new GetCreatedContractsBatchPaginate with the given settings, functions, and options
func newGetCreatedContractsBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCreatedContractsBatchPaginate, []coredb.GetCreatedContractsBatchPaginateParams) ([][]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCreatedContractsBatchPaginate {
	d := &GetCreatedContractsBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetCreatedContractsBatchPaginateParams) ([][]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCreatedContractsBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCreatedContractsBatchPaginate")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetCreatorsByCommunityID batches and caches requests
type GetCreatorsByCommunityID struct {
	generator.Dataloader[persist.DBID, []coredb.GetCreatorsByCommunityIDRow]
}

// newGetCreatorsByCommunityID creates a new GetCreatorsByCommunityID with the given settings, functions, and options
func newGetCreatorsByCommunityID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetCreatorsByCommunityID, []persist.DBID) ([][]coredb.GetCreatorsByCommunityIDRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetCreatorsByCommunityID {
	d := &GetCreatorsByCommunityID{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.GetCreatorsByCommunityIDRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetCreatorsByCommunityID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetCreatorsByCommunityID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetEventByIdBatch batches and caches requests
type GetEventByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.FeedEvent]
}

// newGetEventByIdBatch creates a new GetEventByIdBatch with the given settings, functions, and options
func newGetEventByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetEventByIdBatch, []persist.DBID) ([]coredb.FeedEvent, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetEventByIdBatch {
	d := &GetEventByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.FeedEvent, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetEventByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetEventByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetEventByIdBatch) getKeyForResult(result coredb.FeedEvent) persist.DBID {
	return result.ID
}

// GetFollowersByUserIdBatch batches and caches requests
type GetFollowersByUserIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.User]
}

// newGetFollowersByUserIdBatch creates a new GetFollowersByUserIdBatch with the given settings, functions, and options
func newGetFollowersByUserIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetFollowersByUserIdBatch, []persist.DBID) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetFollowersByUserIdBatch {
	d := &GetFollowersByUserIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetFollowersByUserIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetFollowersByUserIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetFollowingByUserIdBatch batches and caches requests
type GetFollowingByUserIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.User]
}

// newGetFollowingByUserIdBatch creates a new GetFollowingByUserIdBatch with the given settings, functions, and options
func newGetFollowingByUserIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetFollowingByUserIdBatch, []persist.DBID) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetFollowingByUserIdBatch {
	d := &GetFollowingByUserIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetFollowingByUserIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetFollowingByUserIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetFrameTokensByCommunityID batches and caches requests
type GetFrameTokensByCommunityID struct {
	generator.Dataloader[coredb.GetFrameTokensByCommunityIDParams, []coredb.GetFrameTokensByCommunityIDRow]
}

// newGetFrameTokensByCommunityID creates a new GetFrameTokensByCommunityID with the given settings, functions, and options
func newGetFrameTokensByCommunityID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetFrameTokensByCommunityID, []coredb.GetFrameTokensByCommunityIDParams) ([][]coredb.GetFrameTokensByCommunityIDRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetFrameTokensByCommunityID {
	d := &GetFrameTokensByCommunityID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetFrameTokensByCommunityIDParams) ([][]coredb.GetFrameTokensByCommunityIDRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetFrameTokensByCommunityID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetFrameTokensByCommunityID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetGalleriesByUserIdBatch batches and caches requests
type GetGalleriesByUserIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Gallery]
}

// newGetGalleriesByUserIdBatch creates a new GetGalleriesByUserIdBatch with the given settings, functions, and options
func newGetGalleriesByUserIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleriesByUserIdBatch, []persist.DBID) ([][]coredb.Gallery, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleriesByUserIdBatch {
	d := &GetGalleriesByUserIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Gallery, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleriesByUserIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleriesByUserIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetGalleriesDisplayingCommunityIDPaginateBatch batches and caches requests
type GetGalleriesDisplayingCommunityIDPaginateBatch struct {
	generator.Dataloader[coredb.GetGalleriesDisplayingCommunityIDPaginateBatchParams, []coredb.GetGalleriesDisplayingCommunityIDPaginateBatchRow]
}

// newGetGalleriesDisplayingCommunityIDPaginateBatch creates a new GetGalleriesDisplayingCommunityIDPaginateBatch with the given settings, functions, and options
func newGetGalleriesDisplayingCommunityIDPaginateBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleriesDisplayingCommunityIDPaginateBatch, []coredb.GetGalleriesDisplayingCommunityIDPaginateBatchParams) ([][]coredb.GetGalleriesDisplayingCommunityIDPaginateBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleriesDisplayingCommunityIDPaginateBatch {
	d := &GetGalleriesDisplayingCommunityIDPaginateBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetGalleriesDisplayingCommunityIDPaginateBatchParams) ([][]coredb.GetGalleriesDisplayingCommunityIDPaginateBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleriesDisplayingCommunityIDPaginateBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleriesDisplayingCommunityIDPaginateBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetGalleryByCollectionIdBatch batches and caches requests
type GetGalleryByCollectionIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Gallery]
}

// newGetGalleryByCollectionIdBatch creates a new GetGalleryByCollectionIdBatch with the given settings, functions, and options
func newGetGalleryByCollectionIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleryByCollectionIdBatch, []persist.DBID) ([]coredb.Gallery, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleryByCollectionIdBatch {
	d := &GetGalleryByCollectionIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Gallery, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleryByCollectionIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleryByCollectionIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetGalleryByCollectionIdBatch) getKeyForResult(result coredb.Gallery) persist.DBID {
	return result.ID
}

// GetGalleryByIdBatch batches and caches requests
type GetGalleryByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Gallery]
}

// newGetGalleryByIdBatch creates a new GetGalleryByIdBatch with the given settings, functions, and options
func newGetGalleryByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleryByIdBatch, []persist.DBID) ([]coredb.Gallery, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleryByIdBatch {
	d := &GetGalleryByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Gallery, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleryByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleryByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetGalleryByIdBatch) getKeyForResult(result coredb.Gallery) persist.DBID {
	return result.ID
}

// GetGalleryTokenMediasByGalleryIDBatch batches and caches requests
type GetGalleryTokenMediasByGalleryIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.TokenMedia]
}

// newGetGalleryTokenMediasByGalleryIDBatch creates a new GetGalleryTokenMediasByGalleryIDBatch with the given settings, functions, and options
func newGetGalleryTokenMediasByGalleryIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetGalleryTokenMediasByGalleryIDBatch, []persist.DBID) ([][]coredb.TokenMedia, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetGalleryTokenMediasByGalleryIDBatch {
	d := &GetGalleryTokenMediasByGalleryIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.TokenMedia, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetGalleryTokenMediasByGalleryIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetGalleryTokenMediasByGalleryIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetMediaByMediaIdIgnoringStatusBatch batches and caches requests
type GetMediaByMediaIdIgnoringStatusBatch struct {
	generator.Dataloader[persist.DBID, coredb.TokenMedia]
}

// newGetMediaByMediaIdIgnoringStatusBatch creates a new GetMediaByMediaIdIgnoringStatusBatch with the given settings, functions, and options
func newGetMediaByMediaIdIgnoringStatusBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetMediaByMediaIdIgnoringStatusBatch, []persist.DBID) ([]coredb.TokenMedia, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetMediaByMediaIdIgnoringStatusBatch {
	d := &GetMediaByMediaIdIgnoringStatusBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.TokenMedia, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetMediaByMediaIdIgnoringStatusBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetMediaByMediaIdIgnoringStatusBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetMediaByMediaIdIgnoringStatusBatch) getKeyForResult(result coredb.TokenMedia) persist.DBID {
	return result.ID
}

// GetMembershipByMembershipIdBatch batches and caches requests
type GetMembershipByMembershipIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Membership]
}

// newGetMembershipByMembershipIdBatch creates a new GetMembershipByMembershipIdBatch with the given settings, functions, and options
func newGetMembershipByMembershipIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetMembershipByMembershipIdBatch, []persist.DBID) ([]coredb.Membership, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetMembershipByMembershipIdBatch {
	d := &GetMembershipByMembershipIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Membership, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetMembershipByMembershipIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetMembershipByMembershipIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetMembershipByMembershipIdBatch) getKeyForResult(result coredb.Membership) persist.DBID {
	return result.ID
}

// GetMentionsByCommentID batches and caches requests
type GetMentionsByCommentID struct {
	generator.Dataloader[persist.DBID, []coredb.Mention]
}

// newGetMentionsByCommentID creates a new GetMentionsByCommentID with the given settings, functions, and options
func newGetMentionsByCommentID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetMentionsByCommentID, []persist.DBID) ([][]coredb.Mention, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetMentionsByCommentID {
	d := &GetMentionsByCommentID{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Mention, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetMentionsByCommentID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetMentionsByCommentID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetMentionsByPostID batches and caches requests
type GetMentionsByPostID struct {
	generator.Dataloader[persist.DBID, []coredb.Mention]
}

// newGetMentionsByPostID creates a new GetMentionsByPostID with the given settings, functions, and options
func newGetMentionsByPostID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetMentionsByPostID, []persist.DBID) ([][]coredb.Mention, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetMentionsByPostID {
	d := &GetMentionsByPostID{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Mention, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetMentionsByPostID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetMentionsByPostID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetNewTokensByFeedEventIdBatch batches and caches requests
type GetNewTokensByFeedEventIdBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Token]
}

// newGetNewTokensByFeedEventIdBatch creates a new GetNewTokensByFeedEventIdBatch with the given settings, functions, and options
func newGetNewTokensByFeedEventIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetNewTokensByFeedEventIdBatch, []persist.DBID) ([][]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetNewTokensByFeedEventIdBatch {
	d := &GetNewTokensByFeedEventIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetNewTokensByFeedEventIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetNewTokensByFeedEventIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetNotificationByIDBatch batches and caches requests
type GetNotificationByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Notification]
}

// newGetNotificationByIDBatch creates a new GetNotificationByIDBatch with the given settings, functions, and options
func newGetNotificationByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetNotificationByIDBatch, []persist.DBID) ([]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetNotificationByIDBatch {
	d := &GetNotificationByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetNotificationByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetNotificationByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetNotificationByIDBatch) getKeyForResult(result coredb.Notification) persist.DBID {
	return result.ID
}

// GetOwnersByContractIdBatchPaginate batches and caches requests
type GetOwnersByContractIdBatchPaginate struct {
	generator.Dataloader[coredb.GetOwnersByContractIdBatchPaginateParams, []coredb.User]
}

// newGetOwnersByContractIdBatchPaginate creates a new GetOwnersByContractIdBatchPaginate with the given settings, functions, and options
func newGetOwnersByContractIdBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetOwnersByContractIdBatchPaginate, []coredb.GetOwnersByContractIdBatchPaginateParams) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetOwnersByContractIdBatchPaginate {
	d := &GetOwnersByContractIdBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetOwnersByContractIdBatchPaginateParams) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetOwnersByContractIdBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetOwnersByContractIdBatchPaginate")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetPostByIdBatch batches and caches requests
type GetPostByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Post]
}

// newGetPostByIdBatch creates a new GetPostByIdBatch with the given settings, functions, and options
func newGetPostByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetPostByIdBatch, []persist.DBID) ([]coredb.Post, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetPostByIdBatch {
	d := &GetPostByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Post, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetPostByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetPostByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetPostByIdBatch) getKeyForResult(result coredb.Post) persist.DBID {
	return result.ID
}

// GetPostsByIdsPaginateBatch batches and caches requests
type GetPostsByIdsPaginateBatch struct {
	generator.Dataloader[coredb.GetPostsByIdsPaginateBatchParams, []coredb.Post]
}

// newGetPostsByIdsPaginateBatch creates a new GetPostsByIdsPaginateBatch with the given settings, functions, and options
func newGetPostsByIdsPaginateBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetPostsByIdsPaginateBatch, []coredb.GetPostsByIdsPaginateBatchParams) ([][]coredb.Post, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetPostsByIdsPaginateBatch {
	d := &GetPostsByIdsPaginateBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetPostsByIdsPaginateBatchParams) ([][]coredb.Post, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetPostsByIdsPaginateBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetPostsByIdsPaginateBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetProfileImageByIdBatch batches and caches requests
type GetProfileImageByIdBatch struct {
	generator.Dataloader[coredb.GetProfileImageByIdBatchParams, coredb.ProfileImage]
}

// newGetProfileImageByIdBatch creates a new GetProfileImageByIdBatch with the given settings, functions, and options
func newGetProfileImageByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetProfileImageByIdBatch, []coredb.GetProfileImageByIdBatchParams) ([]coredb.ProfileImage, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetProfileImageByIdBatch {
	d := &GetProfileImageByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetProfileImageByIdBatchParams) ([]coredb.ProfileImage, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetProfileImageByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetProfileImageByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetSharedCommunitiesBatchPaginate batches and caches requests
type GetSharedCommunitiesBatchPaginate struct {
	generator.Dataloader[coredb.GetSharedCommunitiesBatchPaginateParams, []coredb.GetSharedCommunitiesBatchPaginateRow]
}

// newGetSharedCommunitiesBatchPaginate creates a new GetSharedCommunitiesBatchPaginate with the given settings, functions, and options
func newGetSharedCommunitiesBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSharedCommunitiesBatchPaginate, []coredb.GetSharedCommunitiesBatchPaginateParams) ([][]coredb.GetSharedCommunitiesBatchPaginateRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSharedCommunitiesBatchPaginate {
	d := &GetSharedCommunitiesBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetSharedCommunitiesBatchPaginateParams) ([][]coredb.GetSharedCommunitiesBatchPaginateRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSharedCommunitiesBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSharedCommunitiesBatchPaginate")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetSharedFollowersBatchPaginate batches and caches requests
type GetSharedFollowersBatchPaginate struct {
	generator.Dataloader[coredb.GetSharedFollowersBatchPaginateParams, []coredb.GetSharedFollowersBatchPaginateRow]
}

// newGetSharedFollowersBatchPaginate creates a new GetSharedFollowersBatchPaginate with the given settings, functions, and options
func newGetSharedFollowersBatchPaginate(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSharedFollowersBatchPaginate, []coredb.GetSharedFollowersBatchPaginateParams) ([][]coredb.GetSharedFollowersBatchPaginateRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSharedFollowersBatchPaginate {
	d := &GetSharedFollowersBatchPaginate{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetSharedFollowersBatchPaginateParams) ([][]coredb.GetSharedFollowersBatchPaginateRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSharedFollowersBatchPaginate")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSharedFollowersBatchPaginate")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokenByIdBatch batches and caches requests
type GetTokenByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.GetTokenByIdBatchRow]
}

// newGetTokenByIdBatch creates a new GetTokenByIdBatch with the given settings, functions, and options
func newGetTokenByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByIdBatch, []persist.DBID) ([]coredb.GetTokenByIdBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByIdBatch {
	d := &GetTokenByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.GetTokenByIdBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokenByIdIgnoreDisplayableBatch batches and caches requests
type GetTokenByIdIgnoreDisplayableBatch struct {
	generator.Dataloader[persist.DBID, coredb.GetTokenByIdIgnoreDisplayableBatchRow]
}

// newGetTokenByIdIgnoreDisplayableBatch creates a new GetTokenByIdIgnoreDisplayableBatch with the given settings, functions, and options
func newGetTokenByIdIgnoreDisplayableBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByIdIgnoreDisplayableBatch, []persist.DBID) ([]coredb.GetTokenByIdIgnoreDisplayableBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByIdIgnoreDisplayableBatch {
	d := &GetTokenByIdIgnoreDisplayableBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.GetTokenByIdIgnoreDisplayableBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByIdIgnoreDisplayableBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByIdIgnoreDisplayableBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokenByUserTokenIdentifiersBatch batches and caches requests
type GetTokenByUserTokenIdentifiersBatch struct {
	generator.Dataloader[coredb.GetTokenByUserTokenIdentifiersBatchParams, coredb.GetTokenByUserTokenIdentifiersBatchRow]
}

// newGetTokenByUserTokenIdentifiersBatch creates a new GetTokenByUserTokenIdentifiersBatch with the given settings, functions, and options
func newGetTokenByUserTokenIdentifiersBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByUserTokenIdentifiersBatch, []coredb.GetTokenByUserTokenIdentifiersBatchParams) ([]coredb.GetTokenByUserTokenIdentifiersBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByUserTokenIdentifiersBatch {
	d := &GetTokenByUserTokenIdentifiersBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokenByUserTokenIdentifiersBatchParams) ([]coredb.GetTokenByUserTokenIdentifiersBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByUserTokenIdentifiersBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByUserTokenIdentifiersBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokenByUserTokenIdentifiersIgnoreDisplayableBatch batches and caches requests
type GetTokenByUserTokenIdentifiersIgnoreDisplayableBatch struct {
	generator.Dataloader[coredb.GetTokenByUserTokenIdentifiersIgnoreDisplayableBatchParams, coredb.GetTokenByUserTokenIdentifiersIgnoreDisplayableBatchRow]
}

// newGetTokenByUserTokenIdentifiersIgnoreDisplayableBatch creates a new GetTokenByUserTokenIdentifiersIgnoreDisplayableBatch with the given settings, functions, and options
func newGetTokenByUserTokenIdentifiersIgnoreDisplayableBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByUserTokenIdentifiersIgnoreDisplayableBatch, []coredb.GetTokenByUserTokenIdentifiersIgnoreDisplayableBatchParams) ([]coredb.GetTokenByUserTokenIdentifiersIgnoreDisplayableBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByUserTokenIdentifiersIgnoreDisplayableBatch {
	d := &GetTokenByUserTokenIdentifiersIgnoreDisplayableBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokenByUserTokenIdentifiersIgnoreDisplayableBatchParams) ([]coredb.GetTokenByUserTokenIdentifiersIgnoreDisplayableBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByUserTokenIdentifiersIgnoreDisplayableBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByUserTokenIdentifiersIgnoreDisplayableBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokenDefinitionByIdBatch batches and caches requests
type GetTokenDefinitionByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.TokenDefinition]
}

// newGetTokenDefinitionByIdBatch creates a new GetTokenDefinitionByIdBatch with the given settings, functions, and options
func newGetTokenDefinitionByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenDefinitionByIdBatch, []persist.DBID) ([]coredb.TokenDefinition, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenDefinitionByIdBatch {
	d := &GetTokenDefinitionByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.TokenDefinition, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenDefinitionByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenDefinitionByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetTokenDefinitionByIdBatch) getKeyForResult(result coredb.TokenDefinition) persist.DBID {
	return result.ID
}

// GetTokensByCollectionIdBatch batches and caches requests
type GetTokensByCollectionIdBatch struct {
	generator.Dataloader[coredb.GetTokensByCollectionIdBatchParams, []coredb.Token]
}

// newGetTokensByCollectionIdBatch creates a new GetTokensByCollectionIdBatch with the given settings, functions, and options
func newGetTokensByCollectionIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByCollectionIdBatch, []coredb.GetTokensByCollectionIdBatchParams) ([][]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByCollectionIdBatch {
	d := &GetTokensByCollectionIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokensByCollectionIdBatchParams) ([][]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByCollectionIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByCollectionIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokensByUserIdBatch batches and caches requests
type GetTokensByUserIdBatch struct {
	generator.Dataloader[coredb.GetTokensByUserIdBatchParams, []coredb.GetTokensByUserIdBatchRow]
}

// newGetTokensByUserIdBatch creates a new GetTokensByUserIdBatch with the given settings, functions, and options
func newGetTokensByUserIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByUserIdBatch, []coredb.GetTokensByUserIdBatchParams) ([][]coredb.GetTokensByUserIdBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByUserIdBatch {
	d := &GetTokensByUserIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokensByUserIdBatchParams) ([][]coredb.GetTokensByUserIdBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByUserIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByUserIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokensByWalletIdsBatch batches and caches requests
type GetTokensByWalletIdsBatch struct {
	generator.Dataloader[persist.DBIDList, []coredb.GetTokensByWalletIdsBatchRow]
}

// newGetTokensByWalletIdsBatch creates a new GetTokensByWalletIdsBatch with the given settings, functions, and options
func newGetTokensByWalletIdsBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByWalletIdsBatch, []persist.DBIDList) ([][]coredb.GetTokensByWalletIdsBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByWalletIdsBatch {
	d := &GetTokensByWalletIdsBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBIDList) ([][]coredb.GetTokensByWalletIdsBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByWalletIdsBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByWalletIdsBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserByAddressAndL1Batch batches and caches requests
type GetUserByAddressAndL1Batch struct {
	generator.Dataloader[coredb.GetUserByAddressAndL1BatchParams, coredb.User]
}

// newGetUserByAddressAndL1Batch creates a new GetUserByAddressAndL1Batch with the given settings, functions, and options
func newGetUserByAddressAndL1Batch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByAddressAndL1Batch, []coredb.GetUserByAddressAndL1BatchParams) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByAddressAndL1Batch {
	d := &GetUserByAddressAndL1Batch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserByAddressAndL1BatchParams) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByAddressAndL1Batch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByAddressAndL1Batch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserByIdBatch batches and caches requests
type GetUserByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.User]
}

// newGetUserByIdBatch creates a new GetUserByIdBatch with the given settings, functions, and options
func newGetUserByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByIdBatch, []persist.DBID) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByIdBatch {
	d := &GetUserByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetUserByIdBatch) getKeyForResult(result coredb.User) persist.DBID {
	return result.ID
}

// GetUserByUsernameBatch batches and caches requests
type GetUserByUsernameBatch struct {
	generator.Dataloader[string, coredb.User]
}

// newGetUserByUsernameBatch creates a new GetUserByUsernameBatch with the given settings, functions, and options
func newGetUserByUsernameBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByUsernameBatch, []string) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByUsernameBatch {
	d := &GetUserByUsernameBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByUsernameBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByUsernameBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserNotificationsBatch batches and caches requests
type GetUserNotificationsBatch struct {
	generator.Dataloader[coredb.GetUserNotificationsBatchParams, []coredb.Notification]
}

// newGetUserNotificationsBatch creates a new GetUserNotificationsBatch with the given settings, functions, and options
func newGetUserNotificationsBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserNotificationsBatch, []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserNotificationsBatch {
	d := &GetUserNotificationsBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserNotificationsBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserNotificationsBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersByPositionPaginateBatch batches and caches requests
type GetUsersByPositionPaginateBatch struct {
	generator.Dataloader[coredb.GetUsersByPositionPaginateBatchParams, []coredb.User]
}

// newGetUsersByPositionPaginateBatch creates a new GetUsersByPositionPaginateBatch with the given settings, functions, and options
func newGetUsersByPositionPaginateBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersByPositionPaginateBatch, []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersByPositionPaginateBatch {
	d := &GetUsersByPositionPaginateBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersByPositionPaginateBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersByPositionPaginateBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersByPositionPersonalizedBatch batches and caches requests
type GetUsersByPositionPersonalizedBatch struct {
	generator.Dataloader[coredb.GetUsersByPositionPersonalizedBatchParams, []coredb.User]
}

// newGetUsersByPositionPersonalizedBatch creates a new GetUsersByPositionPersonalizedBatch with the given settings, functions, and options
func newGetUsersByPositionPersonalizedBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersByPositionPersonalizedBatch, []coredb.GetUsersByPositionPersonalizedBatchParams) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersByPositionPersonalizedBatch {
	d := &GetUsersByPositionPersonalizedBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUsersByPositionPersonalizedBatchParams) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersByPositionPersonalizedBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersByPositionPersonalizedBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersWithTraitBatch batches and caches requests
type GetUsersWithTraitBatch struct {
	generator.Dataloader[string, []coredb.User]
}

// newGetUsersWithTraitBatch creates a new GetUsersWithTraitBatch with the given settings, functions, and options
func newGetUsersWithTraitBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersWithTraitBatch, []string) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersWithTraitBatch {
	d := &GetUsersWithTraitBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetVisibleCollectionsByIDsPaginateBatch batches and caches requests
type GetVisibleCollectionsByIDsPaginateBatch struct {
	generator.Dataloader[coredb.GetVisibleCollectionsByIDsPaginateBatchParams, []coredb.Collection]
}

// newGetVisibleCollectionsByIDsPaginateBatch creates a new GetVisibleCollectionsByIDsPaginateBatch with the given settings, functions, and options
func newGetVisibleCollectionsByIDsPaginateBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetVisibleCollectionsByIDsPaginateBatch, []coredb.GetVisibleCollectionsByIDsPaginateBatchParams) ([][]coredb.Collection, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetVisibleCollectionsByIDsPaginateBatch {
	d := &GetVisibleCollectionsByIDsPaginateBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetVisibleCollectionsByIDsPaginateBatchParams) ([][]coredb.Collection, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetVisibleCollectionsByIDsPaginateBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetVisibleCollectionsByIDsPaginateBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetWalletByIDBatch batches and caches requests
type GetWalletByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Wallet]
}

// newGetWalletByIDBatch creates a new GetWalletByIDBatch with the given settings, functions, and options
func newGetWalletByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletByIDBatch, []persist.DBID) ([]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletByIDBatch {
	d := &GetWalletByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetWalletByIDBatch) getKeyForResult(result coredb.Wallet) persist.DBID {
	return result.ID
}

// GetWalletsByUserIDBatch batches and caches requests
type GetWalletsByUserIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Wallet]
}

// newGetWalletsByUserIDBatch creates a new GetWalletsByUserIDBatch with the given settings, functions, and options
func newGetWalletsByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletsByUserIDBatch, []persist.DBID) ([][]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletsByUserIDBatch {
	d := &GetWalletsByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateAdmiresByCommentIDBatch batches and caches requests
type PaginateAdmiresByCommentIDBatch struct {
	generator.Dataloader[coredb.PaginateAdmiresByCommentIDBatchParams, []coredb.Admire]
}

// newPaginateAdmiresByCommentIDBatch creates a new PaginateAdmiresByCommentIDBatch with the given settings, functions, and options
func newPaginateAdmiresByCommentIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateAdmiresByCommentIDBatch, []coredb.PaginateAdmiresByCommentIDBatchParams) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateAdmiresByCommentIDBatch {
	d := &PaginateAdmiresByCommentIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateAdmiresByCommentIDBatchParams) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateAdmiresByCommentIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateAdmiresByCommentIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateAdmiresByFeedEventIDBatch batches and caches requests
type PaginateAdmiresByFeedEventIDBatch struct {
	generator.Dataloader[coredb.PaginateAdmiresByFeedEventIDBatchParams, []coredb.Admire]
}

// newPaginateAdmiresByFeedEventIDBatch creates a new PaginateAdmiresByFeedEventIDBatch with the given settings, functions, and options
func newPaginateAdmiresByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateAdmiresByFeedEventIDBatch, []coredb.PaginateAdmiresByFeedEventIDBatchParams) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateAdmiresByFeedEventIDBatch {
	d := &PaginateAdmiresByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateAdmiresByFeedEventIDBatchParams) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateAdmiresByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateAdmiresByFeedEventIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateAdmiresByPostIDBatch batches and caches requests
type PaginateAdmiresByPostIDBatch struct {
	generator.Dataloader[coredb.PaginateAdmiresByPostIDBatchParams, []coredb.Admire]
}

// newPaginateAdmiresByPostIDBatch creates a new PaginateAdmiresByPostIDBatch with the given settings, functions, and options
func newPaginateAdmiresByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateAdmiresByPostIDBatch, []coredb.PaginateAdmiresByPostIDBatchParams) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateAdmiresByPostIDBatch {
	d := &PaginateAdmiresByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateAdmiresByPostIDBatchParams) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateAdmiresByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateAdmiresByPostIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateAdmiresByTokenIDBatch batches and caches requests
type PaginateAdmiresByTokenIDBatch struct {
	generator.Dataloader[coredb.PaginateAdmiresByTokenIDBatchParams, []coredb.Admire]
}

// newPaginateAdmiresByTokenIDBatch creates a new PaginateAdmiresByTokenIDBatch with the given settings, functions, and options
func newPaginateAdmiresByTokenIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateAdmiresByTokenIDBatch, []coredb.PaginateAdmiresByTokenIDBatchParams) ([][]coredb.Admire, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateAdmiresByTokenIDBatch {
	d := &PaginateAdmiresByTokenIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateAdmiresByTokenIDBatchParams) ([][]coredb.Admire, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateAdmiresByTokenIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateAdmiresByTokenIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateCommentsByFeedEventIDBatch batches and caches requests
type PaginateCommentsByFeedEventIDBatch struct {
	generator.Dataloader[coredb.PaginateCommentsByFeedEventIDBatchParams, []coredb.Comment]
}

// newPaginateCommentsByFeedEventIDBatch creates a new PaginateCommentsByFeedEventIDBatch with the given settings, functions, and options
func newPaginateCommentsByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateCommentsByFeedEventIDBatch, []coredb.PaginateCommentsByFeedEventIDBatchParams) ([][]coredb.Comment, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateCommentsByFeedEventIDBatch {
	d := &PaginateCommentsByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateCommentsByFeedEventIDBatchParams) ([][]coredb.Comment, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateCommentsByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateCommentsByFeedEventIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateCommentsByPostIDBatch batches and caches requests
type PaginateCommentsByPostIDBatch struct {
	generator.Dataloader[coredb.PaginateCommentsByPostIDBatchParams, []coredb.Comment]
}

// newPaginateCommentsByPostIDBatch creates a new PaginateCommentsByPostIDBatch with the given settings, functions, and options
func newPaginateCommentsByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateCommentsByPostIDBatch, []coredb.PaginateCommentsByPostIDBatchParams) ([][]coredb.Comment, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateCommentsByPostIDBatch {
	d := &PaginateCommentsByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateCommentsByPostIDBatchParams) ([][]coredb.Comment, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateCommentsByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateCommentsByPostIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateHoldersByCommunityID batches and caches requests
type PaginateHoldersByCommunityID struct {
	generator.Dataloader[coredb.PaginateHoldersByCommunityIDParams, []coredb.User]
}

// newPaginateHoldersByCommunityID creates a new PaginateHoldersByCommunityID with the given settings, functions, and options
func newPaginateHoldersByCommunityID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateHoldersByCommunityID, []coredb.PaginateHoldersByCommunityIDParams) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateHoldersByCommunityID {
	d := &PaginateHoldersByCommunityID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateHoldersByCommunityIDParams) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateHoldersByCommunityID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateHoldersByCommunityID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateInteractionsByFeedEventIDBatch batches and caches requests
type PaginateInteractionsByFeedEventIDBatch struct {
	generator.Dataloader[coredb.PaginateInteractionsByFeedEventIDBatchParams, []coredb.PaginateInteractionsByFeedEventIDBatchRow]
}

// newPaginateInteractionsByFeedEventIDBatch creates a new PaginateInteractionsByFeedEventIDBatch with the given settings, functions, and options
func newPaginateInteractionsByFeedEventIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateInteractionsByFeedEventIDBatch, []coredb.PaginateInteractionsByFeedEventIDBatchParams) ([][]coredb.PaginateInteractionsByFeedEventIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateInteractionsByFeedEventIDBatch {
	d := &PaginateInteractionsByFeedEventIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateInteractionsByFeedEventIDBatchParams) ([][]coredb.PaginateInteractionsByFeedEventIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateInteractionsByFeedEventIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateInteractionsByFeedEventIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateInteractionsByPostIDBatch batches and caches requests
type PaginateInteractionsByPostIDBatch struct {
	generator.Dataloader[coredb.PaginateInteractionsByPostIDBatchParams, []coredb.PaginateInteractionsByPostIDBatchRow]
}

// newPaginateInteractionsByPostIDBatch creates a new PaginateInteractionsByPostIDBatch with the given settings, functions, and options
func newPaginateInteractionsByPostIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateInteractionsByPostIDBatch, []coredb.PaginateInteractionsByPostIDBatchParams) ([][]coredb.PaginateInteractionsByPostIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateInteractionsByPostIDBatch {
	d := &PaginateInteractionsByPostIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateInteractionsByPostIDBatchParams) ([][]coredb.PaginateInteractionsByPostIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateInteractionsByPostIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateInteractionsByPostIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginatePostsByCommunityID batches and caches requests
type PaginatePostsByCommunityID struct {
	generator.Dataloader[coredb.PaginatePostsByCommunityIDParams, []coredb.Post]
}

// newPaginatePostsByCommunityID creates a new PaginatePostsByCommunityID with the given settings, functions, and options
func newPaginatePostsByCommunityID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginatePostsByCommunityID, []coredb.PaginatePostsByCommunityIDParams) ([][]coredb.Post, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginatePostsByCommunityID {
	d := &PaginatePostsByCommunityID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginatePostsByCommunityIDParams) ([][]coredb.Post, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginatePostsByCommunityID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginatePostsByCommunityID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginatePostsByContractID batches and caches requests
type PaginatePostsByContractID struct {
	generator.Dataloader[coredb.PaginatePostsByContractIDParams, []coredb.Post]
}

// newPaginatePostsByContractID creates a new PaginatePostsByContractID with the given settings, functions, and options
func newPaginatePostsByContractID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginatePostsByContractID, []coredb.PaginatePostsByContractIDParams) ([][]coredb.Post, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginatePostsByContractID {
	d := &PaginatePostsByContractID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginatePostsByContractIDParams) ([][]coredb.Post, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginatePostsByContractID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginatePostsByContractID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateRepliesByCommentIDBatch batches and caches requests
type PaginateRepliesByCommentIDBatch struct {
	generator.Dataloader[coredb.PaginateRepliesByCommentIDBatchParams, []coredb.Comment]
}

// newPaginateRepliesByCommentIDBatch creates a new PaginateRepliesByCommentIDBatch with the given settings, functions, and options
func newPaginateRepliesByCommentIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateRepliesByCommentIDBatch, []coredb.PaginateRepliesByCommentIDBatchParams) ([][]coredb.Comment, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateRepliesByCommentIDBatch {
	d := &PaginateRepliesByCommentIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateRepliesByCommentIDBatchParams) ([][]coredb.Comment, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateRepliesByCommentIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateRepliesByCommentIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateTokensAdmiredByUserIDBatch batches and caches requests
type PaginateTokensAdmiredByUserIDBatch struct {
	generator.Dataloader[coredb.PaginateTokensAdmiredByUserIDBatchParams, []coredb.PaginateTokensAdmiredByUserIDBatchRow]
}

// newPaginateTokensAdmiredByUserIDBatch creates a new PaginateTokensAdmiredByUserIDBatch with the given settings, functions, and options
func newPaginateTokensAdmiredByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateTokensAdmiredByUserIDBatch, []coredb.PaginateTokensAdmiredByUserIDBatchParams) ([][]coredb.PaginateTokensAdmiredByUserIDBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateTokensAdmiredByUserIDBatch {
	d := &PaginateTokensAdmiredByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateTokensAdmiredByUserIDBatchParams) ([][]coredb.PaginateTokensAdmiredByUserIDBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateTokensAdmiredByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateTokensAdmiredByUserIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// PaginateTokensByCommunityID batches and caches requests
type PaginateTokensByCommunityID struct {
	generator.Dataloader[coredb.PaginateTokensByCommunityIDParams, []coredb.PaginateTokensByCommunityIDRow]
}

// newPaginateTokensByCommunityID creates a new PaginateTokensByCommunityID with the given settings, functions, and options
func newPaginateTokensByCommunityID(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *PaginateTokensByCommunityID, []coredb.PaginateTokensByCommunityIDParams) ([][]coredb.PaginateTokensByCommunityIDRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *PaginateTokensByCommunityID {
	d := &PaginateTokensByCommunityID{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.PaginateTokensByCommunityIDParams) ([][]coredb.PaginateTokensByCommunityIDRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "PaginateTokensByCommunityID")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "PaginateTokensByCommunityID")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetContractCreatorsByIds batches and caches requests
type GetContractCreatorsByIds struct {
	generator.Dataloader[string, coredb.ContractCreator]
}

// newGetContractCreatorsByIds creates a new GetContractCreatorsByIds with the given settings, functions, and options
func newGetContractCreatorsByIds(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetContractCreatorsByIds, []string) ([]coredb.ContractCreator, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetContractCreatorsByIds {
	d := &GetContractCreatorsByIds{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.ContractCreator, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetContractCreatorsByIds")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetContractCreatorsByIds")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetContractsByIDs batches and caches requests
type GetContractsByIDs struct {
	generator.Dataloader[string, coredb.Contract]
}

// newGetContractsByIDs creates a new GetContractsByIDs with the given settings, functions, and options
func newGetContractsByIDs(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetContractsByIDs, []string) ([]coredb.Contract, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetContractsByIDs {
	d := &GetContractsByIDs{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.Contract, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetContractsByIDs")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetContractsByIDs")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}
